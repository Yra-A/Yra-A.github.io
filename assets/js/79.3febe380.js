(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{457:function(_,v,l){"use strict";l.r(v);var t=l(8),i=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("blockquote",[v("p",[_._v("本文是在阅读了 "),v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/408515044",target:"_blank",rel:"noopener noreferrer"}},[_._v("『缓存和数据库一致性问题，看这篇就够了』"),v("OutboundLink")],1),_._v(" 后整理的笔记")])]),_._v(" "),v("h4",{attrs:{id:"全量缓存-后台定时刷新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全量缓存-后台定时刷新"}},[_._v("#")]),_._v(" 全量缓存（后台定时刷新）：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("优点：")]),_._v(" 所有读请求都可以直接命中缓存，性能高")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("缺点：")]),_._v(" 缓存利用率低；数据不一致市场依赖于定时时间")])])]),_._v(" "),v("h4",{attrs:{id:"提高缓存利用率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高缓存利用率"}},[_._v("#")]),_._v(" 提高缓存利用率：")]),_._v(" "),v("ul",[v("li",[_._v("写请求依然全交给数据库，读请求先访问缓存，不存在则访问数据库并更新缓存，缓存中的数据设置过期时间（只读缓存）")])]),_._v(" "),v("h4",{attrs:{id:"数据一致性问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性问题"}},[_._v("#")]),_._v(" 数据一致性问题：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("「第二步」操作失败引发的数据不一致")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("先更新缓存，再更新数据库：如果更新数据库失败，会导致缓存中是新值，数据库中是旧值；缓存失效后，都是旧值")])]),_._v(" "),v("li",[v("p",[_._v("先更新数据库，再更新缓存：如果缓存更新失败，数据库中是新值，缓存中是旧值；缓存失效后重读，才变回一致正确")])])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("并发引发的一致性问题")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("假设先更新数据库，再更新缓存：")])]),_._v(" "),v("li",[v("ol",[v("li",[v("p",[_._v("线程 A 更新数据库 X = 1")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 更新数据库 X = 2")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 更新缓存 X = 2")])]),_._v(" "),v("li",[v("p",[_._v("线程 A 更新缓存 X = 1")])])])]),_._v(" "),v("li",[v("p",[_._v("数据库中为 X = 2，缓存中 X = 1  ===》 数据不一致")])]),_._v(" "),v("li",[v("p",[_._v("「先更新缓存，更新数据库」的方案类似")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("解决方案")]),_._v("：加 「分布式锁」，但会导致性能下降")])])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("「更新数据库 + 更新缓存」 的方案总结")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("数据不一致问题（「操作失败」和「并发」引起）")])]),_._v(" "),v("li",[v("p",[_._v("性能下降问题原因")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("引入分布式锁")])]),_._v(" "),v("li",[v("p",[_._v("每次更新可能都要根据数据库中的数据计算缓存中的值（例如计算个人收到的视频点赞数量，可能需要通过计算个人所有视频的点赞数量总和）")])])])]),_._v(" "),v("li",[v("p",[_._v("缓存利用率低问题原因")]),_._v(" "),v("ul",[v("li",[_._v("更新数据库后，无脑更新缓存，但缓存中的数据未必会被马上读取")])])])])])]),_._v(" "),v("h4",{attrs:{id:"删除缓存方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除缓存方案"}},[_._v("#")]),_._v(" 删除缓存方案")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("『推荐』先更新数据库，后删除缓存")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("在「第二步」操作失败场景下，数据库中是新值，缓存中是旧值，在缓存失效前会产生数据不一致的问题")])]),_._v(" "),v("li",[v("p",[_._v("在并发场景下，发生数据不一致的概率非常低，「如下面的场景所示」")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("线程 A 读，线程 B 写，缓存中 X 失效不存在")])]),_._v(" "),v("li",[v("ol",[v("li",[v("p",[_._v("线程 A 读取数据库得到旧值")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 更新数据库，并删除缓存")])]),_._v(" "),v("li",[v("p",[_._v("线程 A 将旧值写入缓存")])])])]),_._v(" "),v("li",[v("p",[_._v("数据库中是新值，缓存中是旧值")])]),_._v(" "),v("li",[v("p",[_._v("需要满足：1. 缓存失效 2. 两个线程并发读和写 3. 步骤「2」 比 步骤 「1」「3」 短")])]),_._v(" "),v("li",[v("p",[_._v("写数据库往往要「加锁」，第三点发生概率很低")])])])]),_._v(" "),v("li",[v("p",[_._v("为了解决「第二步」操作失败场景下的问题，可以采取方案：「重试」")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("需要考虑的问题有：1. 重试依然可能失败 2. 重试多少次才合理 3. 重试会占用线程资源，无法服务其他客户端请求")])]),_._v(" "),v("li",[v("p",[_._v("更好的方案：「异步重试」")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("独立出一个消息队列服务，将重试消息发送给该服务，异步化的去更新缓存。")])]),_._v(" "),v("li",[v("p",[_._v("好处：独立服务中的队列，直到消息被成功消费之前都不会丢失，且只有成功消费才会删除")])])])])])]),_._v(" "),v("li",[v("p",[_._v("删除缓存的操作还可以通过「订阅数据库变更日志，再操作缓存」，例如阿里的 cannal")])])])])]),_._v(" "),v("img",{staticStyle:{zoom:"25%"},attrs:{src:"https://pic4.zhimg.com/80/v2-3a348fe9dd98f3de29ffb51527133d07_1440w.webp",alt:"img"}}),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("先删除缓存，后更新数据库")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("在「第二步」操作失败场景下，缓存中没有值，数据库没有更新成功，数据满足一致性")])]),_._v(" "),v("li",[v("p",[_._v("在并发场景下，在下面的情况下会发生数据不一致")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("线程 A 写，线程 B 读")])]),_._v(" "),v("li",[v("ol",[v("li",[v("p",[_._v("线程 A 删除缓存")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 读缓存，发生缺失读数据库，得到旧值")])]),_._v(" "),v("li",[v("p",[_._v("线程 A 更新数据库，数据库中是新值")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 将旧值写回缓存")])])])]),_._v(" "),v("li",[v("p",[_._v("数据库中是新值，缓存中是旧值")])])])])])])]),_._v(" "),v("h3",{attrs:{id:"读写分离-主从复制延迟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读写分离-主从复制延迟"}},[_._v("#")]),_._v(" 读写分离 + 主从复制延迟")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("并发场景下依然会数据不一致，即使采用「先更新数据库，后删除缓存」方案")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("线程 A 写，线程 B 读")])]),_._v(" "),v("li",[v("ol",[v("li",[v("p",[_._v("线程 A 删除缓存")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 读取缓存，发生缺失查询从库，得到旧值")])]),_._v(" "),v("li",[v("p",[_._v("从库同步完成，主从库都是新值")])]),_._v(" "),v("li",[v("p",[_._v("线程 B 将旧值写回缓存中")])])])]),_._v(" "),v("li",[v("p",[_._v("主从库中是新值，缓存是旧值")])])])])]),_._v(" "),v("h3",{attrs:{id:"如何解决-1-「先删除缓存-后更新数据库」-方案-和-2-「读写分离-主从复制延迟」-场景下并发导致的数据不一致问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-1-「先删除缓存-后更新数据库」-方案-和-2-「读写分离-主从复制延迟」-场景下并发导致的数据不一致问题"}},[_._v("#")]),_._v(" 如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("「缓存会被回种旧值」是问题的本质")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("「缓存延迟双删策略」")])]),_._v(" "),v("p",[_._v("① 在线程 A 删除缓存，更新数据库 的操作完成后再延迟进行一次缓存删除")]),_._v(" "),v("p",[_._v("② 线程 A 生成一条「延时消息」，写到消息队列中，消费者延时删除缓存")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("延迟时间设置多久？")])]),_._v(" "),v("ul",[v("li",[v("ol",[v("li",[v("p",[_._v("延迟时间要大于「主从复制」的延迟时间")])]),_._v(" "),v("li",[v("p",[_._v("延迟时间要大于线程 B 读取数据库 + 旧值写回缓存的时间")])])])]),_._v(" "),v("li",[v("p",[_._v("在分布式高并发场景下，这个时间很难评估，无法保证极端场景下的数据一致性")])])])])]),_._v(" "),v("h3",{attrs:{id:"总结与心得【转载原文内容】"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结与心得【转载原文内容】"}},[_._v("#")]),_._v(" 总结与心得【转载原文内容】")]),_._v(" "),v("h5",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("​\t1. 想要提高应用的性能，可以引入「缓存」来解决")]),_._v(" "),v("p",[_._v("​\t2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」")]),_._v(" "),v("p",[_._v("​\t3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况")]),_._v(" "),v("p",[_._v("​\t4. 采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估")]),_._v(" "),v("p",[_._v("​\t5. 采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致")]),_._v(" "),v("p",[_._v("​\t6. 采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率")]),_._v(" "),v("h5",{attrs:{id:"四点心得"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四点心得"}},[_._v("#")]),_._v(" 四点心得")]),_._v(" "),v("p",[_._v("​\t1. 性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案")]),_._v(" "),v("p",[_._v("​\t2. 掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题")]),_._v(" "),v("p",[_._v("​\t3. 失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案")]),_._v(" "),v("p",[_._v("​\t4. 订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致")])])}),[],!1,null,null,null);v.default=i.exports}}]);