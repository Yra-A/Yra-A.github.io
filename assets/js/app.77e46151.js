(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,s,o=e[0],l=e[1],c=e[2],d=0,p=[];d<o.length;d++)s=o[d],Object.prototype.hasOwnProperty.call(i,s)&&i[s]&&p.push(i[s][0]),i[s]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,o=1;o<t.length;o++){var l=t[o];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=s(s.s=t[0]))}return n}var r={},i={8:0},a=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,o=document.createElement("script");o.charset="utf-8",o.timeout=120,s.nc&&o.setAttribute("nonce",s.nc),o.src=function(n){return s.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"860e548e",2:"32b4e384",3:"c61f9792",4:"a4d078af",5:"0e88b40f",6:"48079e05",7:"a46ce480",9:"a0c190e4",10:"41939dab",11:"243f6890",12:"f5e152d3",13:"c0317353",14:"32b82f57",15:"38e79c49",16:"77cde8eb",17:"2bbaae2b",18:"7fa83b06",19:"0a1487c5",20:"be977be4",21:"8cad32c6",22:"dd452bde",23:"6f765f33",24:"428856ef",25:"d74da78a",26:"19880d19",27:"1799d7c2",28:"49ffb04f",29:"01df9f19",30:"4bbc0555",31:"8fed8cfa",32:"1f8ccb26",33:"0fae96a7",34:"b04d11cc",35:"fdb6e164",36:"9c147fa6",37:"44516c52",38:"aa61ad21",39:"15e17a00",40:"516456dc",41:"1b20158a",42:"b265a499",43:"d5e24144",44:"2dc120f2",45:"17621cb5",46:"9c0e48f9",47:"46455405",48:"340096c5",49:"a93e5dbb",50:"b02ec1d5",51:"0ddb29bf",52:"03229f3f",53:"7b163e09",54:"6113f617",55:"3efce135",56:"fd2a9e9c",57:"edc23c25",58:"39bed4e5",59:"3a7cd652",60:"b2714d3a",61:"7862a89b",62:"b1c0ba20",63:"b4204344",64:"67b4f8ad",65:"80916048",66:"486fbce2",67:"1193570f",68:"4f61e119",69:"77dd4a51",70:"62a5063b",71:"90e1af10",72:"3c2248c4",73:"1a03a15e",74:"9438976a",75:"fadd2e5c",76:"a9045976",77:"5ba6ce9b",78:"10880cfb",79:"3febe380",80:"d5fed210",81:"db32e7a5",82:"9326140c",83:"915d0b44",84:"e1bff2fa",85:"8bbd228b",86:"7a34741b",87:"15bee76b",88:"ff496e4c",89:"3490fe5c",90:"6c079372",91:"40961190",92:"7b4f2ad8",93:"0da3dbd6",94:"96e8a4ab",95:"eb0d5495",96:"d5d7a8ce"}[n]+".js"}(n);var l=new Error;a=function(e){o.onerror=o.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:o})}),12e4);o.onerror=o.onload=a,document.head.appendChild(o)}return Promise.all(e)},s.m=n,s.c=r,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)s.d(t,r,function(e){return n[e]}.bind(null,r));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/",s.oe=function(n){throw console.error(n),n};var o=window.webpackJsonp=window.webpackJsonp||[],l=o.push.bind(o);o.push=e,o=o.slice();for(var c=0;c<o.length;c++)e(o[c]);var u=l;a.push([131,0]),t()}([function(n,e,t){"use strict";var r=t(10),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not an object")}},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var r=t(9),i=t(3),a=t(146),s=t(0),o=t(1),l=t(87),c=t(127),u=t(148),d=t(4),p=t(11),f=t(16),m=t(88).IteratorPrototype,h=t(6),g=t(24),v=f("toStringTag"),b=TypeError,_=i.Iterator,y=g||!o(_)||_.prototype!==m||!d((function(){_({})})),x=function(){if(a(this,m),l(this)===m)throw new b("Abstract class Iterator not directly constructable")},k=function(n,e){h?c(m,n,{configurable:!0,get:function(){return e},set:function(e){if(s(this),this===m)throw new b("You can't redefine this property");p(this,n)?this[n]=e:u(this,n,e)}}):m[n]=e};p(m,v)||k(v,"Iterator"),!y&&p(m,"constructor")&&m.constructor!==Object||k("constructor",x),x.prototype=m,r({global:!0,constructor:!0,forced:y},{Iterator:x})},function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r=t(33),i=Function.prototype,a=i.call,s=r&&i.bind.bind(a,a);n.exports=r?s:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){"use strict";var r=t(4);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var r=t(1),i=t(49),a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not a function")}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,s,o){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):i&&(l=o?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(3),i=t(70).f,a=t(25),s=t(46),o=t(51),l=t(84),c=t(145);n.exports=function(n,e){var t,u,d,p,f,m=n.target,h=n.global,g=n.stat;if(t=h?r:g?r[m]||o(m,{}):r[m]&&r[m].prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(f=i(t,u))&&f.value:t[u],!c(h?u:m+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),s(t,u,p,n)}}},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){"use strict";var r=t(5),i=t(30),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(33),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var r=t(96),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";var r=t(9),i=t(13),a=t(7),s=t(0),o=t(23),l=t(89),c=t(90),u=t(24),d=l((function(){for(var n,e,t=this.iterator,r=this.predicate,a=this.next;;){if(n=s(i(a,t)),this.done=!!n.done)return;if(e=n.value,c(t,r,[e,this.counter++],!0))return e}}));r({target:"Iterator",proto:!0,real:!0,forced:u},{filter:function(n){return s(this),a(n),new d(o(this),{predicate:n})}})},function(n,e,t){"use strict";var r=t(3),i=t(77),a=t(11),s=t(78),o=t(74),l=t(73),c=r.Symbol,u=i("wks"),d=l?c.for||c:c&&c.withoutSetter||s;n.exports=function(n){return a(u,n)||(u[n]=o&&a(c,n)?c[n]:d("Symbol."+n)),u[n]}},function(n,e,t){"use strict";var r=t(9),i=t(32),a=t(7),s=t(0),o=t(23);r({target:"Iterator",proto:!0,real:!0},{forEach:function(n){s(this),a(n);var e=o(this),t=0;i(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e,t){"use strict";var r=t(6),i=t(79),a=t(81),s=t(0),o=t(71),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(s(n),e=o(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=o(e),s(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(198),i=t(201);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(29),t(2),t(15),t(17),t(21);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,s=/^[a-z]+:/i;function o(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=o(n);return a.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return o(n.path)===o(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=o(e);for(let e=0;e<n.length;e++)if(o(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,r){const{pages:i,themeConfig:a}=t,s=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||s.sidebar||a.sidebar))return h(n);const o=s.sidebar||a.sidebar;if(o){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,o);return"auto"===r?h(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function h(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function _(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return _(e)-_(n)}},function(n,e,t){"use strict";var r=t(9),i=t(154);r({target:"Iterator",proto:!0,real:!0,forced:t(24)},{map:i})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(6),i=t(18),a=t(34);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(28),i=t(183),a=t(184),s=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?i(n):a(n)}},function(n,e,t){"use strict";var r=t(5),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(14).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(9),i=t(30),a=t(31),s=t(177),o=t(179);r({target:"Array",proto:!0,arity:1,forced:t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=a(e),r=arguments.length;o(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){"use strict";var r=t(47),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var r=t(143);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(128),i=t(13),a=t(0),s=t(49),o=t(161),l=t(31),c=t(37),u=t(162),d=t(92),p=t(55),f=TypeError,m=function(n,e){this.stopped=n,this.result=e},h=m.prototype;n.exports=function(n,e,t){var g,v,b,_,y,x,k,w=t&&t.that,q=!(!t||!t.AS_ENTRIES),C=!(!t||!t.IS_RECORD),T=!(!t||!t.IS_ITERATOR),S=!(!t||!t.INTERRUPTED),P=r(e,w),z=function(n){return g&&p(g,"normal",n),new m(!0,n)},I=function(n){return q?(a(n),S?P(n[0],n[1],z):P(n[0],n[1])):S?P(n,z):P(n)};if(C)g=n.iterator;else if(T)g=n;else{if(!(v=d(n)))throw new f(s(n)+" is not iterable");if(o(v)){for(b=0,_=l(n);_>b;b++)if((y=I(n[b]))&&c(h,y))return y;return new m(!1)}g=u(n,v)}for(x=C?n.next:g.next;!(k=i(x,g)).done;){try{y=I(k.value)}catch(n){p(g,"throw",n)}if("object"==typeof y&&y&&c(h,y))return y}return new m(!1)}},function(n,e,t){"use strict";var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(67),i=t(47);n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var r=t(3),i=t(1),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(5);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(7),i=t(48);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e,t){var r=t(188),i=t(189),a=t(190),s=t(191),o=t(192);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var r=t(98);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(19)(Object,"create");n.exports=r},function(n,e,t){var r=t(210);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(63);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,s((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),o(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,u,d)),1===n?(o(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){o(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,s=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return o(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),o=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var r=t(1),i=t(18),a=t(82),s=t(51);n.exports=function(n,e,t,o){o||(o={});var l=o.enumerable,c=void 0!==o.name?o.name:e;if(r(t)&&a(t,c,o),o.global)l?n[e]=t:s(e,t);else{try{o.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(48),i=TypeError;n.exports=function(n){if(r(n))throw new i("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(24),i=t(3),a=t(51),s=n.exports=i["__core-js_shared__"]||a("__core-js_shared__",{});(s.versions||(s.versions=[])).push({version:"3.41.0",mode:r?"pure":"global",copyright:"© 2014-2025 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(3),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";var r=t(77),i=t(78),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r=t(13),i=t(0),a=t(38);n.exports=function(n,e,t){var s,o;i(n);try{if(!(s=a(n,"return"))){if("throw"===e)throw t;return t}s=r(s,n)}catch(n){o=!0,s=n}if("throw"===e)throw t;if(o)throw s;return i(s),t}},function(n,e,t){var r=t(182),i=t(22),a=Object.prototype,s=a.hasOwnProperty,o=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&s.call(n,"callee")&&!o.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(19)(t(14),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(202),i=t(209),a=t(211),s=t(212),o=t(213);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(12),i=t(63),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(s.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(26),i=t(22);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(9),i=t(32),a=t(7),s=t(0),o=t(23);r({target:"Iterator",proto:!0,real:!0},{some:function(n){s(this),a(n);var e=o(this),t=0;return i(e,(function(e,r){if(n(e,t++))return r()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,s=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=o||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,f=function(){return c.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var o=i.test(n);return o||a.test(n)?s(n.slice(2),o?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,s,o,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,s=n.apply(a,t)}function _(n){return c=n,o=setTimeout(x,e),u?b(n):s}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function x(){var n=f();if(y(n))return k(n);o=setTimeout(x,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function k(n){return o=void 0,v&&r?b(n):(r=i=void 0,s)}function w(){var n=f(),t=y(n);if(r=arguments,i=this,l=n,t){if(void 0===o)return _(l);if(g)return o=setTimeout(x,e),b(l)}return void 0===o&&(o=setTimeout(x,e)),s}return e=h(e)||0,m(t)&&(u=!!t.leading,a=(g="maxWait"in t)?d(h(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),w.cancel=function(){void 0!==o&&clearTimeout(o),c=0,r=l=i=o=void 0},w.flush=function(){return void 0===o?s:k(f())},w}},function(n,e,t){"use strict";var r=t(5),i=t(4),a=t(27),s=Object,o=r("".split);n.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"===a(n)?o(n,""):s(n)}:s},function(n,e,t){"use strict";var r,i=t(0),a=t(149),s=t(54),o=t(53),l=t(151),c=t(80),u=t(52),d=u("IE_PROTO"),p=function(){},f=function(n){return"<script>"+n+"<\/script>"},m=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},h=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;h="undefined"!=typeof document?document.domain&&r?m(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):m(r);for(var t=s.length;t--;)delete h.prototype[s[t]];return h()};o[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[d]=n):t=h(),void 0===e?t:a.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var r=t(6),i=t(13),a=t(132),s=t(34),o=t(35),l=t(71),c=t(11),u=t(79),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=o(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return s(!i(a.f,n,e),n[e])}},function(n,e,t){"use strict";var r=t(133),i=t(72);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){"use strict";var r=t(36),i=t(1),a=t(37),s=t(73),o=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,o(n))}},function(n,e,t){"use strict";var r=t(74);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(75),i=t(4),a=t(3).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,i,a=t(3),s=t(76),o=a.process,l=a.Deno,c=o&&o.versions||l&&l.version,u=c&&c.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&s&&(!(r=s.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=s.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){"use strict";var r=t(3).navigator,i=r&&r.userAgent;n.exports=i?String(i):""},function(n,e,t){"use strict";var r=t(50);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";var r=t(5),i=0,a=Math.random(),s=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++i+a,36)}},function(n,e,t){"use strict";var r=t(6),i=t(4),a=t(80);n.exports=!r&&!i((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(3),i=t(10),a=r.document,s=i(a)&&i(a.createElement);n.exports=function(n){return s?a.createElement(n):{}}},function(n,e,t){"use strict";var r=t(6),i=t(4);n.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(5),i=t(4),a=t(1),s=t(11),o=t(6),l=t(135).CONFIGURABLE,c=t(136),u=t(83),d=u.enforce,p=u.get,f=String,m=Object.defineProperty,h=r("".slice),g=r("".replace),v=r([].join),b=o&&!i((function(){return 8!==m((function(){}),"length",{value:8}).length})),_=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===h(f(e),0,7)&&(e="["+g(f(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||l&&n.name!==e)&&(o?m(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&s(t,"arity")&&n.length!==t.arity&&m(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?o&&m(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return s(r,"source")||(r.source=v(_,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var r,i,a,s=t(137),o=t(3),l=t(10),c=t(25),u=t(11),d=t(50),p=t(52),f=t(53),m=o.TypeError,h=o.WeakMap;if(s||d.state){var g=d.state||(d.state=new h);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw new m("Object already initialized");return e.facade=n,g.set(n,e),e},i=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=p("state");f[v]=!0,r=function(n,e){if(u(n,v))throw new m("Object already initialized");return e.facade=n,c(n,v,e),e},i=function(n){return u(n,v)?n[v]:{}},a=function(n){return u(n,v)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw new m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(11),i=t(138),a=t(70),s=t(18);n.exports=function(n,e,t){for(var o=i(e),l=s.f,c=a.f,u=0;u<o.length;u++){var d=o[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var r=t(5),i=t(11),a=t(35),s=t(140).indexOf,o=t(53),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,u=[];for(t in r)!i(o,t)&&i(r,t)&&l(u,t);for(;e.length>c;)i(r,t=e[c++])&&(~s(u,t)||l(u,t));return u}},function(n,e,t){"use strict";var r=t(142);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(11),i=t(1),a=t(30),s=t(52),o=t(147),l=s("IE_PROTO"),c=Object,u=c.prototype;n.exports=o?c.getPrototypeOf:function(n){var e=a(n);if(r(e,l))return e[l];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof c?u:null}},function(n,e,t){"use strict";var r,i,a,s=t(4),o=t(1),l=t(10),c=t(68),u=t(87),d=t(46),p=t(16),f=t(24),m=p("iterator"),h=!1;[].keys&&("next"in(a=[].keys())?(i=u(u(a)))!==Object.prototype&&(r=i):h=!0),!l(r)||s((function(){var n={};return r[m].call(n)!==n}))?r={}:f&&(r=c(r)),o(r[m])||d(r,m,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){"use strict";var r=t(13),i=t(68),a=t(25),s=t(152),o=t(16),l=t(83),c=t(38),u=t(88).IteratorPrototype,d=t(153),p=t(55),f=o("toStringTag"),m=l.set,h=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return s(i(u),{next:function(){var t=e(this);if(n)return t.nextHandler();if(t.done)return d(void 0,!0);try{var r=t.nextHandler();return t.returnHandlerResult?r:d(r,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),i=t.iterator;if(t.done=!0,n){var a=c(i,"return");return a?r(a,i):d(void 0,!0)}if(t.inner)try{p(t.inner.iterator,"normal")}catch(n){return p(i,"throw",n)}return i&&p(i,"normal"),d(void 0,!0)}})},g=h(!0),v=h(!1);a(v,f,"Iterator Helper"),n.exports=function(n,e,t){var r=function(r,i){i?(i.iterator=r.iterator,i.next=r.next):i=r,i.type=e?"WrapForValidIterator":"IteratorHelper",i.returnHandlerResult=!!t,i.nextHandler=n,i.counter=0,i.done=!1,m(this,i)};return r.prototype=e?g:v,r}},function(n,e,t){"use strict";var r=t(0),i=t(55);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var r=t(93),i=t(38),a=t(48),s=t(91),o=t(16)("iterator");n.exports=function(n){if(!a(n))return i(n,o)||i(n,"@@iterator")||s[r(n)]}},function(n,e,t){"use strict";var r=t(163),i=t(1),a=t(27),s=t(16)("toStringTag"),o=Object,l="Arguments"===a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=o(n),s))?t:l?a(e):"Object"===(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r=t(167),i=t(10),a=t(47),s=t(168);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),s(r),i(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(39),i=t(193),a=t(194),s=t(195),o=t(196),l=t(197);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=s,c.prototype.has=o,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(26),i=t(58);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(214),i=t(22);n.exports=function n(e,t,a,s,o){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,s,n,o))}},function(n,e,t){var r=t(103),i=t(217),a=t(104);n.exports=function(n,e,t,s,o,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),f=l.get(e);if(p&&f)return p==e&&f==n;var m=-1,h=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++m<u;){var v=n[m],b=e[m];if(s)var _=c?s(b,v,m,e,n,l):s(v,b,m,n,e,l);if(void 0!==_){if(_)continue;h=!1;break}if(g){if(!i(e,(function(n,e){if(!a(g,e)&&(v===n||o(v,n,t,s,l)))return g.push(e)}))){h=!1;break}}else if(v!==b&&!o(v,b,t,s,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var r=t(59),i=t(215),a=t(216);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=i,s.prototype.has=a,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(227),i=t(233),a=t(109);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(14),i=t(229),a=e&&!e.nodeType&&e,s=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===a?r.Buffer:void 0,l=(o?o.isBuffer:void 0)||i;n.exports=l}).call(this,t(69)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(230),i=t(231),a=t(232),s=a&&a.isTypedArray,o=s?i(s):r;n.exports=o},function(n,e,t){var r=t(99),i=t(61);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(19)(t(14),"Set");n.exports=r},function(n,e,t){var r=t(58);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(114),i=t(43);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(12),i=t(62),a=t(244),s=t(247);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(180),i=t(185),a=t(256),s=t(264),o=t(273),l=t(125),c=a((function(n){var e=l(n);return o(e)&&(e=void 0),s(r(n,1,o,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",s=0,o=0;for(s=i.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}o!==s&&(a+=t.substring(o,s)),o=s+1,a+=e}return o!==s?a+t.substring(o,s):a}},function(n,e,t){var r;"undefined"!=typeof self&&self,r=function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return n[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=7)}([function(n,e,t){n.exports=!t(6)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e){n.exports=function(n,e,t,r,i){var a,s=n=n||{},o=typeof n.default;"object"!==o&&"function"!==o||(a=n,s=n.default);var l,c="function"==typeof s?s.options:s;if(e&&(c.render=e.render,c.staticRenderFns=e.staticRenderFns),r&&(c._scopeId=r),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),t&&t.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):t&&(l=t),l){var u=c.functional,d=u?c.render:c.beforeCreate;u?c.render=function(n,e){return l.call(e),d(n,e)}:c.beforeCreate=d?[].concat(d,l):[l]}return{esModule:a,exports:s,options:c}}},function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(n,e){var t=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=t)},function(n,e,t){var r=t(23),i=t(24),a=t(26),s=Object.defineProperty;e.f=t(0)?Object.defineProperty:function(n,e,t){if(r(n),e=a(e,!0),r(t),i)try{return s(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r,i,a;i=[e,t(8),t(11)],void 0===(a="function"==typeof(r=function(n,e,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Tabs=n.Tab=void 0;var r=a(e),i=a(t);function a(n){return n&&n.__esModule?n:{default:n}}n.default={install:function(n){n.component("tab",r.default),n.component("tabs",i.default)}},n.Tab=r.default,n.Tabs=i.default})?r.apply(e,i):r)||(n.exports=a)},function(n,e,t){var r=t(2)(t(9),t(10),null,null,null);n.exports=r.exports},function(n,e,t){var r,i,a;i=[e],void 0===(a="function"==typeof(r=function(n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={props:{id:{default:null},name:{required:!0},prefix:{default:""},suffix:{default:""},isDisabled:{default:!1}},data:function(){return{isActive:!1,isVisible:!0}},computed:{header:function(){return this.prefix+this.name+this.suffix},computedId:function(){return this.id?this.id:this.name.toLowerCase().replace(/ /g,"-")},hash:function(){return this.isDisabled?"#":"#"+this.computedId}}}})?r.apply(e,i):r)||(n.exports=a)},function(n,e){n.exports={render:function(){var n=this.$createElement;return(this._self._c||n)("section",{directives:[{name:"show",rawName:"v-show",value:this.isActive,expression:"isActive"}],staticClass:"tabs-component-panel",attrs:{"aria-hidden":!this.isActive,id:this.computedId,role:"tabpanel"}},[this._t("default")],2)},staticRenderFns:[]}},function(n,e,t){var r=t(2)(t(12),t(29),null,null,null);n.exports=r.exports},function(n,e,t){var r,i,a;i=[e,t(13)],void 0===(a="function"==typeof(r=function(n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t,r=(t=e)&&t.__esModule?t:{default:t};n.default={props:{cacheLifetime:{default:5},options:{type:Object,required:!1,default:function(){return{useUrlFragment:!0,defaultTabHash:null}}}},data:function(){return{tabs:[],activeTabHash:"",activeTabIndex:0,lastActiveTabHash:""}},computed:{storageKey:function(){return"vue-tabs-component.cache."+window.location.host+window.location.pathname}},created:function(){this.tabs=this.$children},mounted:function(){var n=this;if(window.addEventListener("hashchange",(function(){return n.selectTab(window.location.hash)})),this.findTab(window.location.hash))this.selectTab(window.location.hash);else{var e=r.default.get(this.storageKey);this.findTab(e)?this.selectTab(e):null!==this.options.defaultTabHash&&this.findTab("#"+this.options.defaultTabHash)?this.selectTab("#"+this.options.defaultTabHash):this.tabs.length&&this.selectTab(this.tabs[0].hash)}},methods:{findTab:function(n){return this.tabs.find((function(e){return e.hash===n}))},selectTab:function(n,e){e&&!this.options.useUrlFragment&&e.preventDefault();var t=this.findTab(n);t&&(t.isDisabled?e.preventDefault():this.lastActiveTabHash!==t.hash?(this.tabs.forEach((function(n){n.isActive=n.hash===t.hash})),this.$emit("changed",{tab:t}),this.activeTabHash=t.hash,this.activeTabIndex=this.getTabIndex(n),this.lastActiveTabHash=this.activeTabHash=t.hash,r.default.set(this.storageKey,t.hash,this.cacheLifetime)):this.$emit("clicked",{tab:t}))},setTabVisible:function(n,e){var t=this.findTab(n);t&&(t.isVisible=e,t.isActive&&(t.isActive=e,this.tabs.every((function(n,e,t){return!n.isVisible||(n.isActive=!0,!1)}))))},getTabIndex:function(n){var e=this.findTab(n);return this.tabs.indexOf(e)},getTabHash:function(n){var e=this,t=this.tabs.find((function(t){return e.tabs.indexOf(t)===n}));if(t)return t.hash},getActiveTab:function(){return this.findTab(this.activeTabHash)},getActiveTabIndex:function(){return this.getTabIndex(this.activeTabHash)}}}})?r.apply(e,i):r)||(n.exports=a)},function(n,e,t){var r,i,a;i=[e,t(14),t(15)],void 0===(a="function"==typeof(r=function(n,e,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=a(e),i=a(t);function a(n){return n&&n.__esModule?n:{default:n}}var s=function(){function n(){(0,r.default)(this,n)}return(0,i.default)(n,[{key:"get",value:function(n){var e=JSON.parse(localStorage.getItem(n));return e?new Date(e.expires)<new Date?(localStorage.removeItem(n),null):e.value:null}},{key:"set",value:function(n,e,t){var r=(new Date).getTime(),i=new Date(r+6e4*t);localStorage.setItem(n,JSON.stringify({value:e,expires:i}))}}]),n}();n.default=new s})?r.apply(e,i):r)||(n.exports=a)},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}},function(n,e,t){"use strict";e.__esModule=!0;var r,i=t(16),a=(r=i)&&r.__esModule?r:{default:r};e.default=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),(0,a.default)(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}()},function(n,e,t){n.exports={default:t(17),__esModule:!0}},function(n,e,t){t(18);var r=t(4).Object;n.exports=function(n,e,t){return r.defineProperty(n,e,t)}},function(n,e,t){var r=t(19);r(r.S+r.F*!t(0),"Object",{defineProperty:t(5).f})},function(n,e,t){var r=t(3),i=t(4),a=t(20),s=t(22),o=t(28),l=function(n,e,t){var c,u,d,p=n&l.F,f=n&l.G,m=n&l.S,h=n&l.P,g=n&l.B,v=n&l.W,b=f?i:i[e]||(i[e]={}),_=b.prototype,y=f?r:m?r[e]:(r[e]||{}).prototype;for(c in f&&(t=e),t)(u=!p&&y&&void 0!==y[c])&&o(b,c)||(d=u?y[c]:t[c],b[c]=f&&"function"!=typeof y[c]?t[c]:g&&u?a(d,r):v&&y[c]==d?function(n){var e=function(e,t,r){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(e);case 2:return new n(e,t)}return new n(e,t,r)}return n.apply(this,arguments)};return e.prototype=n.prototype,e}(d):h&&"function"==typeof d?a(Function.call,d):d,h&&((b.virtual||(b.virtual={}))[c]=d,n&l.R&&_&&!_[c]&&s(_,c,d)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},function(n,e,t){var r=t(21);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,i){return n.call(e,t,r,i)}}return function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},function(n,e,t){var r=t(5),i=t(27);n.exports=t(0)?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(1);n.exports=function(n){if(!r(n))throw TypeError(n+" is not an object!");return n}},function(n,e,t){n.exports=!t(0)&&!t(6)((function(){return 7!=Object.defineProperty(t(25)("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(1),i=t(3).document,a=r(i)&&r(i.createElement);n.exports=function(n){return a?i.createElement(n):{}}},function(n,e,t){var r=t(1);n.exports=function(n,e){if(!r(n))return n;var t,i;if(e&&"function"==typeof(t=n.toString)&&!r(i=t.call(n)))return i;if("function"==typeof(t=n.valueOf)&&!r(i=t.call(n)))return i;if(!e&&"function"==typeof(t=n.toString)&&!r(i=t.call(n)))return i;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e){n.exports={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"tabs-component"},[t("ul",{staticClass:"tabs-component-tabs",attrs:{role:"tablist"}},n._l(n.tabs,(function(e,r){return t("li",{directives:[{name:"show",rawName:"v-show",value:e.isVisible,expression:"tab.isVisible"}],key:r,staticClass:"tabs-component-tab",class:{"is-active":e.isActive,"is-disabled":e.isDisabled},attrs:{role:"presentation"}},[t("a",{staticClass:"tabs-component-tab-a",attrs:{"aria-controls":e.hash,"aria-selected":e.isActive,href:e.hash,role:"tab"},domProps:{innerHTML:n._s(e.header)},on:{click:function(t){n.selectTab(e.hash,t)}}})])}))),n._v(" "),t("div",{staticClass:"tabs-component-panels"},[n._t("default")],2)])},staticRenderFns:[]}}])},n.exports=r()},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(280),i=t(281),a=t(282),s=!1,o=t(283).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),u=/^\uFEFF/;function d(n,t){var i,a,s=t.views,o=/^[A-Za-z]+:\\|^\//.exec(n);if(o&&o.length)i=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(i=a)),i||Array.isArray(s)&&s.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(i=a),!i)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return i}function p(n,t){var r,i=n.filename,a=arguments.length>1;if(n.cache){if(!i)throw new Error("cache option requires a filename");if(r=e.cache.get(i))return r;a||(t=m(i).toString().replace(u,""))}else if(!a){if(!i)throw new Error("Internal EJS error: no file name or template provided");t=m(i).toString().replace(u,"")}return r=e.compile(t,n),n.cache&&e.cache.set(i,r),r}function f(n,t,r){var i;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(i=p(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{i=p(n)(t)}catch(n){return r(n)}r(null,i)}function m(n){return e.fileLoader(n)}function h(n,e,t,r,i){var a=e.split("\n"),s=Math.max(r-3,0),o=Math.min(a.length,r+3),l=i(t),c=a.slice(s,o).map((function(n,e){var t=e+s+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=i.dirname,a=i.extname,s=(0,i.resolve)(t?e:r(e),n);return a(n)||(s+=".ejs"),s},e.compile=function(n,e){return e&&e.scope&&(s||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),s=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var r=e||{},i=t||{};return 2==arguments.length&&a.shallowCopyFromList(i,r,l),p(i,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),i=r.shift(),s={filename:i};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(s,r.pop()):(e.settings&&(e.settings.views&&(s.views=e.settings.views),e.settings["view cache"]&&(s.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(s,t)),a.shallowCopyFromList(s,e,c)),s.filename=i):e={},f(s,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,s="",o="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),s+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(s+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",u=0;u<r.destructuredLocals.length;u++){var f=r.destructuredLocals[u];u>0&&(c+=",\n  "),c+=f+" = __locals."+f}s+=c+";\n"}!1!==r._with&&(s+="  with ("+r.localsName+" || {}) {\n",o+="  }\n"),o+="  return __output;\n",this.source=s+this.source+o}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+h.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var m=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var i=a.shallowCopy({},n);return t&&(i=a.shallowCopy(i,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=d(n,t),p(t)}(e,r)(i)},h])};if(m.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,v=i.basename(g,i.extname(g));try{Object.defineProperty(m,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return m},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),i=this.opts.delimiter,s=this.opts.openDelimiter,o=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var p,f,h,g,b,_;if(0===l.indexOf(s+i)&&0!==l.indexOf(s+i+i)&&(f=r[c+2])!=i+o&&f!="-"+i+o&&f!="_"+i+o)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(h=l.match(/^\s*include\s+(\S+)/))&&(p=r[c-1])&&(p==s+i||p==s+i+"-"||p==s+i+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,r,i=a.shallowCopy({},e);r=m(t=d(n,i)).toString().replace(u,""),i.filename=t;var s=new v(r,i);return s.generateSource(),{source:s.source,filename:t,template:r}}(h[1],g),_=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=_,void t.dependencies.push(e.resolveInclude(h[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),i=[];r;)0!==(n=r.index)&&(i.push(e.substring(0,n)),e=e.slice(n)),i.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&i.push(e),i},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,i=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=v.modes.EVAL;break;case r+t+"=":this.mode=v.modes.ESCAPED;break;case r+t+"-":this.mode=v.modes.RAW;break;case r+t+"#":this.mode=v.modes.COMMENT;break;case r+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+i:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+i,t+i)+'")\n';break;case t+i:case"-"+t+i:case"_"+t+i:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=o,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(276),t(8)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"5a3e6e86",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(2),t(15),t(17),t(21);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(277),t(8)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"392329f0",null);e.default=a.exports},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(93),i=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){"use strict";var r=t(82),i=t(18);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){"use strict";var r=t(160),i=t(7),a=t(33),s=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?s(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){"use strict";var r=t(9),i=t(3),a=t(165),s=t(166),o=i.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(o&&o[n]){var t={};t[n]=s("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(9),i=t(32),a=t(7),s=t(0),o=t(23);r({target:"Iterator",proto:!0,real:!0},{every:function(n){s(this),a(n);var e=o(this),t=0;return!i(e,(function(e,r){if(!n(e,t++))return r()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){n.exports=t(288)},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(13),i=t(10),a=t(72),s=t(38),o=t(134),l=t(16),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,l=s(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||a(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),o(n,e)}},function(n,e,t){"use strict";var r=t(13),i=t(1),a=t(10),s=TypeError;n.exports=function(n,e){var t,o;if("string"===e&&i(t=n.toString)&&!a(o=r(t,n)))return o;if(i(t=n.valueOf)&&!a(o=r(t,n)))return o;if("string"!==e&&i(t=n.toString)&&!a(o=r(t,n)))return o;throw new s("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(6),i=t(11),a=Function.prototype,s=r&&Object.getOwnPropertyDescriptor,o=i(a,"name"),l=o&&"something"===function(){}.name,c=o&&(!r||r&&s(a,"name").configurable);n.exports={EXISTS:o,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var r=t(5),i=t(1),a=t(50),s=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return s(n)}),n.exports=a.inspectSource},function(n,e,t){"use strict";var r=t(3),i=t(1),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){"use strict";var r=t(36),i=t(5),a=t(139),s=t(144),o=t(0),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(o(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(85),i=t(54).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(35),i=t(141),a=t(31),s=function(n){return function(e,t,s){var o=r(e),l=a(o);if(0===l)return!n&&-1;var c,u=i(s,l);if(n&&t!=t){for(;l>u;)if((c=o[u++])!=c)return!0}else for(;l>u;u++)if((n||u in o)&&o[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){"use strict";var r=t(86),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:r)(e)}},function(n,e,t){"use strict";var r=t(86),i=Math.min;n.exports=function(n){var e=r(n);return e>0?i(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(4),i=t(1),a=/#|\.prototype\./,s=function(n,e){var t=l[o(n)];return t===u||t!==c&&(i(e)?r(e):!!e)},o=s.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",u=s.POLYFILL="P";n.exports=s},function(n,e,t){"use strict";var r=t(37),i=TypeError;n.exports=function(n,e){if(r(e,n))return n;throw new i("Incorrect invocation")}},function(n,e,t){"use strict";var r=t(4);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var r=t(6),i=t(18),a=t(34);n.exports=function(n,e,t){r?i.f(n,e,a(0,t)):n[e]=t}},function(n,e,t){"use strict";var r=t(6),i=t(81),a=t(18),s=t(0),o=t(35),l=t(150);e.f=r&&!i?Object.defineProperties:function(n,e){s(n);for(var t,r=o(e),i=l(e),c=i.length,u=0;c>u;)a.f(n,t=i[u++],r[t]);return n}},function(n,e,t){"use strict";var r=t(85),i=t(54);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(36);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(46);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var r=t(13),i=t(7),a=t(0),s=t(23),o=t(89),l=t(90),c=o((function(){var n=this.iterator,e=a(r(this.next,n));if(!(this.done=!!e.done))return l(n,this.mapper,[e.value,this.counter++],!0)}));n.exports=function(n){return a(this),i(n),new c(s(this),{mapper:n})}},function(n,e,t){"use strict";var r=t(9),i=t(156).left,a=t(157),s=t(75);r({target:"Array",proto:!0,forced:!t(158)&&s>79&&s<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(7),i=t(30),a=t(67),s=t(31),o=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,u){var d=i(e),p=a(d),f=s(d);if(r(t),0===f&&c<2)throw new o(l);var m=n?f-1:0,h=n?-1:1;if(c<2)for(;;){if(m in p){u=p[m],m+=h;break}if(m+=h,n?m<0:f<=m)throw new o(l)}for(;n?m>=0:f>m;m+=h)m in p&&(u=t(u,p[m],m,d));return u}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(159);n.exports="NODE"===r},function(n,e,t){"use strict";var r=t(3),i=t(76),a=t(27),s=function(n){return i.slice(0,n.length)===n};n.exports=s("Bun/")?"BUN":s("Cloudflare-Workers")?"CLOUDFLARE":s("Deno/")?"DENO":s("Node.js/")?"NODE":r.Bun&&"string"==typeof Bun.version?"BUN":r.Deno&&"object"==typeof Deno.version?"DENO":"process"===a(r.process)?"NODE":r.window&&r.document?"BROWSER":"REST"},function(n,e,t){"use strict";var r=t(27),i=t(5);n.exports=function(n){if("Function"===r(n))return i(n)}},function(n,e,t){"use strict";var r=t(16),i=t(91),a=r("iterator"),s=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||s[a]===n)}},function(n,e,t){"use strict";var r=t(13),i=t(7),a=t(0),s=t(49),o=t(92),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?o(n):e;if(i(t))return a(r(t,n));throw new l(s(n)+" is not iterable")}},function(n,e,t){"use strict";var r={};r[t(16)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(9),i=t(32),a=t(7),s=t(0),o=t(23),l=TypeError;r({target:"Iterator",proto:!0,real:!0},{reduce:function(n){s(this),a(n);var e=o(this),t=arguments.length<2,r=t?void 0:arguments[1],c=0;if(i(e,(function(e){t?(t=!1,r=e):r=n(r,e,c),c++}),{IS_RECORD:!0}),t)throw new l("Reduce of empty iterator with no initial value");return r}})},function(n,e,t){"use strict";var r=t(33),i=Function.prototype,a=i.apply,s=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?s.bind(a):function(){return s.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(36),i=t(11),a=t(25),s=t(37),o=t(94),l=t(84),c=t(170),u=t(171),d=t(172),p=t(173),f=t(174),m=t(6),h=t(24);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),_=b[b.length-1],y=r.apply(null,b);if(y){var x=y.prototype;if(!h&&i(x,"cause")&&delete x.cause,!t)return y;var k=r("Error"),w=e((function(n,e){var t=d(g?e:n,void 0),r=g?new y(n):new y;return void 0!==t&&a(r,"message",t),f(r,w,r.stack,2),this&&s(x,this)&&u(r,this,w),arguments.length>v&&p(r,arguments[v]),r}));if(w.prototype=x,"Error"!==_?o?o(w,k):l(w,k,{name:!0}):m&&"stackTraceLimit"in y&&(c(w,y,"stackTraceLimit"),c(w,y,"prepareStackTrace")),l(w,y),!h)try{x.name!==_&&a(x,"name",_),x.constructor=w}catch(n){}return w}}},function(n,e,t){"use strict";var r=t(5),i=t(7);n.exports=function(n,e,t){try{return r(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(169),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(10);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(18).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(10),a=t(94);n.exports=function(n,e,t){var s,o;return a&&r(s=e.constructor)&&s!==t&&i(o=s.prototype)&&o!==t.prototype&&a(n,o),n}},function(n,e,t){"use strict";var r=t(126);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(10),i=t(25);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(25),i=t(175),a=t(176),s=Error.captureStackTrace;n.exports=function(n,e,t,o){a&&(s?s(n,e):r(n,"stack",i(t,o)))}},function(n,e,t){"use strict";var r=t(5),i=Error,a=r("".replace),s=String(new i("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,o,"");return n}},function(n,e,t){"use strict";var r=t(4),i=t(34);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(6),i=t(178),a=TypeError,s=Object.getOwnPropertyDescriptor,o=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=o?function(n,e){if(i(n)&&!s(n,"length").writable)throw new a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(27);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(95),i=t(181);n.exports=function n(e,t,a,s,o){var l=-1,c=e.length;for(a||(a=i),o||(o=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,s,o):r(o,u):s||(o[o.length]=u)}return o}},function(n,e,t){var r=t(28),i=t(56),a=t(12),s=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(s&&n&&n[s])}},function(n,e,t){var r=t(26),i=t(22);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(28),i=Object.prototype,a=i.hasOwnProperty,s=i.toString,o=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,o),t=n[o];try{n[o]=void 0;var r=!0}catch(n){}var i=s.call(n);return r&&(e?n[o]=t:delete n[o]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(186),i=t(242),a=t(64),s=t(12),o=t(253);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?s(n)?i(n[0],n[1]):r(n):o(n)}},function(n,e,t){var r=t(187),i=t(241),a=t(112);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(97),i=t(101);n.exports=function(n,e,t,a){var s=t.length,o=s,l=!a;if(null==n)return!o;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<o;){var u=(c=t[s])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var f=new r;if(a)var m=a(d,p,u,n,e,f);if(!(void 0===m?i(p,d,3,a,f):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(40),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(40);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(40);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(40);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(39);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(39),i=t(57),a=t(59);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var s=t.__data__;if(!i||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(99),i=t(199),a=t(58),s=t(100),o=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:o).test(s(n))}},function(n,e,t){var r,i=t(200),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(14)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(203),i=t(39),a=t(57);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(204),i=t(205),a=t(206),s=t(207),o=t(208);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var r=t(41);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(41),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(41),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(41);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(42);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(42);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(42);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(42);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(97),i=t(102),a=t(218),s=t(221),o=t(237),l=t(12),c=t(106),u=t(108),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,m,h){var g=l(n),v=l(e),b=g?"[object Array]":o(n),_=v?"[object Array]":o(e),y=(b="[object Arguments]"==b?d:b)==d,x=(_="[object Arguments]"==_?d:_)==d,k=b==_;if(k&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(k&&!y)return h||(h=new r),g||u(n)?i(n,e,t,f,m,h):a(n,e,b,t,f,m,h);if(!(1&t)){var w=y&&p.call(n,"__wrapped__"),q=x&&p.call(e,"__wrapped__");if(w||q){var C=w?n.value():n,T=q?e.value():e;return h||(h=new r),m(C,T,t,f,h)}}return!!k&&(h||(h=new r),s(n,e,t,f,m,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(28),i=t(219),a=t(98),s=t(102),o=t(220),l=t(60),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=o;case"[object Set]":var m=1&r;if(f||(f=l),n.size!=e.size&&!m)return!1;var h=p.get(n);if(h)return h==e;r|=2,p.set(n,e);var g=s(f(n),f(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(14).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(222),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,s,o){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:i.call(e,p)))return!1}var f=o.get(n),m=o.get(e);if(f&&m)return f==e&&m==n;var h=!0;o.set(n,e),o.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],b=e[p];if(a)var _=l?a(b,v,p,e,n,o):a(v,b,p,n,e,o);if(!(void 0===_?v===b||s(v,b,t,a,o):_)){h=!1;break}g||(g="constructor"==p)}if(h&&!g){var y=n.constructor,x=e.constructor;y==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof x&&x instanceof x||(h=!1)}return o.delete(n),o.delete(e),h}},function(n,e,t){var r=t(223),i=t(224),a=t(105);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(95),i=t(12);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(225),i=t(226),a=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,o=s?function(n){return null==n?[]:(n=Object(n),r(s(n),(function(e){return a.call(n,e)})))}:i;n.exports=o},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var s=n[t];e(s,t,n)&&(a[i++]=s)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(228),i=t(56),a=t(12),s=t(106),o=t(107),l=t(108),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&i(n),d=!t&&!u&&s(n),p=!t&&!u&&!d&&l(n),f=t||u||d||p,m=f?r(n.length,String):[],h=m.length;for(var g in n)!e&&!c.call(n,g)||f&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||o(g,h))||m.push(g);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(26),i=t(61),a=t(22),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!s[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(96),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===i&&r.process,o=function(){try{var n=a&&a.require&&a.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=o}).call(this,t(69)(n))},function(n,e,t){var r=t(234),i=t(235),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(236)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(238),i=t(57),a=t(239),s=t(110),o=t(240),l=t(26),c=t(100),u=c(r),d=c(i),p=c(a),f=c(s),m=c(o),h=l;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=h(new i)||a&&"[object Promise]"!=h(a.resolve())||s&&"[object Set]"!=h(new s)||o&&"[object WeakMap]"!=h(new o))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case f:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(19)(t(14),"DataView");n.exports=r},function(n,e,t){var r=t(19)(t(14),"Promise");n.exports=r},function(n,e,t){var r=t(19)(t(14),"WeakMap");n.exports=r},function(n,e,t){var r=t(111),i=t(105);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],s=n[a];e[t]=[a,s,r(s)]}return e}},function(n,e,t){var r=t(101),i=t(243),a=t(250),s=t(62),o=t(111),l=t(112),c=t(43);n.exports=function(n,e){return s(n)&&o(e)?l(c(n),e):function(t){var s=i(t,n);return void 0===s&&s===e?a(t,n):r(e,s,3)}}},function(n,e,t){var r=t(113);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(245),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,s=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var r=t(246);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(59);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var s=n.apply(this,r);return t.cache=a.set(i,s)||a,s};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(248);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(28),i=t(249),a=t(12),s=t(63),o=r?r.prototype:void 0,l=o?o.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(251),i=t(252);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(114),i=t(56),a=t(12),s=t(107),o=t(61),l=t(43);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&o(u)&&s(p,u)&&(a(n)||i(n))}},function(n,e,t){var r=t(254),i=t(255),a=t(62),s=t(43);n.exports=function(n){return a(n)?r(s(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(113);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(64),i=t(257),a=t(259);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(258),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,s=-1,o=i(a.length-e,0),l=Array(o);++s<o;)l[s]=a[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=a[s];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(260),i=t(263)(r);n.exports=i},function(n,e,t){var r=t(261),i=t(262),a=t(64),s=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(19),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(103),i=t(265),a=t(270),s=t(104),o=t(271),l=t(60);n.exports=function(n,e,t){var c=-1,u=i,d=n.length,p=!0,f=[],m=f;if(t)p=!1,u=a;else if(d>=200){var h=e?null:o(n);if(h)return l(h);p=!1,u=s,m=new r}else m=e?[]:f;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=m.length;b--;)if(m[b]===v)continue n;e&&m.push(v),f.push(g)}else u(m,v,t)||(m!==f&&m.push(v),f.push(g))}return f}},function(n,e,t){var r=t(266);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(267),i=t(268),a=t(269);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(110),i=t(272),a=t(60),s=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(109),i=t(22);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(115)},function(n,e,t){"use strict";t(116)},function(n,e,t){},function(n,e,t){},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var i=n[r];"."===i?n.splice(r,1):".."===i?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var a=i>=0?arguments[i]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),s="/"===i(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&s&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var i=r(n.split("/")),a=r(t.split("/")),s=Math.min(i.length,a.length),o=s,l=0;l<s;l++)if(i[l]!==a[l]){o=l;break}var c=[];for(l=o;l<i.length;l++)c.push("..");return(c=c.concat(a.slice(o))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,i=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!i){r=a;break}}else i=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,i=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!i){t=e+1;break}}else-1===r&&(i=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,i=!0,a=0,s=n.length-1;s>=0;--s){var o=n.charCodeAt(s);if(47!==o)-1===r&&(i=!1,r=s+1),46===o?-1===e?e=s:1!==a&&(a=1):-1!==e&&(a=-1);else if(!i){t=s+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var i="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function s(n){return i[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,s)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var i=t[r];void 0!==e[i]&&(n[i]=e[i])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(117)},function(n,e,t){"use strict";t(118)},function(n,e,t){"use strict";t.r(e);t(2),t(15),t(21);var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function f(n){return"[object RegExp]"===d.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,v,2):String(n)}function v(n,e){return e&&e.__v_isRef?e.value:e}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function _(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}_("slot,component",!0);var y=_("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var k=Object.prototype.hasOwnProperty;function w(n,e){return k.call(n,e)}function q(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var C=/-(\w)/g,T=q((function(n){return n.replace(C,(function(n,e){return e?e.toUpperCase():""}))})),S=q((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),P=/\B([A-Z])/g,z=q((function(n){return n.replace(P,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function L(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function E(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&E(e,n[t]);return e}function j(n,e,t){}var N=function(n,e,t){return!1},O=function(n){return n};function R(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return R(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var s=Object.keys(n),o=Object.keys(e);return s.length===o.length&&s.every((function(t){return R(n[t],e[t])}))}catch(n){return!1}}function B(n,e){for(var t=0;t<n.length;t++)if(R(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function D(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var $=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:N,isReservedAttr:N,isUnknownElement:N,getTagNamespace:j,parsePlatformTagName:O,mustUseProp:N,async:!0,_lifecycleHooks:F},W=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function G(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function Y(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(W.source,".$_\\d]"));var Z="__proto__"in{},H="undefined"!=typeof window,Q=H&&window.navigator.userAgent.toLowerCase(),K=Q&&/msie|trident/.test(Q),X=Q&&Q.indexOf("msie 9.0")>0,J=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var nn=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var en,tn=Q&&Q.match(/firefox\/(\d+)/),rn={}.watch,an=!1;if(H)try{var sn={};Object.defineProperty(sn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,sn)}catch(n){}var on=function(){return void 0===en&&(en=!H&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);un="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function fn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,i,a,s,o){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function vn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var bn=0,_n=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,_n.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function kn(n){xn.push(n),yn.target=n}function wn(){xn.pop(),yn.target=xn[xn.length-1]}var qn=Array.prototype,Cn=Object.create(qn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=qn[n];Y(Cn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&s.observeArray(i),s.dep.notify(),a}))}));var Tn=Object.getOwnPropertyNames(Cn),Sn={},Pn=!0;function zn(n){Pn=n}var In={notify:j,depend:j,addSub:j,removeSub:j},Ln=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new yn,this.vmCount=0,Y(n,"__ob__",this),i(n)){if(!t)if(Z)n.__proto__=Cn;else for(var r=0,a=Tn.length;r<a;r++){Y(n,o=Tn[r],Cn[o])}e||this.observeArray(n)}else{var s=Object.keys(n);for(r=0;r<s.length;r++){var o;An(n,o=s[r],Sn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)En(n[e],!1,this.mock)},n}();function En(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Ln?n.__ob__:!Pn||!t&&on()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Dn(n)||n instanceof mn?void 0:new Ln(n,e,t)}function An(n,e,t,r,a,s,o){void 0===o&&(o=!1);var l=new yn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var u=c&&c.get,d=c&&c.set;u&&!d||t!==Sn&&2!==arguments.length||(t=n[e]);var p=a?t&&t.__ob__:En(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=u?u.call(n):t;return yn.target&&(l.depend(),p&&(p.dep.depend(),i(e)&&On(e))),Dn(e)&&!a?e.value:e},set:function(e){var r=u?u.call(n):t;if(D(r,e)){if(d)d.call(n,e);else{if(u)return;if(!a&&Dn(r)&&!Dn(e))return void(r.value=e);t=e}p=a?e&&e.__ob__:En(e,!1,s),l.notify()}}}),l}}function jn(n,e,t){if(!Mn(n)){var r=n.__ob__;return i(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&En(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(An(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Nn(n,e){if(i(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Mn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&On(e)}function Rn(n){return Bn(n,!0),Y(n,"__v_isShallow",!0),n}function Bn(n,e){if(!Mn(n)){En(n,e,on());0}}function Mn(n){return!(!n||!n.__v_isReadonly)}function Dn(n){return!(!n||!0!==n.__v_isRef)}function $n(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Dn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Dn(r)&&!Dn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Wn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Gn=q((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Yn(n,e){function t(){var n=t.fns;if(!i(n))return Pe(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Pe(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,r,i,s){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Gn(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=Yn(c,s)),o(d.once)&&(c=n[l]=i(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((d=Gn(l)).name,e[l],d.capture)}function Zn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}a(i)?r=Yn([l]):s(i.fns)&&o(i.merged)?(r=i).fns.push(l):r=Yn([i,l]),r.merged=!0,n[e]=r}function Hn(n,e,t,r,i){if(s(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Qn(n){return l(n)?[gn(n)]:i(n)?function n(e,t){var r,c,u,d,p=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(u=p.length-1,d=p[u],i(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Kn(d)&&(p[u]=gn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Kn(d)?p[u]=gn(d.text+c):""!==c&&p.push(gn(c)):Kn(c)&&Kn(d)?p[u]=gn(d.text+c.text):(o(e._isVList)&&s(c.tag)&&a(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Kn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Xn(n,e){var t,r,a,o,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)o=a[t],l[t]=e(n[o],o,t);return s(l)||(l=[]),l._isVList=!0,l}function Jn(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=E(E({},r),t)),i=a(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},i):i}function ne(n){return Lt(this.$options,"filters",n,!0)||O}function ee(n,e){return i(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,i){var a=U.keyCodes[e]||t;return i&&r&&!U.keyCodes[e]?ee(i,r):a?ee(a,n):r?z(r)!==e:void 0===n}function re(n,e,t,r,a){if(t)if(u(t)){i(t)&&(t=A(t));var s=void 0,o=function(i){if("class"===i||"style"===i||y(i))s=n;else{var o=n.attrs&&n.attrs.type;s=r||U.mustUseProp(e,o,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(i),c=z(i);l in s||c in s||(s[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)o(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||se(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return se(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function se(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?E({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var s=n[a];i(s)?ce(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return r&&(e.$key=r),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=ae,n._n=b,n._s=g,n._l=Xn,n._t=Jn,n._q=R,n._i=B,n._m=ie,n._f=ne,n._k=te,n._b=re,n._v=gn,n._e=hn,n._u=ce,n._g=le,n._d=ue,n._p=de}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],s=a.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,a.context!==e&&a.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(a);else{var o=s.slot,l=t[o]||(t[o]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,i){var a,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&i&&i!==r&&l===i.$key&&!s&&!i.$hasNormal)return i;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ve(n,t,c,e[c]))}else a={};for(var u in t)u in a||(a[u]=be(t,u));return e&&Object.isExtensible(e)&&(e._normalized=a),Y(a,"$stable",o),Y(a,"$key",l),Y(a,"$hasNormal",s),a}function ve(n,e,t,r){var a=function(){var e=pn;fn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:Qn(t))&&t[0];return fn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function be(n,e){return function(){return n[e]}}function _e(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};Y(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return $n(n,e,t)}))}}}function ye(n,e,t,r,i){var a=!1;for(var s in e)s in n?e[s]!==t[s]&&(a=!0):(a=!0,xe(n,s,r,i));for(var s in n)s in e||(a=!0,delete n[s]);return a}function xe(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function qe(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Ce(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||he(t)))return t}}function Te(n,e,t,r,d,p){return(i(t)||l(t))&&(d=r,r=t,t=void 0),o(p)&&(d=2),function(n,e,t,r,l){if(s(t)&&s(t.__ob__))return hn();s(t)&&s(t.is)&&(e=t.is);if(!e)return hn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Qn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,p;if("string"==typeof e){var f=void 0;p=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),d=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!s(f=Lt(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):xt(f,t,n,r,e)}else d=xt(e,t,n,r);return i(d)?d:s(d)?(s(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(s(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];s(c.tag)&&(a(c.ns)||o(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,p),s(t)&&function(n){u(n.style)&&Ue(n.style);u(n.class)&&Ue(n.class)}(t),d):hn()}(n,e,t,r,d)}function Se(n,e,t){kn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){ze(n,r,"errorCaptured hook")}}ze(n,e,t)}finally{wn()}}function Pe(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&h(a)&&!a._handled&&(a.catch((function(n){return Se(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Se(n,r,i)}return a}function ze(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!H||"undefined"==typeof console)throw n;console.error(n)}var Le,Ee=!1,Ae=[],je=!1;function Ne(){je=!1;var n=Ae.slice(0);Ae.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Oe=Promise.resolve();Le=function(){Oe.then(Ne),nn&&setTimeout(j)},Ee=!0}else if(K||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Le="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Ne)}:function(){setTimeout(Ne,0)};else{var Re=1,Be=new MutationObserver(Ne),Me=document.createTextNode(String(Re));Be.observe(Me,{characterData:!0}),Le=function(){Re=(Re+1)%2,Me.data=String(Re)},Ee=!0}function De(n,e){var t;if(Ae.push((function(){if(n)try{n.call(e)}catch(n){Se(n,e,"nextTick")}else t&&t(e)})),je||(je=!0,Le()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function $e(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=St(r[e],t)}(t,n,e)}}$e("beforeMount"),$e("mounted"),$e("beforeUpdate"),$e("updated"),$e("beforeDestroy"),$e("destroyed"),$e("activated"),$e("deactivated"),$e("serverPrefetch"),$e("renderTracked"),$e("renderTriggered"),$e("errorCaptured");var Fe=new un;function Ue(n){return function n(e,t){var r,a,s=i(e);if(!s&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(r=e.length;r--;)n(e[r],t);else if(Dn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Fe),Fe.clear(),n}var We,Ge=0,Ye=function(){function n(n,e,t,r,i){var a,s;a=this,void 0===(s=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(s=Fn),s&&s.active&&s.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ge,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=j)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Se(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ft(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Pe(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){We.$on(n,e)}function Ze(n,e){We.$off(n,e)}function He(n,e){var t=We;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Qe(n,e,t){We=n,Vn(e,t||{},Ve,Ze,He,n),We=void 0}var Ke=null;function Xe(n){var e=Ke;return Ke=n,function(){Ke=e}}function Je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),kn();var i=pn,a=Fn;r&&fn(n);var s=n.$options[e],o="".concat(e," hook");if(s)for(var l=0,c=s.length;l<c;l++)Pe(s[l],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&(fn(i),a&&a.on()),wn()}var tt=[],rt=[],it={},at=!1,st=!1,ot=0;var lt=0,ct=Date.now;if(H&&!K){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ct(),st=!0,tt.sort(dt),ot=0;ot<tt.length;ot++)(n=tt[ot]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=rt.slice(),r=tt.slice();ot=tt.length=rt.length=0,it={},at=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<_n.length;n++){var e=_n[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}_n.length=0}(),ln&&U.devtools&&ln.emit("flush")}function ft(n){var e=n.id;if(null==it[e]&&(n!==yn.target||!n.noRecurse)){if(it[e]=!0,st){for(var t=tt.length-1;t>ot&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,De(pt))}}function mt(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var s=n[a].from;if(s in e._provided)t[a]=e._provided[s];else if("default"in n[a]){var o=n[a].default;t[a]=c(o)?o.call(e):o}else 0}}return t}}function ht(n,e,t,a,s){var l,c=this,u=s.options;w(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=o(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=mt(u.inject,a),this.slots=function(){return c.$slots||ge(a,n.scopedSlots,c.$slots=fe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var s=Te(l,n,e,t,r,p);return s&&!i(s)&&(s.fnScopeId=u._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,r){return Te(l,n,e,t,r,p)}}function gt(n,e,t,r,i){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function vt(n,e){for(var t in e)n[T(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}pe(ht.prototype);var _t={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;_t.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;s(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var s=i.data.scopedSlots,o=n.$scopedSlots,l=!!(s&&!s.$stable||o!==r&&!o.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var d=i.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,d,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,p),e&&n.$options.props){zn(!1);for(var f=n._props,m=n.$options._propKeys||[],h=0;h<m.length;h++){var g=m[h],v=n.$options.props;f[g]=Et(g,v,e,n)}zn(!0),n.$options.propsData=e}c&&(n.$slots=fe(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Je(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(_t);function xt(n,e,t,l,c){if(!a(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=we;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var r=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=M((function(t){n.resolved=qe(t,e),i?r.length=0:d(!0)})),f=M((function(e){s(n.errorComp)&&(n.error=!0,d(!0))})),m=n(p,f);return u(m)&&(h(m)?a(n.resolved)&&m.then(p,f):h(m.component)&&(m.component.then(p,f),s(m.error)&&(n.errorComp=qe(m.error,e)),s(m.loading)&&(n.loadingComp=qe(m.loading,e),0===m.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),m.delay||200)),s(m.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&f(null)}),m.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,r,i){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(p,e,t,l,c);e=e||{},Yt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[r],l=e.model.callback;s(o)?(i(o)?-1===o.indexOf(l):o!==l)&&(a[r]=[l].concat(o)):a[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var c in r){var u=z(c);Hn(i,l,c,u,!0)||Hn(i,o,c,u,!1)}return i}}(e,n);if(o(n.options.functional))return function(n,e,t,a,o){var l=n.options,c={},u=l.props;if(s(u))for(var d in u)c[d]=Et(d,u,e||r);else s(t.attrs)&&vt(c,t.attrs),s(t.props)&&vt(c,t.props);var p=new ht(t,c,o,a,n),f=l.render.call(null,p._c,p);if(f instanceof mn)return gt(f,t,p.parent,l,p);if(i(f)){for(var m=Qn(f)||[],h=new Array(m.length),g=0;g<m.length;g++)h[g]=gt(m[g],t,p.parent,l,p);return h}}(n,f,e,t,l);var m=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],i=e[r],a=_t[r];i===a||i&&i._merged||(e[r]=i?kt(a,i):a)}}(e);var v=bt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:m,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var wt=j,qt=U.optionMergeStrategies;function Ct(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,s=dn?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(r=s[o])&&(i=n[r],a=e[r],t&&w(n,r)?i!==a&&p(i)&&p(a)&&Ct(i,a):jn(n,r,a));return n}function Tt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?Ct(r,i):i}:e?n?function(){return Ct(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function St(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pt(n,e,t,r){var i=Object.create(n||null);return e?E(i,e):i}qt.data=function(n,e,t){return t?Tt(n,e,t):e&&"function"!=typeof e?n:Tt(n,e)},F.forEach((function(n){qt[n]=St})),$.forEach((function(n){qt[n+"s"]=Pt})),qt.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var s in E(a,n),e){var o=a[s],l=e[s];o&&!i(o)&&(o=[o]),a[s]=o?o.concat(l):i(l)?l:[l]}return a},qt.props=qt.methods=qt.inject=qt.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return E(i,n),e&&E(i,e),i},qt.provide=function(n,e){return n?function(){var t=Object.create(null);return Ct(t,c(n)?n.call(this):n),e&&Ct(t,c(e)?e.call(this):e,!1),t}:e};var zt=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,s={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(s[T(a)]={type:null});else if(p(t))for(var o in t)a=t[o],s[T(o)]=p(a)?a:{type:a};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var s in t){var o=t[s];r[s]=p(o)?E({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=It(n,e.mixins[r],t);var s,o={};for(s in n)l(s);for(s in e)w(n,s)||l(s);function l(r){var i=qt[r]||zt;o[r]=i(n[r],e[r],t,r)}return o}function Lt(n,e,t,r){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var a=T(t);if(w(i,a))return i[a];var s=S(a);return w(i,s)?i[s]:i[t]||i[a]||i[s]}}function Et(n,e,t,r){var i=e[n],a=!w(t,n),s=t[n],o=Ot(Boolean,i.type);if(o>-1)if(a&&!w(i,"default"))s=!1;else if(""===s||s===z(n)){var l=Ot(String,i.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==jt(e.type)?r.call(n):r}(r,i,n);var u=Pn;zn(!0),En(s),zn(u)}return s}var At=/^\s*function (\w+)/;function jt(n){var e=n&&n.toString().match(At);return e?e[1]:""}function Nt(n,e){return jt(n)===jt(e)}function Ot(n,e){if(!i(e))return Nt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Nt(e[t],n))return t;return-1}var Rt={enumerable:!0,configurable:!0,get:j,set:j};function Bt(n,e,t){Rt.get=function(){return this[e][t]},Rt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Rt)}function Mt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Rn({}),i=n.$options._propKeys=[];n.$parent&&zn(!1);var a=function(a){i.push(a);var s=Et(a,e,t,n);An(r,a,s,void 0,!0),a in n||Bt(n,"_props",a)};for(var s in e)a(s);zn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=_e(n);fn(n),kn();var i=Pe(t,null,[n._props||Rn({}),r],n,"setup");if(wn(),fn(),c(i))e.render=i;else if(u(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var s in i)"__sfc"!==s&&$n(a,i,s)}else for(var s in i)G(s)||$n(n,i,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?j:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Se(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&w(r,a)||G(a)||Bt(n,"_data",a)}var s=En(e);s&&s.vmCount++}(n);else{var t=En(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var i in e){var a=e[i],s=c(a)?a:a.get;0,r||(t[i]=new Ye(n,s||j,j,Dt)),i in n||$t(n,i,a)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)Wt(n,t,r[a]);else Wt(n,t,r)}}(n,e.watch)}var Dt={lazy:!0};function $t(n,e,t){var r=!on();c(t)?(Rt.get=r?Ft(e):Ut(t),Rt.set=j):(Rt.get=t.get?r&&!1!==t.cache?Ft(e):Ut(t.get):j,Rt.set=t.set||j),Object.defineProperty(n,e,Rt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function Wt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Gt=0;function Yt(n){var e=n.options;if(n.super){var t=Yt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&E(n.extendOptions,r),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Zt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=bt(n)||bt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=It(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Bt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)$t(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,$.forEach((function(n){s[n]=t[n]})),a&&(s.options.components[a]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=E({},s.options),i[r]=s,s}}function Ht(n){return n&&(bt(n.Ctor.options)||n.tag)}function Qt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Kt(n,e){var t=n.cache,r=n.keys,i=n._vnode,a=n.$vnode;for(var s in t){var o=t[s];if(o){var l=o.name;l&&!e(l)&&Xt(t,s,r,i)}}a.componentOptions.children=void 0}function Xt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}Vt.prototype._init=function(n){var e=this;e._uid=Gt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Yt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=fe(e._renderChildren,i),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return Te(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Te(n,e,t,r,i,!0)};var a=t&&t.data;An(n,"$attrs",a&&a.attrs||r,null,!0),An(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(zn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),zn(!0))}(e),Mt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Wn(n),i=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var s=i[a];Object.defineProperty(r,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=jn,n.prototype.$delete=Nn,n.prototype.$watch=function(n,e,t){if(p(e))return Wt(this,n,e,t);(t=t||{}).user=!0;var r=new Ye(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');kn(),Pe(e,this,[r.value],this,i),wn()}return function(){r.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,s=n.length;a<s;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((s=o[l])===e||s.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?L(t):t;for(var r=L(arguments,1),i='event handler for "'.concat(n,'"'),a=0,s=t.length;a<s;a++)Pe(t[a],e,r,e,i)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Xe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return De(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=ge(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ke(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var a,s=pn,o=we;try{fn(n),we=n,a=t.call(n._renderProxy,n.$createElement)}catch(e){Se(e,n,"render"),a=n._vnode}finally{we=o,fn(s)}return i(a)&&1===a.length&&(a=a[0]),a instanceof mn||(a=hn()),a.parent=r,a}}(Vt);var Jt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jt,exclude:Jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,s=t.componentOptions;n[r]={name:Ht(s),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ce(n),t=e&&e.componentOptions;if(t){var r=Ht(t),i=this.include,a=this.exclude;if(i&&(!r||!Qt(i,r))||a&&r&&Qt(a,r))return e;var s=this.cache,o=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,x(o,l),o.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:E,mergeOptions:It,defineReactive:An},n.set=jn,n.delete=Nn,n.nextTick=De,n.observable=function(n){return En(n),n},n.options=Object.create(null),$.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,E(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=L(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),Zt(n),function(n){$.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.16";var er=_("style,class"),tr=_("input,textarea,option,select,progress"),rr=_("contenteditable,draggable,spellcheck"),ir=_("events,caret,typing,plaintext-only"),ar=_("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),sr="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return or(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function ur(n){for(var e=n.data,t=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;s(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(s(n)||s(e))return pr(n,fr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:pr(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function pr(n,e){return n?e?n+" "+e:n:e||""}function fr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)s(e=fr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=_("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=_("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return hr(n)||gr(n)};var br=Object.create(null);var _r=_("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xr={create:function(n,e){kr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(kr(n,!0),kr(e))},destroy:function(n){kr(n,!0)}};function kr(n,e){var t=n.data.ref;if(s(t)){var r=n.context,a=n.componentInstance||n.elm,o=e?null:a,l=e?void 0:a;if(c(t))Pe(t,r,[o],r,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Dn(t),f=r.$refs;if(d||p)if(u){var m=d?f[t]:t.value;e?i(m)&&x(m,a):i(m)?m.includes(a)||m.push(a):d?(f[t]=[a],wr(r,t,f[t])):t.value=[a]}else if(d){if(e&&f[t]!==a)return;f[t]=l,wr(r,t,o)}else if(p){if(e&&t.value!==a)return;t.value=o}else 0}}}function wr(n,e,t){var r=n._setupState;r&&w(r,e)&&(Dn(r[e])?r[e].value=t:r[e]=t)}var qr=new mn("",{},[]),Cr=["create","activate","update","remove","destroy"];function Tr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=s(t=n.data)&&s(t=t.attrs)&&t.type,i=s(t=e.data)&&s(t=t.attrs)&&t.type;return r===i||_r(r)&&_r(i)}(n,e)||o(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Sr(n,e,t){var r,i,a={};for(r=e;r<=t;++r)s(i=n[r].key)&&(a[i]=r);return a}var Pr={create:zr,update:zr,destroy:function(n){zr(n,qr)}};function zr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===qr,s=e===qr,o=Lr(n.data.directives,n.context),l=Lr(e.data.directives,e.context),c=[],u=[];for(t in l)r=o[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Ar(i,"update",e,n),i.def&&i.def.componentUpdated&&u.push(i)):(Ar(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Ar(c[t],"inserted",e,n)};a?Zn(e,"insert",d):d()}u.length&&Zn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Ar(u[t],"componentUpdated",e,n)}));if(!a)for(t in o)l[t]||Ar(o[t],"unbind",n,n,s)}(n,e)}var Ir=Object.create(null);function Lr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Ir),i[Er(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||Lt(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||Lt(e.$options,"directives",r.name)}return i}function Er(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ar(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Se(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var jr=[xr,Pr];function Nr(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(s(u.__ob__)||o(u._v_attr_proxy))&&(u=e.data.attrs=E({},u)),u)i=u[r],c[r]!==i&&Or(l,r,i,e.data.pre);for(r in(K||J)&&u.value!==c.value&&Or(l,"value",u.value),c)a(u[r])&&(or(r)?l.removeAttributeNS(sr,lr(r)):rr(r)||l.removeAttribute(r))}}function Or(n,e,t,r){r||n.tagName.indexOf("-")>-1?Rr(n,e,t):ar(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&ir(e)?e:"true"}(e,t)):or(e)?cr(t)?n.removeAttributeNS(sr,lr(e)):n.setAttributeNS(sr,e,t):Rr(n,e,t)}function Rr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(K&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Br={create:Nr,update:Nr};function Mr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var o=ur(e),l=t._transitionClasses;s(l)&&(o=pr(o,fr(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var Dr,$r={create:Mr,update:Mr};function Fr(n,e,t){var r=Dr;return function i(){var a=e.apply(null,arguments);null!==a&&Gr(n,i,t,r)}}var Ur=Ee&&!(tn&&Number(tn[1])<=53);function Wr(n,e,t,r){if(Ur){var i=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Dr.addEventListener(n,e,an?{capture:t,passive:r}:t)}function Gr(n,e,t,r){(r||Dr).removeEventListener(n,e._wrapper||e,t)}function Yr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Dr=e.elm||n.elm,function(n){if(s(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,r,Wr,Gr,Fr,e.context),Dr=void 0}}var Vr,Zr={create:Yr,update:Yr,destroy:function(n){return Yr(n,qr)}};function Hr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||o(c._v_attr_proxy))&&(c=e.data.domProps=E({},c)),l)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var u=a(r)?"":String(r);Qr(i,u)&&(i.value=u)}else if("innerHTML"===t&&gr(i.tagName)&&a(i.innerHTML)){(Vr=Vr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Vr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Qr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(s(r)){if(r.number)return b(t)!==b(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Kr={create:Hr,update:Hr},Xr=q((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Jr(n){var e=ni(n.style);return n.staticStyle?E(n.staticStyle,e):e}function ni(n){return Array.isArray(n)?A(n):"string"==typeof n?Xr(n):n}var ei,ti=/^--/,ri=/\s*!important$/,ii=function(n,e,t){if(ti.test(e))n.style.setProperty(e,t);else if(ri.test(t))n.style.setProperty(z(e),t.replace(ri,""),"important");else{var r=si(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ai=["Webkit","Moz","ms"],si=q((function(n){if(ei=ei||document.createElement("div").style,"filter"!==(n=T(n))&&n in ei)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ai.length;t++){var r=ai[t]+e;if(r in ei)return r}}));function oi(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,o,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=ni(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?E({},p):p;var f=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Jr(i.data))&&E(r,t);(t=Jr(n.data))&&E(r,t);for(var a=n;a=a.parent;)a.data&&(t=Jr(a.data))&&E(r,t);return r}(e,!0);for(o in d)a(f[o])&&ii(l,o,"");for(o in f)i=f[o],ii(l,o,null==i?"":i)}}var li={create:oi,update:oi},ci=/\s+/;function ui(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pi(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&E(e,fi(n.name||"v")),E(e,n),e}return"string"==typeof n?fi(n):void 0}}var fi=q((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mi=H&&!X,hi="transition",gi="transitionend",vi="animation",bi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vi="WebkitAnimation",bi="webkitAnimationEnd"));var _i=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yi(n){_i((function(){_i(n)}))}function xi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ui(n,e))}function ki(n,e){n._transitionClasses&&x(n._transitionClasses,e),di(n,e)}function wi(n,e,t){var r=Ci(n,e),i=r.type,a=r.timeout,s=r.propCount;if(!i)return t();var o="transition"===i?gi:bi,l=0,c=function(){n.removeEventListener(o,u),t()},u=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),a+1),n.addEventListener(o,u)}var qi=/\b(transform|all)(,|$)/;function Ci(n,e){var t,r=window.getComputedStyle(n),i=(r[hi+"Delay"]||"").split(", "),a=(r[hi+"Duration"]||"").split(", "),s=Ti(i,a),o=(r[vi+"Delay"]||"").split(", "),l=(r[vi+"Duration"]||"").split(", "),c=Ti(o,l),u=0,d=0;return"transition"===e?s>0&&(t="transition",u=s,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&qi.test(r[hi+"Property"])}}function Ti(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Si(e)+Si(n[t])})))}function Si(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Pi(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=pi(n.data.transition);if(!a(r)&&!s(t._enterCb)&&1===t.nodeType){for(var i=r.css,o=r.type,l=r.enterClass,d=r.enterToClass,p=r.enterActiveClass,f=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,g=r.beforeEnter,v=r.enter,_=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,k=r.appear,w=r.afterAppear,q=r.appearCancelled,C=r.duration,T=Ke,S=Ke.$vnode;S&&S.parent;)T=S.context,S=S.parent;var P=!T._isMounted||!n.isRootInsert;if(!P||k||""===k){var z=P&&f?f:l,I=P&&h?h:p,L=P&&m?m:d,E=P&&x||g,A=P&&c(k)?k:v,j=P&&w||_,N=P&&q||y,O=b(u(C)?C.enter:C);0;var R=!1!==i&&!X,B=Li(A),D=t._enterCb=M((function(){R&&(ki(t,L),ki(t,I)),D.cancelled?(R&&ki(t,z),N&&N(t)):j&&j(t),t._enterCb=null}));n.data.show||Zn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),A&&A(t,D)})),E&&E(t),R&&(xi(t,z),xi(t,I),yi((function(){ki(t,z),D.cancelled||(xi(t,L),B||(Ii(O)?setTimeout(D,O):wi(t,o,D)))}))),n.data.show&&(e&&e(),A&&A(t,D)),R||B||D()}}}function zi(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=pi(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var i=r.css,o=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,f=r.leave,m=r.afterLeave,h=r.leaveCancelled,g=r.delayLeave,v=r.duration,_=!1!==i&&!X,y=Li(f),x=b(u(v)?v.leave:v);0;var k=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),_&&(ki(t,c),ki(t,d)),k.cancelled?(_&&ki(t,l),h&&h(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(w):w()}function w(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),_&&(xi(t,l),xi(t,d),yi((function(){ki(t,l),k.cancelled||(xi(t,c),y||(Ii(x)?setTimeout(k,x):wi(t,o,k)))}))),f&&f(t,k),_||y||k())}}function Ii(n){return"number"==typeof n&&!isNaN(n)}function Li(n){if(a(n))return!1;var e=n.fns;return s(e)?Li(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ei(n,e){!0!==e.data.show&&Pi(e)}var Ai=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<Cr.length;++e)for(r[Cr[e]]=[],t=0;t<c.length;++t)s(c[t][Cr[e]])&&r[Cr[e]].push(c[t][Cr[e]]);function d(n){var e=u.parentNode(n);s(e)&&u.removeChild(e,n)}function p(n,e,t,i,a,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=vn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(s(a)){var l=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return f(n,e),m(t,n.elm,i),o(l)&&function(n,e,t,i){var a,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(a=o.data)&&s(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](qr,o);e.push(o);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,g=n.tag;s(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),h(n,p,e),s(d)&&v(n,e),m(t,n.elm,i)):o(n.isComment)?(n.elm=u.createComment(n.text),m(t,n.elm,i)):(n.elm=u.createTextNode(n.text),m(t,n.elm,i))}}function f(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),b(n)):(kr(n),e.push(n))}function m(n,e,t){s(n)&&(s(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function h(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,t){for(var i=0;i<r.create.length;++i)r.create[i](qr,n);s(e=n.data.hook)&&(s(e.create)&&e.create(qr,n),s(e.insert)&&t.push(n))}function b(n){var e;if(s(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;s(e=Ke)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)p(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(s(i))for(s(e=i.hook)&&s(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];s(r)&&(s(r.tag)?(w(r),x(r)):d(r.elm))}}function w(n,e){if(s(e)||s(n.data)){var t,i=r.remove.length+1;for(s(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else d(n.elm)}function q(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(s(a)&&Tr(n,a))return i}}function C(n,e,t,i,l,c){if(n!==e){s(e.elm)&&s(i)&&(e=i[l]=vn(e));var d=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,m=e.data;s(m)&&s(f=m.hook)&&s(f=f.prepatch)&&f(n,e);var h=n.children,v=e.children;if(s(m)&&g(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);s(f=m.hook)&&s(f=f.update)&&f(n,e)}a(e.text)?s(h)&&s(v)?h!==v&&function(n,e,t,r,i){var o,l,c,d=0,f=0,m=e.length-1,h=e[0],g=e[m],v=t.length-1,b=t[0],_=t[v],x=!i;for(0;d<=m&&f<=v;)a(h)?h=e[++d]:a(g)?g=e[--m]:Tr(h,b)?(C(h,b,r,t,f),h=e[++d],b=t[++f]):Tr(g,_)?(C(g,_,r,t,v),g=e[--m],_=t[--v]):Tr(h,_)?(C(h,_,r,t,v),x&&u.insertBefore(n,h.elm,u.nextSibling(g.elm)),h=e[++d],_=t[--v]):Tr(g,b)?(C(g,b,r,t,f),x&&u.insertBefore(n,g.elm,h.elm),g=e[--m],b=t[++f]):(a(o)&&(o=Sr(e,d,m)),a(l=s(b.key)?o[b.key]:q(b,e,d,m))?p(b,r,n,h.elm,!1,t,f):Tr(c=e[l],b)?(C(c,b,r,t,f),e[l]=void 0,x&&u.insertBefore(n,c.elm,h.elm)):p(b,r,n,h.elm,!1,t,f),b=t[++f]);d>m?y(n,a(t[v+1])?null:t[v+1].elm,t,f,v,r):f>v&&k(e,d,m)}(d,h,v,t,c):s(v)?(s(n.text)&&u.setTextContent(d,""),y(d,null,v,0,v.length-1,t)):s(h)?k(h,0,h.length-1):s(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),s(m)&&s(f=m.hook)&&s(f=f.postpatch)&&f(n,e)}}}function T(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=_("attrs,class,staticClass,staticStyle,key");function P(n,e,t,r){var i,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(i=l.hook)&&s(i=i.init)&&i(e,!0),s(i=e.componentInstance)))return f(e,t),!0;if(s(a)){if(s(c))if(n.hasChildNodes())if(s(i=l)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!P(d,c[p],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else h(e,c,t);if(s(l)){var m=!1;for(var g in l)if(!S(g)){m=!0,v(e,t);break}!m&&l.class&&Ue(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,c=!1,d=[];if(a(n))c=!0,p(e,d);else{var f=s(n.nodeType);if(!f&&Tr(n,e))C(n,e,d,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&P(n,e,d))return T(e,d,!0),n;l=n,n=new mn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,h=u.parentNode(m);if(p(e,d,m._leaveCb?null:h,u.nextSibling(m)),s(e.parent))for(var v=e.parent,b=g(e);v;){for(var _=0;_<r.destroy.length;++_)r.destroy[_](v);if(v.elm=e.elm,b){for(var y=0;y<r.create.length;++y)r.create[y](qr,v);var w=v.data.hook.insert;if(w.merged)for(var q=w.fns.slice(1),S=0;S<q.length;S++)q[S]()}else kr(v);v=v.parent}s(h)?k([n],0,0):s(n.tag)&&x(n)}}return T(e,d,c),e.elm}s(n)&&x(n)}}({nodeOps:yr,modules:[Br,$r,Zr,Kr,li,H?{create:Ei,activate:Ei,remove:function(n,e){!0!==n.data.show?zi(n,e):e()}}:{}].concat(jr)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&$i(n,"input")}));var ji={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Zn(t,"postpatch",(function(){ji.componentUpdated(n,e,t)})):Ni(n,e,t.context),n._vOptions=[].map.call(n.options,Bi)):("textarea"===t.tag||_r(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Mi),n.addEventListener("compositionend",Di),n.addEventListener("change",Di),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ni(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Bi);if(i.some((function(n,e){return!R(n,r[e])})))(n.multiple?e.value.some((function(n){return Ri(n,i)})):e.value!==e.oldValue&&Ri(e.value,i))&&$i(n,"change")}}};function Ni(n,e,t){Oi(n,e,t),(K||J)&&setTimeout((function(){Oi(n,e,t)}),0)}function Oi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,s,o=0,l=n.options.length;o<l;o++)if(s=n.options[o],i)a=B(r,Bi(s))>-1,s.selected!==a&&(s.selected=a);else if(R(Bi(s),r))return void(n.selectedIndex!==o&&(n.selectedIndex=o));i||(n.selectedIndex=-1)}}function Ri(n,e){return e.every((function(e){return!R(e,n)}))}function Bi(n){return"_value"in n?n._value:n.value}function Mi(n){n.target.composing=!0}function Di(n){n.target.composing&&(n.target.composing=!1,$i(n.target,"input"))}function $i(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fi(n){return!n.componentInstance||n.data&&n.data.transition?n:Fi(n.componentInstance._vnode)}var Ui={model:ji,show:{bind:function(n,e,t){var r=e.value,i=(t=Fi(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Pi(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fi(t)).data&&t.data.transition?(t.data.show=!0,r?Pi(t,(function(){n.style.display=n.__vOriginalDisplay})):zi(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Wi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Gi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Gi(Ce(e.children)):n}function Yi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[T(r)]=i[r];return e}function Vi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Zi=function(n){return n.tag||he(n)},Hi=function(n){return"show"===n.name},Qi={name:"transition",props:Wi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Zi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Gi(i);if(!a)return i;if(this._leaving)return Vi(n,i);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:l(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var o=(a.data||(a.data={})).transition=Yi(this),c=this._vnode,u=Gi(c);if(a.data.directives&&a.data.directives.some(Hi)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=E({},o);if("out-in"===r)return this._leaving=!0,Zn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vi(n,i);if("in-out"===r){if(he(a))return c;var p,f=function(){p()};Zn(o,"afterEnter",f),Zn(o,"enterCancelled",f),Zn(d,"delayLeave",(function(n){p=n}))}}return i}}},Ki=E({tag:String,moveClass:String},Wi);function Xi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function na(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete Ki.mode;var ea={Transition:Qi,TransitionGroup:{props:Ki,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],s=Yi(this),o=0;o<i.length;o++){if((u=i[o]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))a.push(u),t[u.key]=u,(u.data||(u.data={})).transition=s;else;}if(r){var l=[],c=[];for(o=0;o<r.length;o++){var u;(u=r[o]).data.transition=s,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xi),n.forEach(Ji),n.forEach(na),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xi(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(gi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(gi,n),t._moveCb=null,ki(t,e))})}})))},methods:{hasMove:function(n,e){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),ui(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ci(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ta(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=vr,Vt.config.isReservedAttr=er,Vt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!H)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=br[n])return br[n];var e=document.createElement(n);return n.indexOf("-")>-1?br[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:br[n]=/HTMLUnknownElement/.test(e.toString())},E(Vt.options.directives,Ui),E(Vt.options.components,ea),Vt.prototype.__patch__=H?Ai:j,Vt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ye(n,r,j,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){U.devtools&&ln&&ln.emit("init",Vt)}),0);var ra=/[!'()*]/g,ia=function(n){return"%"+n.charCodeAt(0).toString(16)},aa=/%2C/g,sa=function(n){return encodeURIComponent(n).replace(ra,ia).replace(aa,",")};function oa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var la=function(n){return null==n||"object"==typeof n?n:String(n)};function ca(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=oa(t.shift()),i=t.length>0?oa(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function ua(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return sa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(sa(e)):r.push(sa(e)+"="+sa(n)))})),r.join("&")}return sa(e)+"="+sa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function pa(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=fa(a)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ga(e,i),matched:n?ha(n):[]};return t&&(s.redirectedFrom=ga(t,i)),Object.freeze(s)}function fa(n){if(Array.isArray(n))return n.map(fa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=fa(n[t]);return e}return n}var ma=pa(null,{path:"/"});function ha(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ga(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||ua)(r)+i}function va(n,e,t){return e===ma?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&ba(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ba(n.query,e.query)&&ba(n.params,e.params))))}function ba(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var s=e[t];return null==a||null==s?a===s:"object"==typeof a&&"object"==typeof s?ba(a,s):String(a)===String(s)}))}function _a(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var s=0;s<a.length;s++)i._isBeingDestroyed||a[s](i)}}}}var ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var s=i.$createElement,o=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),u=0,d=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&u++,p.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(a.routerViewDepth=u,d){var f=c[o],m=f&&f.component;return m?(f.configProps&&xa(m,a,f.route,f.configProps),s(m,a,r)):s()}var h=l.matched[u],g=h&&h.components[o];if(!h||!g)return c[o]=null,s();c[o]={component:g},a.registerRouteInstance=function(n,e){var t=h.instances[o];(e&&t!==n||!e&&t===n)&&(h.instances[o]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[o]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[o]&&(h.instances[o]=n.componentInstance),_a(l)};var v=h.props&&h.props[o];return v&&(ta(c[o],{route:l,configProps:v}),xa(g,a,l,v)),s(g,a,r)}};function xa(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ta({},i);var a=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(a[s]=i[s],delete i[s])}}function ka(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),s=0;s<a.length;s++){var o=a[s];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function wa(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var qa=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ca=Ma,Ta=La,Sa=function(n,e){return Aa(La(n,e),e)},Pa=Aa,za=Ba,Ia=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function La(n,e){for(var t,r=[],i=0,a=0,s="",o=e&&e.delimiter||"/";null!=(t=Ia.exec(n));){var l=t[0],c=t[1],u=t.index;if(s+=n.slice(a,u),a=u+l.length,c)s+=c[1];else{var d=n[a],p=t[2],f=t[3],m=t[4],h=t[5],g=t[6],v=t[7];s&&(r.push(s),s="");var b=null!=p&&null!=d&&d!==p,_="+"===g||"*"===g,y="?"===g||"*"===g,x=t[2]||o,k=m||h;r.push({name:f||i++,prefix:p||"",delimiter:x,optional:y,repeat:_,partial:b,asterisk:!!v,pattern:k?Na(k):v?".*":"[^"+ja(x)+"]+?"})}}return a<n.length&&(s+=n.substr(a)),s&&r.push(s),r}function Ea(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Aa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Ra(e)));return function(e,r){for(var i="",a=e||{},s=(r||{}).pretty?Ea:encodeURIComponent,o=0;o<n.length;o++){var l=n[o];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(qa(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=s(u[d]),!t[o].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(u),!t[o].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function ja(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Na(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oa(n,e){return n.keys=e,n}function Ra(n){return n&&n.sensitive?"":"i"}function Ba(n,e,t){qa(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",s=0;s<n.length;s++){var o=n[s];if("string"==typeof o)a+=ja(o);else{var l=ja(o.prefix),c="(?:"+o.pattern+")";e.push(o),o.repeat&&(c+="(?:"+l+c+")*"),a+=c=o.optional?o.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=ja(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=i?"$":r&&d?"":"(?="+u+"|$)",Oa(new RegExp("^"+a,Ra(t)),e)}function Ma(n,e,t){return qa(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oa(n,e)}(n,e):qa(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(Ma(n[i],e,t).source);return Oa(new RegExp("(?:"+r.join("|")+")",Ra(t)),e)}(n,e,t):function(n,e,t){return Ba(La(n,t),e,t)}(n,e,t)}Ca.parse=Ta,Ca.compile=Sa,Ca.tokensToFunction=Pa,Ca.tokensToRegExp=za;var Da=Object.create(null);function $a(n,e,t){e=e||{};try{var r=Da[n]||(Da[n]=Ca.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fa(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ta({},n)).params;return a&&"object"==typeof a&&(i.params=ta({},a)),i}if(!i.path&&i.params&&e){(i=ta({},i))._normalized=!0;var s=ta(ta({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var o=e.matched[e.matched.length-1].path;i.path=$a(o,s,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",u=l.path?ka(l.path,c,t||i.append):c,d=function(n,e,t){void 0===e&&(e={});var r,i=t||ca;try{r=i(n||"")}catch(n){r={}}for(var a in e){var s=e[a];r[a]=Array.isArray(s)?s.map(la):la(s)}return r}(l.query,i.query,r&&r.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var Ua,Wa=function(){},Ga={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,s=i.route,o=i.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,f=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?p:this.exactActiveClass,h=s.redirectedFrom?pa(null,Fa(s.redirectedFrom),null,t):s;l[m]=va(r,h,this.exactPath),l[f]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var g=l[m]?this.ariaCurrentValue:null,v=function(n){Ya(n)&&(e.replace?t.replace(a,Wa):t.push(a,Wa))},b={click:Ya};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var _={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:v,isActive:l[f],isExactActive:l[m]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)_.on=b,_.attrs={href:o,"aria-current":g};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var k=x.data=ta({},x.data);for(var w in k.on=k.on||{},k.on){var q=k.on[w];w in b&&(k.on[w]=Array.isArray(q)?q:[q])}for(var C in b)C in k.on?k.on[C].push(b[C]):k.on[C]=v;var T=x.data.attrs=ta({},x.data.attrs);T.href=o,T["aria-current"]=g}else _.on=b}return n(this.tag,_,this.$slots.default)}};function Ya(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Va="undefined"!=typeof window;function Za(n,e,t,r,i){var a=e||[],s=t||Object.create(null),o=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,s){var o=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wa(e.path+"/"+n)}(o,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var d={path:u,regex:Ha(u,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:s,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=s?wa(s+"/"+i.path):void 0;n(e,t,r,i,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<p.length;++f){0;var m={path:p[f],children:i.children};n(e,t,r,m,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,s,o,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:s,nameMap:o}}function Ha(n,e){return Ca(n,[],e)}function Qa(n,e){var t=Za(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function s(n,t,s){var o=Fa(n,t,!1,e),c=o.name;if(c){var u=a[c];if(!u)return l(null,o);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof o.params&&(o.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in o.params)&&d.indexOf(p)>-1&&(o.params[p]=t.params[p]);return o.path=$a(u.path,o.params),l(u,o,s)}if(o.path){o.params={};for(var f=0;f<r.length;f++){var m=r[f],h=i[m];if(Ka(h.regex,o.path,o.params))return l(h,o,s)}}return l(null,o)}function o(n,t){var r=n.redirect,i="function"==typeof r?r(pa(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var o=i,c=o.name,u=o.path,d=t.query,p=t.hash,f=t.params;if(d=o.hasOwnProperty("query")?o.query:d,p=o.hasOwnProperty("hash")?o.hash:p,f=o.hasOwnProperty("params")?o.params:f,c){a[c];return s({_normalized:!0,name:c,query:d,hash:p,params:f},void 0,t)}if(u){var m=function(n,e){return ka(n,e.parent?e.parent.path:"/",!0)}(u,n);return s({_normalized:!0,path:$a(m,f),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?o(n,r||t):n&&n.matchAs?function(n,e,t){var r=s({_normalized:!0,path:$a(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):pa(n,t,r,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Za([e||n],r,i,a,t),t&&t.alias.length&&Za(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Za(n,r,i,a)}}}function Ka(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var s=n.keys[i-1];s&&(t[s.name||"pathMatch"]="string"==typeof r[i]?oa(r[i]):r[i])}return!0}var Xa=Va&&window.performance&&window.performance.now?window.performance:Date;function Ja(){return Xa.now().toFixed(3)}var ns=Ja();function es(){return ns}function ts(n){return ns=n}var rs=Object.create(null);function is(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ta({},window.history.state);return t.key=es(),window.history.replaceState(t,"",e),window.addEventListener("popstate",os),function(){window.removeEventListener("popstate",os)}}function as(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=es();if(n)return rs[n]}(),s=i.call(n,e,t,r?a:null);s&&("function"==typeof s.then?s.then((function(n){ps(n,a)})).catch((function(n){0})):ps(s,a))}))}}function ss(){var n=es();n&&(rs[n]={x:window.pageXOffset,y:window.pageYOffset})}function os(n){ss(),n.state&&n.state.key&&ts(n.state.key)}function ls(n){return us(n.x)||us(n.y)}function cs(n){return{x:us(n.x)?n.x:window.pageXOffset,y:us(n.y)?n.y:window.pageYOffset}}function us(n){return"number"==typeof n}var ds=/^#\d/;function ps(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=ds.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:us((t=a).x)?t.x:0,y:us(t.y)?t.y:0})}else ls(n)&&(e=cs(n))}else r&&ls(n)&&(e=cs(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fs,ms=Va&&((-1===(fs=window.navigator.userAgent).indexOf("Android 2.")&&-1===fs.indexOf("Android 4.0")||-1===fs.indexOf("Mobile Safari")||-1!==fs.indexOf("Chrome")||-1!==fs.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function hs(n,e){ss();var t=window.history;try{if(e){var r=ta({},t.state);r.key=es(),t.replaceState(r,"",n)}else t.pushState({key:ts(Ja())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function gs(n){hs(n,!0)}var vs={redirected:2,aborted:4,cancelled:8,duplicated:16};function bs(n,e){return ys(n,e,vs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xs.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function _s(n,e){return ys(n,e,vs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ys(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var xs=["params","query","hash"];function ks(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ws(n,e){return ks(n)&&n._isRouter&&(null==e||n.type===e)}function qs(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Cs(n){return function(e,t,r){var i=!1,a=0,s=null;Ts(n,(function(n,e,t,o){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=zs((function(e){var i;((i=e).__esModule||Ps&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ua.extend(e),t.components[o]=e,--a<=0&&r()})),u=zs((function(n){var e="Failed to resolve async component "+o+": "+n;s||(s=ks(n)?n:new Error(e),r(s))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),i||r()}}function Ts(n,e){return Ss(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ss(n){return Array.prototype.concat.apply([],n)}var Ps="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zs(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Is=function(n,e){this.router=n,this.base=function(n){if(!n)if(Va){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ma,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ls(n,e,t,r){var i=Ts(n,(function(n,r,i,a){var s=function(n,e){"function"!=typeof n&&(n=Ua.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,r,i,a)})):t(s,r,i,a)}));return Ss(r?i.reverse():i)}function Es(n,e){if(e)return function(){return n.apply(e,arguments)}}Is.prototype.listen=function(n){this.cb=n},Is.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Is.prototype.onError=function(n){this.errorCbs.push(n)},Is.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(ws(n,vs.redirected)&&a===ma||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},Is.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,s,o=function(n){!ws(n)&&ks(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(va(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&as(this.router,i,n,!1),o(((s=ys(a=i,n,vs.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",s));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,f=u.activated,m=[].concat(function(n){return Ls(n,"beforeRouteLeave",Es,!0)}(p),this.router.beforeHooks,function(n){return Ls(n,"beforeRouteUpdate",Es)}(d),f.map((function(n){return n.beforeEnter})),Cs(f)),h=function(e,t){if(r.pending!==n)return o(_s(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),o(function(n,e){return ys(n,e,vs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):ks(e)?(r.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(bs(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){o(n)}};qs(m,h,(function(){qs(function(n){return Ls(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return o(_s(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){_a(n)}))}))}))},Is.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Is.prototype.setupListeners=function(){},Is.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ma,this.pending=null};var As=function(n){function e(e,t){n.call(this,e,t),this._startLocation=js(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=ms&&t;r&&this.listeners.push(is());var i=function(){var t=n.current,i=js(n.base);n.current===ma&&i===n._startLocation||n.transitionTo(i,(function(n){r&&as(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){hs(wa(r.base+n.fullPath)),as(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){gs(wa(r.base+n.fullPath)),as(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(js(this.base)!==this.current.fullPath){var e=wa(this.base+this.current.fullPath);n?hs(e):gs(e)}},e.prototype.getCurrentLocation=function(){return js(this.base)},e}(Is);function js(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(wa(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ns=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=js(n);if(!/^\/#/.test(e))return window.location.replace(wa(n+"/#"+e)),!0}(this.base)||Os()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ms&&e;t&&this.listeners.push(is());var r=function(){var e=n.current;Os()&&n.transitionTo(Rs(),(function(r){t&&as(n.router,r,e,!0),ms||Ds(r.fullPath)}))},i=ms?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ms(n.fullPath),as(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ds(n.fullPath),as(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Rs()!==e&&(n?Ms(e):Ds(e))},e.prototype.getCurrentLocation=function(){return Rs()},e}(Is);function Os(){var n=Rs();return"/"===n.charAt(0)||(Ds("/"+n),!1)}function Rs(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Bs(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ms(n){ms?hs(Bs(n)):window.location.hash=n}function Ds(n){ms?gs(Bs(n)):window.location.replace(Bs(n))}var $s=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ws(n,vs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Is),Fs=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ms&&!1!==n.fallback,this.fallback&&(e="hash"),Va||(e="abstract"),this.mode=e,e){case"history":this.history=new As(this,n.base);break;case"hash":this.history=new Ns(this,n.base,this.fallback);break;case"abstract":this.history=new $s(this,n.base);break;default:0}},Us={currentRoute:{configurable:!0}};Fs.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Us.currentRoute.get=function(){return this.history&&this.history.current},Fs.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof As||t instanceof Ns){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;ms&&i&&"fullPath"in n&&as(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fs.prototype.beforeEach=function(n){return Gs(this.beforeHooks,n)},Fs.prototype.beforeResolve=function(n){return Gs(this.resolveHooks,n)},Fs.prototype.afterEach=function(n){return Gs(this.afterHooks,n)},Fs.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fs.prototype.onError=function(n){this.history.onError(n)},Fs.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Fs.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fs.prototype.go=function(n){this.history.go(n)},Fs.prototype.back=function(){this.go(-1)},Fs.prototype.forward=function(){this.go(1)},Fs.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fs.prototype.resolve=function(n,e,t){var r=Fa(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?wa(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},Fs.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fs.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Fs.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fs.prototype,Us);var Ws=Fs;function Gs(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fs.install=function n(e){if(!n.installed||Ua!==e){n.installed=!0,Ua=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ya),e.component("RouterLink",Ga);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Fs.version="3.6.5",Fs.isNavigationFailure=ws,Fs.NavigationFailureType=vs,Fs.START_LOCATION=ma,Va&&window.Vue&&window.Vue.use(Fs);t(155),t(17),t(164);t(129),t(29);var Ys={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,413)),"components/ArchivesPage":()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,382)),"components/ArticleInfo":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,351)),"components/BloggerBar":()=>Promise.all([t.e(0),t.e(25)]).then(t.bind(null,383)),"components/BodyBgImg":()=>Promise.all([t.e(0),t.e(26)]).then(t.bind(null,384)),"components/Buttons":()=>Promise.all([t.e(0),t.e(21)]).then(t.bind(null,385)),"components/Catalogue":()=>Promise.all([t.e(0),t.e(27)]).then(t.bind(null,352)),"components/CategoriesBar":()=>Promise.all([t.e(0),t.e(28)]).then(t.bind(null,346)),"components/CategoriesPage":()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,386)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,313)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(29)]).then(t.bind(null,292)),"components/Footer":()=>Promise.all([t.e(0),t.e(30)]).then(t.bind(null,387)),"components/Home":()=>Promise.all([t.e(0),t.e(3),t.e(1)]).then(t.bind(null,406)),"components/MainLayout":()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,314)),"components/NavLink":()=>t.e(40).then(t.bind(null,290)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(15)]).then(t.bind(null,320)),"components/Navbar":()=>Promise.all([t.e(0),t.e(2),t.e(12)]).then(t.bind(null,381)),"components/Page":()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,388)),"components/PageEdit":()=>Promise.all([t.e(0),t.e(22)]).then(t.bind(null,353)),"components/PageNav":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,354)),"components/Pagination":()=>Promise.all([t.e(0),t.e(32)]).then(t.bind(null,312)),"components/PostList":()=>Promise.all([t.e(0),t.e(33)]).then(t.bind(null,311)),"components/RightMenu":()=>Promise.all([t.e(0),t.e(34)]).then(t.bind(null,355)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,389)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(35)]).then(t.bind(null,356)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,349)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(36)]).then(t.bind(null,323)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,321)),"components/TagsBar":()=>Promise.all([t.e(0),t.e(37)]).then(t.bind(null,348)),"components/TagsPage":()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,390)),"components/UpdateArticle":()=>Promise.all([t.e(0),t.e(38)]).then(t.bind(null,347)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,418)),"global-components/CodeBlock":()=>Promise.resolve().then(t.bind(null,123)),"global-components/CodeGroup":()=>Promise.resolve().then(t.bind(null,124)),"layouts/404":()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,414)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(2),t.e(3),t.e(1),t.e(4)]).then(t.bind(null,415)),NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,414)),Layout:()=>Promise.all([t.e(0),t.e(2),t.e(3),t.e(1),t.e(4)]).then(t.bind(null,415))},Vs={"v-eb60e52c":()=>t.e(41).then(t.bind(null,419)),"v-14ae4ae1":()=>t.e(42).then(t.bind(null,420)),"v-db872dc4":()=>t.e(43).then(t.bind(null,421)),"v-1fdb2df8":()=>t.e(44).then(t.bind(null,422)),"v-17e23a6a":()=>t.e(45).then(t.bind(null,423)),"v-f42ff692":()=>t.e(47).then(t.bind(null,424)),"v-68bd270f":()=>t.e(48).then(t.bind(null,425)),"v-a584c712":()=>t.e(46).then(t.bind(null,426)),"v-706c3357":()=>t.e(49).then(t.bind(null,427)),"v-0edbe937":()=>t.e(50).then(t.bind(null,428)),"v-30f35d12":()=>t.e(51).then(t.bind(null,429)),"v-db77d4ca":()=>t.e(52).then(t.bind(null,430)),"v-74aa51d7":()=>t.e(53).then(t.bind(null,431)),"v-1211effb":()=>t.e(54).then(t.bind(null,432)),"v-0850134b":()=>t.e(56).then(t.bind(null,433)),"v-ca59abba":()=>t.e(57).then(t.bind(null,434)),"v-4588700e":()=>t.e(58).then(t.bind(null,435)),"v-10dcc84e":()=>t.e(59).then(t.bind(null,436)),"v-62cfc316":()=>t.e(61).then(t.bind(null,437)),"v-5dd5a642":()=>t.e(55).then(t.bind(null,438)),"v-ea6ca4f0":()=>t.e(62).then(t.bind(null,439)),"v-07a99e36":()=>t.e(60).then(t.bind(null,440)),"v-08d656b6":()=>t.e(63).then(t.bind(null,441)),"v-24a8be88":()=>t.e(64).then(t.bind(null,442)),"v-e38ed39e":()=>t.e(66).then(t.bind(null,443)),"v-0f826bae":()=>t.e(65).then(t.bind(null,444)),"v-3e1953e8":()=>t.e(67).then(t.bind(null,445)),"v-df166c36":()=>t.e(68).then(t.bind(null,446)),"v-ea583cf6":()=>t.e(69).then(t.bind(null,447)),"v-2c3fadad":()=>t.e(70).then(t.bind(null,448)),"v-0b190e48":()=>t.e(72).then(t.bind(null,449)),"v-44124b74":()=>t.e(71).then(t.bind(null,450)),"v-5b207082":()=>t.e(73).then(t.bind(null,451)),"v-fc061f2e":()=>t.e(74).then(t.bind(null,452)),"v-08c775ea":()=>t.e(76).then(t.bind(null,453)),"v-08eaab1d":()=>t.e(75).then(t.bind(null,454)),"v-acc71d30":()=>t.e(77).then(t.bind(null,455)),"v-81e0e884":()=>t.e(78).then(t.bind(null,456)),"v-ed83a606":()=>t.e(79).then(t.bind(null,457)),"v-fc04b82a":()=>t.e(80).then(t.bind(null,458)),"v-37e5e89e":()=>t.e(81).then(t.bind(null,459)),"v-4db5ae13":()=>t.e(82).then(t.bind(null,460)),"v-dc8b9824":()=>t.e(83).then(t.bind(null,461)),"v-f4b56318":()=>t.e(84).then(t.bind(null,462)),"v-8cc7ac4e":()=>t.e(85).then(t.bind(null,463)),"v-bedbdb3a":()=>t.e(86).then(t.bind(null,464)),"v-5a61da48":()=>t.e(87).then(t.bind(null,465)),"v-20c29ae8":()=>t.e(88).then(t.bind(null,466)),"v-62d053a2":()=>t.e(92).then(t.bind(null,467)),"v-36182552":()=>t.e(93).then(t.bind(null,468)),"v-702df9d4":()=>t.e(90).then(t.bind(null,469)),"v-464606d4":()=>t.e(89).then(t.bind(null,470)),"v-89715122":()=>t.e(91).then(t.bind(null,471))};function Zs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Hs=/-(\w)/g,Qs=Zs(n=>n.replace(Hs,(n,e)=>e?e.toUpperCase():"")),Ks=/\B([A-Z])/g,Xs=Zs(n=>n.replace(Ks,"-$1").toLowerCase()),Js=Zs(n=>n.charAt(0).toUpperCase()+n.slice(1));function no(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Js(Qs(e))):n(Js(e))||n(Xs(e))}const eo=Object.assign({},Ys,Vs),to=n=>eo[n],ro=n=>Vs[n],io=n=>Ys[n],ao=n=>Vt.component(n);function so(n){return no(ro,n)}function oo(n){return no(io,n)}function lo(n){return no(to,n)}function co(n){return no(ao,n)}function uo(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!co(n)&&lo(n)){const e=await lo(n)();Vt.component(n,e.default)}}))}function po(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var fo=t(119),mo=t.n(fo),ho=t(120),go=t.n(ho),vo={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${go()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=_o(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=yo(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return mo()([{name:"description",content:this.$description}],n,this.siteMeta,xo)},updateCanonicalLink(){bo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",_o(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){yo(null,this.currentMetaTags),bo()}};function bo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function _o(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function yo(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xo(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(65);var ko=t(66),wo={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ko)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],s=e[n+1],o=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(o&&l!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},qo=t(44),Co=t.n(qo),To={mounted(){Co.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||Co.a.start(),t()}),this.$router.afterEach(()=>{Co.a.done(),this.isSidebarOpen=!1})}};t(274),t(275);class So{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Po={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new So).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},zo="auto",Io="zoom-in",Lo="zoom-out",Eo="grab",Ao="move";function jo(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function No(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Oo(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ro(n,e,t){!function(n){var e=Bo,t=Mo;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Bo="transition",Mo="transform",Do="transform",$o="transitionend";var Fo=function(){},Uo={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Fo,onClose:Fo,onGrab:Fo,onMove:Fo,onRelease:Fo,onBeforeOpen:Fo,onBeforeClose:Fo,onBeforeGrab:Fo,onBeforeRelease:Fo,onImageLoading:Fo,onImageLoaded:Fo},Wo={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Yo(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Go(n)&&!Yo(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Go(n)&&!Yo(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Go(n){return 0===n.button}function Yo(n){return n.metaKey||n.ctrlKey}var Vo={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ro(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),jo(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ro(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Zo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ho=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Qo=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Ko={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Oo(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Eo:Lo,transition:Do+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ro(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ro(this.el,{transform:"none"})},grab:function(n,e,t){var r=Xo(),i=r.x-n,a=r.y-e;Ro(this.el,{cursor:Ao,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Xo(),i=r.x-n,a=r.y-e;Ro(this.el,{transition:Do,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ro(this.el,this.styleClose)},restoreOpenStyle:function(){Ro(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Xo(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Zo(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var s=this.rect.width/2,o=this.rect.height/2,l=Xo(),c={x:l.x-s,y:l.y-o},u=c.x/s,d=c.y/o,p=a+Math.min(u,d);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,m=e||this.el.naturalHeight,h=parseFloat(i)*f/(100*this.rect.width),g=parseFloat(i)*m/(100*this.rect.height);if(p>h||p>g)return{x:h,y:g}}return{x:p,y:p}}};function Xo(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Jo(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){jo(n,r,e[r],t)}))}var nl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ko),this.overlay=Object.create(Vo),this.handler=Object.create(Wo),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Qo({},Uo,e),this.overlay.init(this),this.handler.init(this)}return Ho(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Io,jo(n,"click",this.handler.click),this.options.preloadImage&&No(Oo(n)));return this}},{key:"config",value:function(n){return n?(Qo(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),No(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),jo(document,"scroll",this.handler.scroll),jo(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&jo(window,"resize",this.handler.resizeWindow);var a=function n(){jo(r,$o,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Jo(document,e.handler,!0),t(r)};return jo(r,$o,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=zo,this.overlay.fadeOut(),this.target.zoomOut(),jo(document,"scroll",this.handler.scroll,!1),jo(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&jo(window,"resize",this.handler.resizeWindow,!1);var r=function r(){jo(t,$o,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Jo(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return jo(t,$o,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){jo(i,$o,n,!1),r(i)};return jo(i,$o,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ao,this.target.move(n,e,t);var i=this.target.el,a=function n(){jo(i,$o,n,!1),r(i)};return jo(i,$o,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=zo,this.target.restoreOpenStyle();var r=function r(){jo(t,$o,r,!1),n.lock=!1,n.released=!0,e(t)};return jo(t,$o,r),this}}}]),n}();const el=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),tl=Number("500");class rl{constructor(){this.instance=new nl(el)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=tl){setTimeout(()=>this.update(n),e)}}var il=[vo,wo,To,Po,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new rl,this.$vuepress.zooming.updateDelay()}}],al={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return po("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},sl=t(8),ol=Object(sl.a)(al,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(ol,"mixins",il);const ll=[{name:"v-eb60e52c",path:"/CompetitiveProgramming/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-eb60e52c").then(t)}},{path:"/CompetitiveProgramming/index.html",redirect:"/CompetitiveProgramming/"},{path:"/00.目录页/01.Competitive Programming.html",redirect:"/CompetitiveProgramming/"},{name:"v-14ae4ae1",path:"/Research/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-14ae4ae1").then(t)}},{path:"/Research/index.html",redirect:"/Research/"},{path:"/00.目录页/02.Research.html",redirect:"/Research/"},{name:"v-db872dc4",path:"/LearningNotes/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-db872dc4").then(t)}},{path:"/LearningNotes/index.html",redirect:"/LearningNotes/"},{path:"/00.目录页/03.Learning Notes.html",redirect:"/LearningNotes/"},{name:"v-1fdb2df8",path:"/CasualRecords/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-1fdb2df8").then(t)}},{path:"/CasualRecords/index.html",redirect:"/CasualRecords/"},{path:"/00.目录页/04.Casual Records.html",redirect:"/CasualRecords/"},{name:"v-17e23a6a",path:"/ProgrammingLanguages/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-17e23a6a").then(t)}},{path:"/ProgrammingLanguages/index.html",redirect:"/ProgrammingLanguages/"},{path:"/00.目录页/05.Programming Languages.html",redirect:"/ProgrammingLanguages/"},{name:"v-f42ff692",path:"/pages/82da93/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-f42ff692").then(t)}},{path:"/pages/82da93/index.html",redirect:"/pages/82da93/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/02.LeetCode 308th Weekly Contest.html",redirect:"/pages/82da93/"},{name:"v-68bd270f",path:"/pages/93641c/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-68bd270f").then(t)}},{path:"/pages/93641c/index.html",redirect:"/pages/93641c/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/03.LeetCode 86th Biweekly Contest.html",redirect:"/pages/93641c/"},{name:"v-a584c712",path:"/pages/dc89c0/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-a584c712").then(t)}},{path:"/pages/dc89c0/index.html",redirect:"/pages/dc89c0/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/01.LeetCode 307th Weekly Contest.html",redirect:"/pages/dc89c0/"},{name:"v-706c3357",path:"/pages/4804d1/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-706c3357").then(t)}},{path:"/pages/4804d1/index.html",redirect:"/pages/4804d1/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/04.LeetCode 310th Weekly Contest.html",redirect:"/pages/4804d1/"},{name:"v-0edbe937",path:"/pages/e43306/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-0edbe937").then(t)}},{path:"/pages/e43306/index.html",redirect:"/pages/e43306/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/05.LeetCode 312th Weekly Contest.html",redirect:"/pages/e43306/"},{name:"v-30f35d12",path:"/pages/4c0651/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-30f35d12").then(t)}},{path:"/pages/4c0651/index.html",redirect:"/pages/4c0651/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/06.LeetCode 313th Weekly Contest.html",redirect:"/pages/4c0651/"},{name:"v-db77d4ca",path:"/pages/3ceb05/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-db77d4ca").then(t)}},{path:"/pages/3ceb05/index.html",redirect:"/pages/3ceb05/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/07.LeetCode 88th Biweekly Contest.html",redirect:"/pages/3ceb05/"},{name:"v-74aa51d7",path:"/pages/445c9b/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-74aa51d7").then(t)}},{path:"/pages/445c9b/index.html",redirect:"/pages/445c9b/"},{path:"/01.Competitive Programming/01.LeetCode周赛/01.Contests/08.LeetCode 321th Weekly Contest.html",redirect:"/pages/445c9b/"},{name:"v-1211effb",path:"/pages/29a8bf/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-1211effb").then(t)}},{path:"/pages/29a8bf/index.html",redirect:"/pages/29a8bf/"},{path:"/01.Competitive Programming/02.Acwing周赛/01.Contests/01.Acwing 64th Weekly Contest.html",redirect:"/pages/29a8bf/"},{name:"v-0850134b",path:"/pages/bdac31/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-0850134b").then(t)}},{path:"/pages/bdac31/index.html",redirect:"/pages/bdac31/"},{path:"/01.Competitive Programming/04.题解/01.洛谷P6510.html",redirect:"/pages/bdac31/"},{name:"v-ca59abba",path:"/pages/285600/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-ca59abba").then(t)}},{path:"/pages/285600/index.html",redirect:"/pages/285600/"},{path:"/01.Competitive Programming/04.题解/02.ABC283_F.html",redirect:"/pages/285600/"},{name:"v-4588700e",path:"/pages/547f66/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-4588700e").then(t)}},{path:"/pages/547f66/index.html",redirect:"/pages/547f66/"},{path:"/02.Research/01.Paper Reading/01.Petri Net/01.整理：基于着色Petri网的无人机侦察战术规划.html",redirect:"/pages/547f66/"},{name:"v-10dcc84e",path:"/pages/2498ed/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-10dcc84e").then(t)}},{path:"/pages/2498ed/index.html",redirect:"/pages/2498ed/"},{path:"/02.Research/02.Static Analysis/01.NJU Course Notes/01.Introduction.html",redirect:"/pages/2498ed/"},{name:"v-62cfc316",path:"/pages/382964/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-62cfc316").then(t)}},{path:"/pages/382964/index.html",redirect:"/pages/382964/"},{path:"/02.Research/03.Deep Learning/01.Dive into Deep Learning.html",redirect:"/pages/382964/"},{name:"v-5dd5a642",path:"/pages/0b751d/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-5dd5a642").then(t)}},{path:"/pages/0b751d/index.html",redirect:"/pages/0b751d/"},{path:"/01.Competitive Programming/03.刷题日寄/01.简简单单刷个题⑧.html",redirect:"/pages/0b751d/"},{name:"v-ea6ca4f0",path:"/pages/80231f/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-ea6ca4f0").then(t)}},{path:"/pages/80231f/index.html",redirect:"/pages/80231f/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/01.Lab1: Unix utilities.html",redirect:"/pages/80231f/"},{name:"v-07a99e36",path:"/pages/6818d5/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-07a99e36").then(t)}},{path:"/pages/6818d5/index.html",redirect:"/pages/6818d5/"},{path:"/02.Research/02.Static Analysis/01.NJU Course Notes/02.Intermediate Representation(IR).html",redirect:"/pages/6818d5/"},{name:"v-08d656b6",path:"/pages/4708e0/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-08d656b6").then(t)}},{path:"/pages/4708e0/index.html",redirect:"/pages/4708e0/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/010.Lab10: Mmap.html",redirect:"/pages/4708e0/"},{name:"v-24a8be88",path:"/pages/e84f04/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-24a8be88").then(t)}},{path:"/pages/e84f04/index.html",redirect:"/pages/e84f04/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/02.Lab2: System Calls.html",redirect:"/pages/e84f04/"},{name:"v-e38ed39e",path:"/pages/80245f/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-e38ed39e").then(t)}},{path:"/pages/80245f/index.html",redirect:"/pages/80245f/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/04.Lab4: Traps.html",redirect:"/pages/80245f/"},{name:"v-0f826bae",path:"/pages/aa266f/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-0f826bae").then(t)}},{path:"/pages/aa266f/index.html",redirect:"/pages/aa266f/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/03.Lab3: Page Tables.html",redirect:"/pages/aa266f/"},{name:"v-3e1953e8",path:"/pages/810ff6/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-3e1953e8").then(t)}},{path:"/pages/810ff6/index.html",redirect:"/pages/810ff6/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/05.Lab5: Copy-on-Write Fork for xv6.html",redirect:"/pages/810ff6/"},{name:"v-df166c36",path:"/pages/2bb440/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-df166c36").then(t)}},{path:"/pages/2bb440/index.html",redirect:"/pages/2bb440/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/06.Lab6: Multithreading.html",redirect:"/pages/2bb440/"},{name:"v-ea583cf6",path:"/pages/b8b8a2/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-ea583cf6").then(t)}},{path:"/pages/b8b8a2/index.html",redirect:"/pages/b8b8a2/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/07.Lab7: Networking.html",redirect:"/pages/b8b8a2/"},{name:"v-2c3fadad",path:"/pages/19fce7/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-2c3fadad").then(t)}},{path:"/pages/19fce7/index.html",redirect:"/pages/19fce7/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/08.Lab8: Locks.html",redirect:"/pages/19fce7/"},{name:"v-0b190e48",path:"/pages/dda50b/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-0b190e48").then(t)}},{path:"/pages/dda50b/index.html",redirect:"/pages/dda50b/"},{path:"/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/01.Lab0：Networking warmup.html",redirect:"/pages/dda50b/"},{name:"v-44124b74",path:"/pages/865884/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-44124b74").then(t)}},{path:"/pages/865884/index.html",redirect:"/pages/865884/"},{path:"/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/09.Lab9: File System.html",redirect:"/pages/865884/"},{name:"v-5b207082",path:"/pages/dc39fe/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-5b207082").then(t)}},{path:"/pages/dc39fe/index.html",redirect:"/pages/dc39fe/"},{path:"/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/02.Lab1：stitching substrings into a byte stream.html",redirect:"/pages/dc39fe/"},{name:"v-fc061f2e",path:"/pages/875773/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-fc061f2e").then(t)}},{path:"/pages/875773/index.html",redirect:"/pages/875773/"},{path:"/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/03.Lab2：The TCP Receiver.html",redirect:"/pages/875773/"},{name:"v-08c775ea",path:"/pages/e07ff0/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-08c775ea").then(t)}},{path:"/pages/e07ff0/index.html",redirect:"/pages/e07ff0/"},{path:"/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/05.Lab4：The TCP Connection.html",redirect:"/pages/e07ff0/"},{name:"v-08eaab1d",path:"/pages/e12074/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-08eaab1d").then(t)}},{path:"/pages/e12074/index.html",redirect:"/pages/e12074/"},{path:"/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/04.Lab3：The TCP Sender.html",redirect:"/pages/e12074/"},{name:"v-acc71d30",path:"/pages/498a73/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-acc71d30").then(t)}},{path:"/pages/498a73/index.html",redirect:"/pages/498a73/"},{path:"/03.Learning Notes/03.DataBase/01.MySQL/01.MySQL 问题整理.html",redirect:"/pages/498a73/"},{name:"v-81e0e884",path:"/pages/c32e71/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-81e0e884").then(t)}},{path:"/pages/c32e71/index.html",redirect:"/pages/c32e71/"},{path:"/03.Learning Notes/03.DataBase/02.Redis/01.Redis 缓冲区溢出问题总结 copy.html",redirect:"/pages/c32e71/"},{name:"v-ed83a606",path:"/pages/aac048/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-ed83a606").then(t)}},{path:"/pages/aac048/index.html",redirect:"/pages/aac048/"},{path:"/03.Learning Notes/03.DataBase/02.Redis/02.「缓存和数据库一致性问题」阅读笔记.html",redirect:"/pages/aac048/"},{name:"v-fc04b82a",path:"/pages/15f315/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-fc04b82a").then(t)}},{path:"/pages/15f315/index.html",redirect:"/pages/15f315/"},{path:"/03.Learning Notes/04.Software Engineering/01.THU Course Notes/01.软工笔记01：概述.html",redirect:"/pages/15f315/"},{name:"v-37e5e89e",path:"/pages/7b3c38/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-37e5e89e").then(t)}},{path:"/pages/7b3c38/index.html",redirect:"/pages/7b3c38/"},{path:"/03.Learning Notes/04.Software Engineering/01.THU Course Notes/02.软工笔记02：软件过程.html",redirect:"/pages/7b3c38/"},{name:"v-4db5ae13",path:"/pages/d38254/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-4db5ae13").then(t)}},{path:"/pages/d38254/index.html",redirect:"/pages/d38254/"},{path:"/03.Learning Notes/04.Software Engineering/01.THU Course Notes/03.软工笔记03：用例建模.html",redirect:"/pages/d38254/"},{name:"v-dc8b9824",path:"/pages/b04817/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-dc8b9824").then(t)}},{path:"/pages/b04817/index.html",redirect:"/pages/b04817/"},{path:"/03.Learning Notes/05.Others/01.通过 Bit-Manipulation 实现 abs 函数.html",redirect:"/pages/b04817/"},{name:"v-f4b56318",path:"/pages/0e1ab0/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-f4b56318").then(t)}},{path:"/pages/0e1ab0/index.html",redirect:"/pages/0e1ab0/"},{path:"/03.Learning Notes/05.Others/02.408 计组笔记.html",redirect:"/pages/0e1ab0/"},{name:"v-8cc7ac4e",path:"/pages/96615a/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-8cc7ac4e").then(t)}},{path:"/pages/96615a/index.html",redirect:"/pages/96615a/"},{path:"/05.Programming Languages/01.CPP/01.【OOP】访问控制与继承.html",redirect:"/pages/96615a/"},{name:"v-bedbdb3a",path:"/pages/03d2a3/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-bedbdb3a").then(t)}},{path:"/pages/03d2a3/index.html",redirect:"/pages/03d2a3/"},{path:"/05.Programming Languages/01.CPP/02.右值引用与std::move().html",redirect:"/pages/03d2a3/"},{name:"v-5a61da48",path:"/pages/f2991f/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-5a61da48").then(t)}},{path:"/pages/f2991f/index.html",redirect:"/pages/f2991f/"},{path:"/05.Programming Languages/02.Golang/01. Go 语言中的 GC 问题整理.html",redirect:"/pages/f2991f/"},{name:"v-20c29ae8",path:"/pages/843296/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-20c29ae8").then(t)}},{path:"/pages/843296/index.html",redirect:"/pages/843296/"},{path:"/05.Programming Languages/02.Golang/02. Go 语言中的 channel 相关问题整理.html",redirect:"/pages/843296/"},{name:"v-62d053a2",path:"/pages/018443/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-62d053a2").then(t)}},{path:"/pages/018443/index.html",redirect:"/pages/018443/"},{path:"/x04.Casual Records/01.一些最近.html",redirect:"/pages/018443/"},{name:"v-36182552",path:"/pages/ef3649/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-36182552").then(t)}},{path:"/pages/ef3649/index.html",redirect:"/pages/ef3649/"},{path:"/x04.Casual Records/02.25 考研随记.html",redirect:"/pages/ef3649/"},{name:"v-702df9d4",path:"/tags/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-702df9d4").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-464606d4",path:"/archives/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-464606d4").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-89715122",path:"/",component:ol,beforeEnter:(n,e,t)=>{uo("Layout","v-89715122").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:ol}],cl={title:"Yra's blog",description:"记录个人的CS学习，内容或许会很杂。Contact me : wenjun-1216@qq.com",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["link",{rel:"stylesheet",href:"https://at.alicdn.com/t/font_3114978_qe0b39no76.css"}],["meta",{},{name:"referrer",content:"no-referrer-when-downgrade"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Competitive Programming",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.Competitive Programming",description:"程序设计竞赛中的一些解题记录和算法学习笔记"}},title:"Competitive Programming",date:"2022-08-07T22:48:31.000Z",permalink:"/CompetitiveProgramming",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.Competitive%20Programming.html",relativePath:"00.目录页/01.Competitive Programming.md",key:"v-eb60e52c",path:"/CompetitiveProgramming/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Research",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Research",description:"磕盐方面的一点点学习记录"}},title:"Research",date:"2022-08-07T23:32:01.000Z",permalink:"/Research",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.Research.html",relativePath:"00.目录页/02.Research.md",key:"v-14ae4ae1",path:"/Research/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Learning Notes",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.Learning Notes",description:"一些学习笔记"}},title:"Learning Notes",date:"2022-09-10T21:43:01.000Z",permalink:"/LearningNotes",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.Learning%20Notes.html",relativePath:"00.目录页/03.Learning Notes.md",key:"v-db872dc4",path:"/LearningNotes/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Casual Records",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.Casual Records",description:"瞎写写，随便记录记录"}},title:"Casual Records",date:"2022-10-08T13:00:00.000Z",permalink:"/CasualRecords",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.Casual%20Records.html",relativePath:"00.目录页/04.Casual Records.md",key:"v-1fdb2df8",path:"/CasualRecords/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Programming Languages",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.Programming Languages",description:"一些编程语言的学习记录分享"}},title:"Programming Languages",date:"2022-10-31T15:00:00.000Z",permalink:"/ProgrammingLanguages",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.Programming%20Languages.html",relativePath:"00.目录页/05.Programming Languages.md",key:"v-17e23a6a",path:"/ProgrammingLanguages/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"LeetCode 308th Weekly Contest",frontmatter:{title:"LeetCode 308th Weekly Contest",date:"2022-08-29T14:34:47.000Z",permalink:"/pages/82da93/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/02.LeetCode%20308th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/02.LeetCode 308th Weekly Contest.md",key:"v-f42ff692",path:"/pages/82da93/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:47},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:149},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:682},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:47},{level:3,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:149},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:37},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:47},{level:3,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:149},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:1823},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:47},{level:3,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:149}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 代码 B 题目 思路 代码 C 题目 思路 代码 D 题目 思路 代码",content:"# A\n\n\n# 题目\n\n2389. 和有限的最长子序列 - 力扣（LeetCode）\n\n\n# 思路\n\n根据贪心，我们每次要选取尽可能小的数字才能保证长度最大，因此先从小到大对 进行排序，对于 我们从头开始选取 的元素，直到选取的元素之和不满足条件或数组遍历完结束，得到的长度就是最大长度。\n\n\n# 代码\n\n\nclass Solution {\npublic:\n    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n        std::vector<int> res;\n        std::sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for (auto up : queries) {\n            int sum = 0;\n            int i = 0;\n            for (i = 0; i < n; i ++) {\n                sum += nums[i];\n                if (sum > up) break;\n            }\n            if (i == n) res.push_back(n);\n            else res.push_back(i);\n        }\n        return res;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2390. 从字符串中移除星号 - 力扣（LeetCode）\n\n\n# 思路\n\n模拟即可，遍历字符串 ，如果是非星号字符，则加入答案字符串，否则弹出答案字符串的最后一位即可。\n\n\n# 代码\n\n\nclass Solution {\npublic:\n  string removeStars(string s) {\n      std::string res;\n      for (auto c : s) {\n          if (c != '*') {\n              res += c;\n          } else {\n              res.pop_back();\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2391. 收集垃圾的最少总时间 - 力扣（LeetCode）\n\n\n# 思路\n\n对于 、、 ，我们找出他们出现的最远位置，答案分别加上对应的 前缀和即可，最后将所有字符串的长度统计进答案即可。\n\n\n# 代码\n\n\nclass Solution {\nusing ll = long long;\npublic:\n  int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n      int n = garbage.size();\n      std::vector<ll> psum(n);\n      for (int i = 0; i < n - 1; i ++) {\n          psum[i + 1] = psum[i] + travel[i]; \n      }\n      ll res = 0; \n      std::map<char, bool> st;\n      for (int i = n - 1; i > 0; i --) {\n          for (auto c : garbage[i]) {\n              if (st[c]) continue;\n              res += psum[i];\n              st[c] = 1;\n          }\n          if (st['G'] && st['M'] && st['P']) break;\n      }\n      for (auto s : garbage) {\n          res += s.size();\n      }\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2392. 给定条件下构造矩阵 - 力扣（LeetCode）\n\n\n# 思路\n\n假设仅考虑行的情况，我们可以对数字建一张图， 表示在数字 和 之间连一条有向边，不难发现其实就是进行拓扑排序。\n\n对于列同理，因此我们先进行两次拓扑排序，然后对于数字 ，我们分别找出他在两次拓扑排序中的位置，并放入答案矩阵中即可。\n\n如果出现拓扑排序失败的情况则说明无解。\n\n\n# 代码\n\n\nclass Solution {\npublic:\n  std::vector<int> toposort(int n, std::vector<std::vector<int>>& es) {\n          std::vector<std::vector<int>> g(n + 1);\n          std::vector<int> d(n + 1);\n          for (auto& e: es) g[e[0]].push_back(e[1]), d[e[1]] ++ ;\n          std::queue<int> q;\n          for (int i = 1; i <= n; i ++)\n              if (!d[i]) {\n                  q.push(i);\n              }\n          \n          std::vector<int> res;\n          while (q.size()) {\n              auto t = q.front();\n              q.pop();\n              res.push_back(t);\n              \n              for (int j: g[t])\n                  if ( -- d[j] == 0)\n                      q.push(j);\n          }\n          \n          return res;\n  }\n\n  vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\n      auto row = toposort(k, rowConditions);\n      auto col = toposort(k, colConditions);\n      if (row.size() < k || col.size() < k) return {};\n      std::map<int, int> rpos, cpos;\n      for (int i = 0; i < k; i ++) rpos[row[i]] = i, cpos[col[i]] = i;\n      std::vector res(k, std::vector<int> (k));\n      for (int i = 1; i <= k; i ++) {\n          res[rpos[i]][cpos[i]] = i;\n      }\n      return res;\n  } \n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2389. 和有限的最长子序列 - 力扣（leetcode）\n\n\n# 思路\n\n根据贪心，我们每次要选取尽可能小的数字才能保证长度最大，因此先从小到大对 进行排序，对于 我们从头开始选取 的元素，直到选取的元素之和不满足条件或数组遍历完结束，得到的长度就是最大长度。\n\n\n# 代码\n\n\nclass solution {\npublic:\n    vector<int> answerqueries(vector<int>& nums, vector<int>& queries) {\n        std::vector<int> res;\n        std::sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for (auto up : queries) {\n            int sum = 0;\n            int i = 0;\n            for (i = 0; i < n; i ++) {\n                sum += nums[i];\n                if (sum > up) break;\n            }\n            if (i == n) res.push_back(n);\n            else res.push_back(i);\n        }\n        return res;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2390. 从字符串中移除星号 - 力扣（leetcode）\n\n\n# 思路\n\n模拟即可，遍历字符串 ，如果是非星号字符，则加入答案字符串，否则弹出答案字符串的最后一位即可。\n\n\n# 代码\n\n\nclass solution {\npublic:\n  string removestars(string s) {\n      std::string res;\n      for (auto c : s) {\n          if (c != '*') {\n              res += c;\n          } else {\n              res.pop_back();\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2391. 收集垃圾的最少总时间 - 力扣（leetcode）\n\n\n# 思路\n\n对于 、、 ，我们找出他们出现的最远位置，答案分别加上对应的 前缀和即可，最后将所有字符串的长度统计进答案即可。\n\n\n# 代码\n\n\nclass solution {\nusing ll = long long;\npublic:\n  int garbagecollection(vector<string>& garbage, vector<int>& travel) {\n      int n = garbage.size();\n      std::vector<ll> psum(n);\n      for (int i = 0; i < n - 1; i ++) {\n          psum[i + 1] = psum[i] + travel[i]; \n      }\n      ll res = 0; \n      std::map<char, bool> st;\n      for (int i = n - 1; i > 0; i --) {\n          for (auto c : garbage[i]) {\n              if (st[c]) continue;\n              res += psum[i];\n              st[c] = 1;\n          }\n          if (st['g'] && st['m'] && st['p']) break;\n      }\n      for (auto s : garbage) {\n          res += s.size();\n      }\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2392. 给定条件下构造矩阵 - 力扣（leetcode）\n\n\n# 思路\n\n假设仅考虑行的情况，我们可以对数字建一张图， 表示在数字 和 之间连一条有向边，不难发现其实就是进行拓扑排序。\n\n对于列同理，因此我们先进行两次拓扑排序，然后对于数字 ，我们分别找出他在两次拓扑排序中的位置，并放入答案矩阵中即可。\n\n如果出现拓扑排序失败的情况则说明无解。\n\n\n# 代码\n\n\nclass solution {\npublic:\n  std::vector<int> toposort(int n, std::vector<std::vector<int>>& es) {\n          std::vector<std::vector<int>> g(n + 1);\n          std::vector<int> d(n + 1);\n          for (auto& e: es) g[e[0]].push_back(e[1]), d[e[1]] ++ ;\n          std::queue<int> q;\n          for (int i = 1; i <= n; i ++)\n              if (!d[i]) {\n                  q.push(i);\n              }\n          \n          std::vector<int> res;\n          while (q.size()) {\n              auto t = q.front();\n              q.pop();\n              res.push_back(t);\n              \n              for (int j: g[t])\n                  if ( -- d[j] == 0)\n                      q.push(j);\n          }\n          \n          return res;\n  }\n\n  vector<vector<int>> buildmatrix(int k, vector<vector<int>>& rowconditions, vector<vector<int>>& colconditions) {\n      auto row = toposort(k, rowconditions);\n      auto col = toposort(k, colconditions);\n      if (row.size() < k || col.size() < k) return {};\n      std::map<int, int> rpos, cpos;\n      for (int i = 0; i < k; i ++) rpos[row[i]] = i, cpos[col[i]] = i;\n      std::vector res(k, std::vector<int> (k));\n      for (int i = 1; i <= k; i ++) {\n          res[rpos[i]][cpos[i]] = i;\n      }\n      return res;\n  } \n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 86th Biweekly Contest",frontmatter:{title:"LeetCode 86th Biweekly Contest",date:"2022-09-04T21:49:04.000Z",permalink:"/pages/93641c/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/03.LeetCode%2086th%20Biweekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/03.LeetCode 86th Biweekly Contest.md",key:"v-68bd270f",path:"/pages/93641c/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:45},{level:4,title:"1. 枚举",slug:"_1-枚举",normalizedTitle:"1. 枚举",charIndex:51},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:72},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:445},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:45},{level:4,title:"1. 数学",slug:"_1-数学",normalizedTitle:"1. 数学",charIndex:495},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:72},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:35},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:45},{level:4,title:"1. 二进制枚举",slug:"_1-二进制枚举",normalizedTitle:"1. 二进制枚举",charIndex:725},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:72},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:2007},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:45},{level:4,title:"1. 二分 + 单调队列 $O(nlogn)$",slug:"_1-二分-单调队列",normalizedTitle:'1. 二分 + 单调队列 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" viewbox="0 -750 4001 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mi" transform="translate(1752, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(2050, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(2535, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(3012, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3612, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:72},{level:4,title:"2. 双指针 + 单调队列 $O(n)$",slug:"_2-双指针-单调队列",normalizedTitle:'2. 双指针 + 单调队列 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-5",normalizedTitle:"代码",charIndex:72}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 枚举 代码 B 题目 思路 1. 数学 代码 C 题目 思路 1. 二进制枚举 代码 D 题目 思路 1. 二分 + 单调队列 $O(nlogn)$ 代码 2. 双指针 + 单调队列 $O(n)$ 代码",content:"# A\n\n\n# 题目\n\n6171. 和相等的子数组 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n枚举所有情况判断即可\n\n# 代码\n\n\nclass Solution {\npublic:\n    bool findSubarrays(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n - 1; i ++) {\n            for (int j = 0; j < n - 1; j ++) {\n                if (i == j) continue;\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) return true;\n            }\n        }\n        return false;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n数学证明 - 严格回文的数字 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 数学\n\n对于 ，容易发现 在 进制下，值为 ，不满足回文；\n\n对于 ， 在 进制下，值为 ，也不满足回文。\n\n综上，一定不存在严格回文的数字。\n\n# 代码\n\n\nclass Solution {\npublic:\n  bool isStrictlyPalindromic(int n) {\n      return false;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n6173. 被列覆盖的最多行数 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 二进制枚举\n\n看一眼数据，，因此直接暴力即可。\n\n二进制枚举去枚举所有情况，在所有可行状态中取可覆盖行数的最大值即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int maximumRows(vector<vector<int>>& mat, int cols) {\n      int n = mat.size(), m = mat[0].size();\n\n      auto get = [&](int x) { // 求 x 中有多少个 1\n          int cnt = 0;\n          for (int z = 0; z < 12; z ++) {\n              if (x & (1 << z)) cnt ++;\n          }\n          return cnt;\n      };\n\n      auto check = [&](int o) { // 判断 o 有多少个可覆盖行\n          auto t = mat; // 备份矩阵\n          for (int z = 0; z < 12; z ++) { //将所有带 1 的列清空\n              if (o & (1 << z)) {\n                  for (int i = 0; i < n; i ++) {\n                      t[i][z] = 0;\n                  }\n              }\n          };\n          int cnt = 0; // 统计可覆盖行数\n          for (int i = 0; i < n; i ++) {\n              bool ok = true;\n              for (int j = 0; j < m; j ++) { \n                  if (t[i][j]) { // 如果该行有 1，则该行未被覆盖。\n                      ok = false;\n                      break;\n                  }\n              }\n              cnt += ok;\n          }\n          return cnt;\n      };\n      int res = 0;\n      for (int o = 0; o < (1 << m); o ++) {\n          int cnt = 0;\n          if (get(o) > cols) continue; // 判断是否可行\n          res = std::max(res, check(o));\n      }\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n6143. 预算内的最多机器人数目 - 力扣（LeetCode）\n\n\n# 思路\n\n题目翻译有点问题，题干中的 连续 指的是下标连续。\n\n前置题：239. 滑动窗口最大值 - 力扣（LeetCode）\n\n# 1. 二分 + 单调队列\n\n对 进行二分，判断是否成立的部分和滑动窗口的模板题基本一样，额外维护 个数的 和即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int q[50005];\n  using ll = long long;\n  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\n      int n = chargeTimes.size();\n      int L = 0, R = n;\n\n      auto check = [&](int k) {\n          int hh = 0, tt = -1;\n          ll sum = 0;\n          for (int i = 0; i < n; i ++) {\n              if (hh <= tt && q[hh] <= i - k) hh ++;\n              while (hh <= tt && chargeTimes[i] >= chargeTimes[q[tt]]) tt --;\n              q[++ tt] = i;\n              sum += 1ll * k * runningCosts[i];\n              if (i >= k) sum -= 1ll * k * runningCosts[i - k];\n              if (i >= k - 1 && sum + chargeTimes[q[hh]] <= budget) return true; \n          }\n          return false;\n      };\n\n      while (L < R) {\n          int m = (L + R + 1) >> 1;\n          if (check(m)) {\n              L = m;\n          } else {\n              R = m - 1;\n          }\n      }\n      return L;\n  }\n};\n\n\n\n\n# 2. 双指针 + 单调队列\n\n本题其实并不需要二分，我们用右指针进行遍历，并用单调队列维护区间最值，同时对每一个右指针，我们通过移动左指针，找到最长的满足条件的区间，并更新答案。\n\n# 代码\n\n\nclass Solution {\npublic:\n  using ll = long long;\n  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\n      int n = chargeTimes.size();\n      std::deque<int> DQ;\n      ll sum = 0;\n      int res = 0;\n      for (int i = 0, j = 0; j < n; j ++) {\n          sum += runningCosts[j];\n          while (!DQ.empty() && chargeTimes[j] >= chargeTimes[DQ.back()]) DQ.pop_back();\n          DQ.push_back(j);\n          while (!DQ.empty() && sum * (j - i + 1) + chargeTimes[DQ.front()] > budget) {\n              if (DQ.front() == i) DQ.pop_front();\n              sum -= runningCosts[i ++];\n          }  \n          res = std::max(res, j - i + 1);\n      }   \n      return res;\n  }\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n6171. 和相等的子数组 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n枚举所有情况判断即可\n\n# 代码\n\n\nclass solution {\npublic:\n    bool findsubarrays(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n - 1; i ++) {\n            for (int j = 0; j < n - 1; j ++) {\n                if (i == j) continue;\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) return true;\n            }\n        }\n        return false;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n数学证明 - 严格回文的数字 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 数学\n\n对于 ，容易发现 在 进制下，值为 ，不满足回文；\n\n对于 ， 在 进制下，值为 ，也不满足回文。\n\n综上，一定不存在严格回文的数字。\n\n# 代码\n\n\nclass solution {\npublic:\n  bool isstrictlypalindromic(int n) {\n      return false;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n6173. 被列覆盖的最多行数 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 二进制枚举\n\n看一眼数据，，因此直接暴力即可。\n\n二进制枚举去枚举所有情况，在所有可行状态中取可覆盖行数的最大值即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int maximumrows(vector<vector<int>>& mat, int cols) {\n      int n = mat.size(), m = mat[0].size();\n\n      auto get = [&](int x) { // 求 x 中有多少个 1\n          int cnt = 0;\n          for (int z = 0; z < 12; z ++) {\n              if (x & (1 << z)) cnt ++;\n          }\n          return cnt;\n      };\n\n      auto check = [&](int o) { // 判断 o 有多少个可覆盖行\n          auto t = mat; // 备份矩阵\n          for (int z = 0; z < 12; z ++) { //将所有带 1 的列清空\n              if (o & (1 << z)) {\n                  for (int i = 0; i < n; i ++) {\n                      t[i][z] = 0;\n                  }\n              }\n          };\n          int cnt = 0; // 统计可覆盖行数\n          for (int i = 0; i < n; i ++) {\n              bool ok = true;\n              for (int j = 0; j < m; j ++) { \n                  if (t[i][j]) { // 如果该行有 1，则该行未被覆盖。\n                      ok = false;\n                      break;\n                  }\n              }\n              cnt += ok;\n          }\n          return cnt;\n      };\n      int res = 0;\n      for (int o = 0; o < (1 << m); o ++) {\n          int cnt = 0;\n          if (get(o) > cols) continue; // 判断是否可行\n          res = std::max(res, check(o));\n      }\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n6143. 预算内的最多机器人数目 - 力扣（leetcode）\n\n\n# 思路\n\n题目翻译有点问题，题干中的 连续 指的是下标连续。\n\n前置题：239. 滑动窗口最大值 - 力扣（leetcode）\n\n# 1. 二分 + 单调队列\n\n对 进行二分，判断是否成立的部分和滑动窗口的模板题基本一样，额外维护 个数的 和即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int q[50005];\n  using ll = long long;\n  int maximumrobots(vector<int>& chargetimes, vector<int>& runningcosts, long long budget) {\n      int n = chargetimes.size();\n      int l = 0, r = n;\n\n      auto check = [&](int k) {\n          int hh = 0, tt = -1;\n          ll sum = 0;\n          for (int i = 0; i < n; i ++) {\n              if (hh <= tt && q[hh] <= i - k) hh ++;\n              while (hh <= tt && chargetimes[i] >= chargetimes[q[tt]]) tt --;\n              q[++ tt] = i;\n              sum += 1ll * k * runningcosts[i];\n              if (i >= k) sum -= 1ll * k * runningcosts[i - k];\n              if (i >= k - 1 && sum + chargetimes[q[hh]] <= budget) return true; \n          }\n          return false;\n      };\n\n      while (l < r) {\n          int m = (l + r + 1) >> 1;\n          if (check(m)) {\n              l = m;\n          } else {\n              r = m - 1;\n          }\n      }\n      return l;\n  }\n};\n\n\n\n\n# 2. 双指针 + 单调队列\n\n本题其实并不需要二分，我们用右指针进行遍历，并用单调队列维护区间最值，同时对每一个右指针，我们通过移动左指针，找到最长的满足条件的区间，并更新答案。\n\n# 代码\n\n\nclass solution {\npublic:\n  using ll = long long;\n  int maximumrobots(vector<int>& chargetimes, vector<int>& runningcosts, long long budget) {\n      int n = chargetimes.size();\n      std::deque<int> dq;\n      ll sum = 0;\n      int res = 0;\n      for (int i = 0, j = 0; j < n; j ++) {\n          sum += runningcosts[j];\n          while (!dq.empty() && chargetimes[j] >= chargetimes[dq.back()]) dq.pop_back();\n          dq.push_back(j);\n          while (!dq.empty() && sum * (j - i + 1) + chargetimes[dq.front()] > budget) {\n              if (dq.front() == i) dq.pop_front();\n              sum -= runningcosts[i ++];\n          }  \n          res = std::max(res, j - i + 1);\n      }   \n      return res;\n  }\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 307th Weekly Contest",frontmatter:{title:"LeetCode 307th Weekly Contest",date:"2022-08-23T10:20:21.000Z",permalink:"/pages/dc89c0/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/01.LeetCode%20307th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/01.LeetCode 307th Weekly Contest.md",key:"v-a584c712",path:"/pages/dc89c0/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:51},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:194},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:643},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:51},{level:3,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:194},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:41},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:51},{level:3,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:194},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:1652},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:51},{level:3,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:194}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 代码 B 题目 思路 代码 C 题目 思路 代码 D 题目 思路 代码",content:"# A\n\n\n# 题目\n\n2383. 赢得比赛需要的最少训练时长 - 力扣（LeetCode）\n\n\n# 思路\n\n对于精力，我们可以直接预处理出来所需要的训练时长。\n\n对于经验，我们可以对过程进行模拟，当需要训练来增加经验时候，根据贪心的思想，令此时initialExperience为experience[i] + 1，答案加上对应的训练时长，最后还要记得打败完对手要加上其经验值\n\n\n# 代码\n\n\nclass Solution {\npublic:\n    int minNumberOfHours(int ieng, int iexp, vector<int>& eng, vector<int>& exp) {\n        int res = 0;\n        res = std::max(0, std::accumulate(eng.begin(), eng.end(), 0) - ieng + 1);\n        int n = eng.size();\n        for (int i = 0; i < n; i ++) {\n            if (iexp <= exp[i]) res += exp[i] - iexp + 1, iexp = exp[i] + 1;\n            iexp += exp[i];\n            \n        }   \n        return res;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2384. 最大回文数字 - 力扣（LeetCode）\n\n\n# 思路\n\n将所有数字用哈希表存起来。先构造回文串的一半，用贪心的思想，从大到小遍历 9 到 0，如果个数大于等于 2，便可加入该数字，另外记得要特判前导零的情况。\n\n接着将字符串反转拼接，最后从大到小再次遍历 9 到 0，看看有没有留下的单个数字，有的话便加入到串中作为中间的那个数字即可。\n\n\n# 代码\n\n\nclass Solution {\npublic:\n  string largestPalindromic(string num) {\n      std::map<int, int> cnt;\n      for (auto x : num) cnt[x - '0'] ++;\n      std::string res;\n      for (int i = 9; i >= 0; i --) {\n          if (i == 0 && res == \"\") break; //处理前导零\n          if (cnt[i] >= 2) {\n              int t = cnt[i] / 2;\n              for (int j = 0; j < t; j ++) res.push_back(i + '0');\n              cnt[i] -= 2 * t;\n          }\n      }\n      std::string rev = res;\n      std::string z = \"\";\n      reverse(rev.begin(), rev.end());\n      for (int i = 9; i >= 0; i --) {\n          if (cnt[i]) {\n              z += i + '0';\n              break;\n          }\n      }\n      return res + z + rev;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2385. 感染二叉树需要的总时间 - 力扣（LeetCode）\n\n\n# 思路\n\n两次dfs。\n\n第一次从根开始dfs用邻接表建树，第二次从 start点开始dfs求最大深度即可。\n\n\n# 代码\n\n\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n  int N = 1e5 + 5;\n  int amountOfTime(TreeNode* root, int start) {\n      std::vector<int> e[N];\n      std::function<void(TreeNode*)> dfs1 = [&](TreeNode *node) {\n          if (node->left) {\n              e[node->val].push_back(node->left->val);\n              e[node->left->val].push_back(node->val);\n              dfs1(node->left);\n          }\n          if (node->right) {\n              e[node->val].push_back(node->right->val);\n              e[node->right->val].push_back(node->val);\n              dfs1(node->right);\n          }\n      };\n      std::function<int(int, int)> dfs2 = [&](int u, int fa) {\n          int res = 0;\n          for (auto to : e[u]) {\n              if (to == fa) continue;\n              res = std::max(res, dfs2(to, u) + 1);\n          }\n          return res;\n      };\n      dfs1(root);\n      return dfs2(start, -1);\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2386. 找出数组的第 K 大和 - 力扣（LeetCode）\n\n\n# 思路\n\n取 nums 中所有的非负元素之和，记为 ，并将所有元素取绝对值，因此任意子序列之和等于 减去 的某些元素的值（非负数之和减去某些非负数 或者 加上某些负数）\n\n用大根堆维护子序列之和吗，记 表示前 项数字之和为 ，初始时将 放入堆中，我们通过每次弹出堆顶，将元素减去 ，并考虑是否保留 的两种情况，分别放入堆中。我们每次操作都能得到子序列中最大的一个，经过 次操作后我们便能的到第 大的子序列之和了\n\n参考：两种做法：堆 / 二分（Python/Java/C++/Go） - 找出数组的第 K 大和 - 力扣（LeetCode）\n\n\n# 代码\n\n\nclass Solution {\nusing ll = long long;\npublic:\n  long long kSum(vector<int>& nums, int k) {\n      ll sum = 0;\n      int n = nums.size();\n      for (auto &x : nums) {\n          if (x >= 0) sum += x;\n          else x = -x; \n      }\n      std::sort(nums.begin(), nums.end());\n      std::priority_queue<std::pair<ll, int>> pq;\n      pq.emplace(sum, 0);\n      while (-- k) {\n          auto [sum, i] = pq.top();\n          pq.pop();\n          if (i < n) {\n              pq.emplace(sum - nums[i], i + 1);\n              if (i) pq.emplace(sum - nums[i] + nums[i - 1], i + 1);    \n          }\n      }\n      return pq.top().first;\n  }\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2383. 赢得比赛需要的最少训练时长 - 力扣（leetcode）\n\n\n# 思路\n\n对于精力，我们可以直接预处理出来所需要的训练时长。\n\n对于经验，我们可以对过程进行模拟，当需要训练来增加经验时候，根据贪心的思想，令此时initialexperience为experience[i] + 1，答案加上对应的训练时长，最后还要记得打败完对手要加上其经验值\n\n\n# 代码\n\n\nclass solution {\npublic:\n    int minnumberofhours(int ieng, int iexp, vector<int>& eng, vector<int>& exp) {\n        int res = 0;\n        res = std::max(0, std::accumulate(eng.begin(), eng.end(), 0) - ieng + 1);\n        int n = eng.size();\n        for (int i = 0; i < n; i ++) {\n            if (iexp <= exp[i]) res += exp[i] - iexp + 1, iexp = exp[i] + 1;\n            iexp += exp[i];\n            \n        }   \n        return res;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2384. 最大回文数字 - 力扣（leetcode）\n\n\n# 思路\n\n将所有数字用哈希表存起来。先构造回文串的一半，用贪心的思想，从大到小遍历 9 到 0，如果个数大于等于 2，便可加入该数字，另外记得要特判前导零的情况。\n\n接着将字符串反转拼接，最后从大到小再次遍历 9 到 0，看看有没有留下的单个数字，有的话便加入到串中作为中间的那个数字即可。\n\n\n# 代码\n\n\nclass solution {\npublic:\n  string largestpalindromic(string num) {\n      std::map<int, int> cnt;\n      for (auto x : num) cnt[x - '0'] ++;\n      std::string res;\n      for (int i = 9; i >= 0; i --) {\n          if (i == 0 && res == \"\") break; //处理前导零\n          if (cnt[i] >= 2) {\n              int t = cnt[i] / 2;\n              for (int j = 0; j < t; j ++) res.push_back(i + '0');\n              cnt[i] -= 2 * t;\n          }\n      }\n      std::string rev = res;\n      std::string z = \"\";\n      reverse(rev.begin(), rev.end());\n      for (int i = 9; i >= 0; i --) {\n          if (cnt[i]) {\n              z += i + '0';\n              break;\n          }\n      }\n      return res + z + rev;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2385. 感染二叉树需要的总时间 - 力扣（leetcode）\n\n\n# 思路\n\n两次dfs。\n\n第一次从根开始dfs用邻接表建树，第二次从 start点开始dfs求最大深度即可。\n\n\n# 代码\n\n\n/**\n* definition for a binary tree node.\n* struct treenode {\n*     int val;\n*     treenode *left;\n*     treenode *right;\n*     treenode() : val(0), left(nullptr), right(nullptr) {}\n*     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass solution {\npublic:\n  int n = 1e5 + 5;\n  int amountoftime(treenode* root, int start) {\n      std::vector<int> e[n];\n      std::function<void(treenode*)> dfs1 = [&](treenode *node) {\n          if (node->left) {\n              e[node->val].push_back(node->left->val);\n              e[node->left->val].push_back(node->val);\n              dfs1(node->left);\n          }\n          if (node->right) {\n              e[node->val].push_back(node->right->val);\n              e[node->right->val].push_back(node->val);\n              dfs1(node->right);\n          }\n      };\n      std::function<int(int, int)> dfs2 = [&](int u, int fa) {\n          int res = 0;\n          for (auto to : e[u]) {\n              if (to == fa) continue;\n              res = std::max(res, dfs2(to, u) + 1);\n          }\n          return res;\n      };\n      dfs1(root);\n      return dfs2(start, -1);\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2386. 找出数组的第 k 大和 - 力扣（leetcode）\n\n\n# 思路\n\n取 nums 中所有的非负元素之和，记为 ，并将所有元素取绝对值，因此任意子序列之和等于 减去 的某些元素的值（非负数之和减去某些非负数 或者 加上某些负数）\n\n用大根堆维护子序列之和吗，记 表示前 项数字之和为 ，初始时将 放入堆中，我们通过每次弹出堆顶，将元素减去 ，并考虑是否保留 的两种情况，分别放入堆中。我们每次操作都能得到子序列中最大的一个，经过 次操作后我们便能的到第 大的子序列之和了\n\n参考：两种做法：堆 / 二分（python/java/c++/go） - 找出数组的第 k 大和 - 力扣（leetcode）\n\n\n# 代码\n\n\nclass solution {\nusing ll = long long;\npublic:\n  long long ksum(vector<int>& nums, int k) {\n      ll sum = 0;\n      int n = nums.size();\n      for (auto &x : nums) {\n          if (x >= 0) sum += x;\n          else x = -x; \n      }\n      std::sort(nums.begin(), nums.end());\n      std::priority_queue<std::pair<ll, int>> pq;\n      pq.emplace(sum, 0);\n      while (-- k) {\n          auto [sum, i] = pq.top();\n          pq.pop();\n          if (i < n) {\n              pq.emplace(sum - nums[i], i + 1);\n              if (i) pq.emplace(sum - nums[i] + nums[i - 1], i + 1);    \n          }\n      }\n      return pq.top().first;\n  }\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 310th Weekly Contest",frontmatter:{title:"LeetCode 310th Weekly Contest",date:"2022-09-13T19:20:16.000Z",permalink:"/pages/4804d1/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/04.LeetCode%20310th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/04.LeetCode 310th Weekly Contest.md",key:"v-706c3357",path:"/pages/4804d1/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:48},{level:4,title:"1. 枚举",slug:"_1-枚举",normalizedTitle:"1. 枚举",charIndex:54},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:95},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:425},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:48},{level:4,title:"1. 枚举",slug:"_1-枚举-2",normalizedTitle:"1. 枚举",charIndex:54},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:95},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:38},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:48},{level:4,title:"1.贪心 + 优先队列",slug:"_1-贪心-优先队列",normalizedTitle:"1.贪心 + 优先队列",charIndex:931},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:95},{level:4,title:"2.差分",slug:"_2-差分",normalizedTitle:"2.差分",charIndex:1566},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:95},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:2070},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:48},{level:4,title:"1. DP + 线段树优化",slug:"_1-dp-线段树优化",normalizedTitle:"1. dp + 线段树优化",charIndex:2155},{level:4,title:"代码",slug:"代码-5",normalizedTitle:"代码",charIndex:95}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 枚举 代码 B 题目 思路 1. 枚举 代码 C 题目 思路 1.贪心 + 优先队列 代码 2.差分 代码 D 题目 思路 1. DP + 线段树优化 代码",content:"# A\n\n\n# 题目\n\n2404. 出现最频繁的偶数元素 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n用数组或者哈希表统计每个数字出现的次数，然后枚举以此判断即可\n\n# 代码\n\n\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        std::map<int, int> cnt;\n        for (auto x : nums) cnt[x] ++;\n        int maxcnt = -1, maxv = -1;\n        for (auto [x, cc] : cnt) {\n            if (x % 2 == 0 && cc > maxcnt) maxv = x, maxcnt = cc;\n        }\n        return maxv;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2405. 子字符串的最优划分 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n从头往后枚举\n\n# 代码\n\n\nclass Solution {\npublic:\n  int partitionString(string s) {\n      int res = 0;\n      std::vector<bool> pos(26);\n      for (auto x : s) {\n          if (pos[x - 'a']) {\n              res ++;\n              for (int i = 0; i < 26; i ++) pos[i] = 0;\n              pos[x - 'a'] = 1;\n          } else {\n              pos[x - 'a'] = 1;\n          }\n      }\n      return res + 1;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2406. 将区间分为最少组数 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1.贪心 + 优先队列\n\n先对序列按左端点进行排序，然后用小根堆维护最小的右端点，每次取最小的右端点和当前的区间进行比较。如果没有相交，就取出堆顶并放入当前区间的右端点，表示合并到一个组中；否则有相交，则直接入堆当前区间的右端点即可。最终答案便是优先队列的长度。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int minGroups(vector<vector<int>>& intervals) {\n      std::sort(intervals.begin(), intervals.end());\n      int n = intervals.size();\n      std::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n      for (int i = 0; i < n; i ++) {\n          if (pq.empty() || pq.top() >= intervals[i][0]) pq.emplace(intervals[i][1]);\n          else {\n              pq.pop();\n              pq.emplace(intervals[i][1]);\n          }\n      }\n      return pq.size();\n  }\n};\n\n\n\n# 2.差分\n\n通过差分，可以用 的时间进行区间修改，对任意区间 ，我们令 差分数组 dif[left] ++, dif[right + 1] --;。由于差分数组的前缀和等于单点的值，我们只需要遍历差分数组求前缀和，便能得到每个点的区间重叠个数，答案取其最大值即可\n\n# 代码\n\n\nclass Solution {\npublic:\n  int minGroups(vector<vector<int>>& intervals) {\n      int n = intervals.size();\n      std::vector<int> dif(1e6 + 2);\n\n      for (auto x : intervals) {\n          dif[x[0]] ++, dif[x[1] + 1] --;\n      }\n      int res = 0, sum = 0;\n\n      for (auto x : dif) {\n          res = std::max(res, sum += x);\n      }\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2407. 最长递增子序列 II - 力扣（LeetCode）\n\n\n# 思路\n\n前置题：300. 最长递增子序列 - 力扣（LeetCode）\n\n# 1. DP + 线段树优化\n\n前置题是一道 的裸题，不用优化的 ，时间复杂度是 。我们也可以通过二分并维护一个有序队列进行解题，时间复杂度是 。而对 可以用线段树进行优化，因为我们每次找的是前面的数中的最大值，所以可以用线段树维护区间最大值，将时间复杂度优化到 ，不过对于有负数的情况需要进行离散化。\n\n而本题便是基于 的 + 线段树优化来求解的，我们只需更改状态转移的条件为 严格递增并且差值不超过 即可。\n\n# 代码\n\n\nclass Solution {\npublic:\nusing ll = long long;\n  std::vector<int> max;\n  void modify(int u, int l, int r, int pos, int val) {\n      if (l == r) max[u] = val;\n      else {\n          int mid = (l + r) >> 1;\n          if (pos <= mid) modify(u << 1, l, mid, pos, val);\n          else modify(u << 1 | 1, mid + 1, r, pos, val);\n          max[u] = std::max(max[u << 1], max[u << 1 | 1]);\n      }\n  }\n\n  int query(int u, int l, int r, int L, int R) {\n      if (L <= l && r <= R) return max[u];\n      int res = 0;\n      int mid = (l + r) >> 1;\n      if (L <= mid) res = query(u << 1, l, mid, L, R);\n      if (R > mid) res = std::max(res, query(u << 1 | 1, mid + 1, r, L, R));\n      return res;\n  }\n\n  int lengthOfLIS(vector<int>& nums, int k) {\n      int n = nums.size();\n      int mx = *max_element(nums.begin(), nums.end());\n      max.resize(mx * 4 + 10);\n      for (int i = 0; i < n; i ++) {\n          if (nums[i] == 1) modify(1, 1, mx, 1, 1);\n          else {\n              int maxv = query(1, 1, mx, std::max(1, nums[i] - k), nums[i] - 1) + 1;\n              modify(1, 1, mx, nums[i], std::max(1, maxv));\n          }\n      }\n      return max[1];\n  }\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2404. 出现最频繁的偶数元素 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n用数组或者哈希表统计每个数字出现的次数，然后枚举以此判断即可\n\n# 代码\n\n\nclass solution {\npublic:\n    int mostfrequenteven(vector<int>& nums) {\n        std::map<int, int> cnt;\n        for (auto x : nums) cnt[x] ++;\n        int maxcnt = -1, maxv = -1;\n        for (auto [x, cc] : cnt) {\n            if (x % 2 == 0 && cc > maxcnt) maxv = x, maxcnt = cc;\n        }\n        return maxv;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2405. 子字符串的最优划分 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n从头往后枚举\n\n# 代码\n\n\nclass solution {\npublic:\n  int partitionstring(string s) {\n      int res = 0;\n      std::vector<bool> pos(26);\n      for (auto x : s) {\n          if (pos[x - 'a']) {\n              res ++;\n              for (int i = 0; i < 26; i ++) pos[i] = 0;\n              pos[x - 'a'] = 1;\n          } else {\n              pos[x - 'a'] = 1;\n          }\n      }\n      return res + 1;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2406. 将区间分为最少组数 - 力扣（leetcode）\n\n\n# 思路\n\n# 1.贪心 + 优先队列\n\n先对序列按左端点进行排序，然后用小根堆维护最小的右端点，每次取最小的右端点和当前的区间进行比较。如果没有相交，就取出堆顶并放入当前区间的右端点，表示合并到一个组中；否则有相交，则直接入堆当前区间的右端点即可。最终答案便是优先队列的长度。\n\n# 代码\n\n\nclass solution {\npublic:\n  int mingroups(vector<vector<int>>& intervals) {\n      std::sort(intervals.begin(), intervals.end());\n      int n = intervals.size();\n      std::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n      for (int i = 0; i < n; i ++) {\n          if (pq.empty() || pq.top() >= intervals[i][0]) pq.emplace(intervals[i][1]);\n          else {\n              pq.pop();\n              pq.emplace(intervals[i][1]);\n          }\n      }\n      return pq.size();\n  }\n};\n\n\n\n# 2.差分\n\n通过差分，可以用 的时间进行区间修改，对任意区间 ，我们令 差分数组 dif[left] ++, dif[right + 1] --;。由于差分数组的前缀和等于单点的值，我们只需要遍历差分数组求前缀和，便能得到每个点的区间重叠个数，答案取其最大值即可\n\n# 代码\n\n\nclass solution {\npublic:\n  int mingroups(vector<vector<int>>& intervals) {\n      int n = intervals.size();\n      std::vector<int> dif(1e6 + 2);\n\n      for (auto x : intervals) {\n          dif[x[0]] ++, dif[x[1] + 1] --;\n      }\n      int res = 0, sum = 0;\n\n      for (auto x : dif) {\n          res = std::max(res, sum += x);\n      }\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2407. 最长递增子序列 ii - 力扣（leetcode）\n\n\n# 思路\n\n前置题：300. 最长递增子序列 - 力扣（leetcode）\n\n# 1. dp + 线段树优化\n\n前置题是一道 的裸题，不用优化的 ，时间复杂度是 。我们也可以通过二分并维护一个有序队列进行解题，时间复杂度是 。而对 可以用线段树进行优化，因为我们每次找的是前面的数中的最大值，所以可以用线段树维护区间最大值，将时间复杂度优化到 ，不过对于有负数的情况需要进行离散化。\n\n而本题便是基于 的 + 线段树优化来求解的，我们只需更改状态转移的条件为 严格递增并且差值不超过 即可。\n\n# 代码\n\n\nclass solution {\npublic:\nusing ll = long long;\n  std::vector<int> max;\n  void modify(int u, int l, int r, int pos, int val) {\n      if (l == r) max[u] = val;\n      else {\n          int mid = (l + r) >> 1;\n          if (pos <= mid) modify(u << 1, l, mid, pos, val);\n          else modify(u << 1 | 1, mid + 1, r, pos, val);\n          max[u] = std::max(max[u << 1], max[u << 1 | 1]);\n      }\n  }\n\n  int query(int u, int l, int r, int l, int r) {\n      if (l <= l && r <= r) return max[u];\n      int res = 0;\n      int mid = (l + r) >> 1;\n      if (l <= mid) res = query(u << 1, l, mid, l, r);\n      if (r > mid) res = std::max(res, query(u << 1 | 1, mid + 1, r, l, r));\n      return res;\n  }\n\n  int lengthoflis(vector<int>& nums, int k) {\n      int n = nums.size();\n      int mx = *max_element(nums.begin(), nums.end());\n      max.resize(mx * 4 + 10);\n      for (int i = 0; i < n; i ++) {\n          if (nums[i] == 1) modify(1, 1, mx, 1, 1);\n          else {\n              int maxv = query(1, 1, mx, std::max(1, nums[i] - k), nums[i] - 1) + 1;\n              modify(1, 1, mx, nums[i], std::max(1, maxv));\n          }\n      }\n      return max[1];\n  }\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 312th Weekly Contest",frontmatter:{title:"LeetCode 312th Weekly Contest",date:"2022-09-27T13:36:43.000Z",permalink:"/pages/e43306/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/05.LeetCode%20312th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/05.LeetCode 312th Weekly Contest.md",key:"v-0edbe937",path:"/pages/e43306/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:43},{level:4,title:"1. 排序 $O(nlogn)$",slug:"_1-排序",normalizedTitle:'1. 排序 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" viewbox="0 -750 4001 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mi" transform="translate(1752, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(2050, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(2535, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(3012, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3612, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:81},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:559},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:43},{level:4,title:"1. 思维题 + 枚举 $O(n)$",slug:"_1-思维题-枚举",normalizedTitle:'1. 思维题 + 枚举 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:81},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:33},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:43},{level:4,title:"1.枚举 $O(n)$",slug:"_1-枚举",normalizedTitle:'1.枚举 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:81},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:2106},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:43},{level:4,title:"1. 排序 + 并查集 $O(nlogn)$",slug:"_1-排序-并查集",normalizedTitle:'1. 排序 + 并查集 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" viewbox="0 -750 4001 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mi" transform="translate(1752, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(2050, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(2535, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(3012, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3612, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:81}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 排序 $O(nlogn)$ 代码 B 题目 思路 1. 思维题 + 枚举 $O(n)$ 代码 C 题目 思路 1.枚举 $O(n)$ 代码 D 题目 思路 1. 排序 + 并查集 $O(nlogn)$ 代码",content:"# A\n\n\n# 题目\n\n2418. 按身高排序 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 排序\n\n新建一个 id 数组，然后按题意排序即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\n        int n = names.size();\n        std::vector<int> a(n);\n        std::iota(a.begin(), a.end(), 0);\n        sort(a.begin(), a.end(), [&](int i, int j) {\n            return heights[i] > heights[j];\n        });\n        std::vector<std::string> res(n);\n        for (int i = 0; i < n; i ++) {\n            res[i] = names[a[i]];\n        }\n        return res;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2419. 按位与最大的最长子数组 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 思维题 + 枚举\n\n首先对于任一子数组的按位与的和，我们可以发现其值一定小于等于子数组中的最大值，当且仅当子数组所有数字相等时，取等号。\n\n因此我们不难发现本题中，子数组最大的按位与和就是数组中的最大值，所以我们只需要先求出数组中的最大值 ，然后从开头进行枚举，求连续的 最长长度即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int longestSubarray(vector<int>& nums) {\n      int k = *max_element(nums.begin(), nums.end());\n      \n      int res = 1, i = 0, n = nums.size();\n      while (i < n) {\n          if (nums[i] == k) {\n              int cnt = 1;\n              i ++;\n              while (i < n && nums[i] == k) {\n                  cnt ++, i ++;\n              }\n              res = std::max(res, cnt);\n          }\n          i ++;\n      }\n      return res;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2406. 将区间分为最少组数 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1.枚举\n\n(这道题我在赛时过是过了，但写的太烦了...)\n\n令 f[i] 表示以第 i 项作为结尾的最长非递增连续子序列，g[i] 表示以第 i 项作为开头的最长非递减连续子序列。\n\n我们先预处理一遍后，在对 k <= i < n - k 的每一项判断是否满足好下标条件 f[i - 1] >= k && g[i + 1] >= k 即可\n\n参考：枚举 - 找到所有好下标 - 力扣（LeetCode）\n\n# 代码\n\n\nclass Solution {\npublic:\n  vector<int> goodIndices(vector<int>& nums, int k) {\n      int n = nums.size();\n      std::vector<int> f(n), g(n);\n      f[0] = 1, g[n - 1] = 1;\n      for (int i = 1; i < n; i ++) {\n          if (nums[i] <= nums[i - 1]) f[i] = f[i - 1] + 1;\n          else f[i] = 1;\n      }\n      for (int i = n - 2; ~i; i --) {\n          if (nums[i] <= nums[i + 1]) g[i] = g[i + 1] + 1;\n          else g[i] = 1;\n      }\n      std::vector<int> res;\n      for (int i = k; i < n - k; i ++) {\n          if (f[i - 1] >= k && g[i + 1] >= k) res.emplace_back(i);\n      }\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2421. 好路径的数目 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 排序 + 并查集\n\n这道题的思路有点类似于最小生成树的算法。我们先对所有的点按权值进行排序，然后假设一棵树，开始时还没有结点在上面，然后我们从前往后依次去遍历排完序的点，对于当前的结点 ，我们再去遍历与 相连的所有点，设当前遍历到的与 相连的点为 ，如果此时 与 在一个连通块中，或者 的权值大于 (等后面遍历到结点 的时候再讨论) 时，我们就先不进行讨论。我们只需要判断在 所处的连通块中有多少个权值等于 点的结点，此时一定可以满足好路径的条件，注意 也可能在一个连通块中。而这些集合的操作我们就用并查集来实现，对于每个集合，我们令集合中的某个最大值结点作为集合的主导结点，其长度 size[fx]，表示在 fx 主导的集合中，权值等于vals[fx]的结点个数，所以按照乘法原理，每次答案要加上 size[find(x)] * size[find(y)]。最后，我们更新答案后，还要将 与 相连，合并为一个连通块，并且将小的集合合并到大的上面\n\n# 代码\n\n\nclass Solution {\npublic:\n  int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n      int n = vals.size();\n      std::vector<int> id(n), p(n), size(n, 1);\n      std::vector<std::vector<int>> G(n);\n      for (int i = 0; i < n; i ++) p[i] = id[i] = i;\n      \n      std::sort(id.begin(), id.end(), [&](int i, int j) {\n          return vals[i] < vals[j];\n      });\n\n      for (auto e : edges) {\n          int u = e[0], v = e[1];\n          G[u].emplace_back(v);\n          G[v].emplace_back(u);\n      }\n\n      std::function<int(int)> find = [&](int x) { \n          return x == p[x] ? x : p[x] = find(p[x]); \n      };\n\n      int res = n;\n\n      for (int x : id) {\n          int fx = find(x);\n          for (int y : G[x]) {\n              int fy = find(y);\n              if (fy == fx || vals[y] > vals[x]) continue;\n              if (vals[fy] == vals[x]) {\n                  res += size[fy] * size[fx];\n                  size[fx] += size[fy];\n              }\n              p[fy] = fx;\n          }\n      }\n      return res;\n  }\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2418. 按身高排序 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 排序\n\n新建一个 id 数组，然后按题意排序即可。\n\n# 代码\n\n\nclass solution {\npublic:\n    vector<string> sortpeople(vector<string>& names, vector<int>& heights) {\n        int n = names.size();\n        std::vector<int> a(n);\n        std::iota(a.begin(), a.end(), 0);\n        sort(a.begin(), a.end(), [&](int i, int j) {\n            return heights[i] > heights[j];\n        });\n        std::vector<std::string> res(n);\n        for (int i = 0; i < n; i ++) {\n            res[i] = names[a[i]];\n        }\n        return res;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2419. 按位与最大的最长子数组 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 思维题 + 枚举\n\n首先对于任一子数组的按位与的和，我们可以发现其值一定小于等于子数组中的最大值，当且仅当子数组所有数字相等时，取等号。\n\n因此我们不难发现本题中，子数组最大的按位与和就是数组中的最大值，所以我们只需要先求出数组中的最大值 ，然后从开头进行枚举，求连续的 最长长度即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int longestsubarray(vector<int>& nums) {\n      int k = *max_element(nums.begin(), nums.end());\n      \n      int res = 1, i = 0, n = nums.size();\n      while (i < n) {\n          if (nums[i] == k) {\n              int cnt = 1;\n              i ++;\n              while (i < n && nums[i] == k) {\n                  cnt ++, i ++;\n              }\n              res = std::max(res, cnt);\n          }\n          i ++;\n      }\n      return res;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2406. 将区间分为最少组数 - 力扣（leetcode）\n\n\n# 思路\n\n# 1.枚举\n\n(这道题我在赛时过是过了，但写的太烦了...)\n\n令 f[i] 表示以第 i 项作为结尾的最长非递增连续子序列，g[i] 表示以第 i 项作为开头的最长非递减连续子序列。\n\n我们先预处理一遍后，在对 k <= i < n - k 的每一项判断是否满足好下标条件 f[i - 1] >= k && g[i + 1] >= k 即可\n\n参考：枚举 - 找到所有好下标 - 力扣（leetcode）\n\n# 代码\n\n\nclass solution {\npublic:\n  vector<int> goodindices(vector<int>& nums, int k) {\n      int n = nums.size();\n      std::vector<int> f(n), g(n);\n      f[0] = 1, g[n - 1] = 1;\n      for (int i = 1; i < n; i ++) {\n          if (nums[i] <= nums[i - 1]) f[i] = f[i - 1] + 1;\n          else f[i] = 1;\n      }\n      for (int i = n - 2; ~i; i --) {\n          if (nums[i] <= nums[i + 1]) g[i] = g[i + 1] + 1;\n          else g[i] = 1;\n      }\n      std::vector<int> res;\n      for (int i = k; i < n - k; i ++) {\n          if (f[i - 1] >= k && g[i + 1] >= k) res.emplace_back(i);\n      }\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2421. 好路径的数目 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 排序 + 并查集\n\n这道题的思路有点类似于最小生成树的算法。我们先对所有的点按权值进行排序，然后假设一棵树，开始时还没有结点在上面，然后我们从前往后依次去遍历排完序的点，对于当前的结点 ，我们再去遍历与 相连的所有点，设当前遍历到的与 相连的点为 ，如果此时 与 在一个连通块中，或者 的权值大于 (等后面遍历到结点 的时候再讨论) 时，我们就先不进行讨论。我们只需要判断在 所处的连通块中有多少个权值等于 点的结点，此时一定可以满足好路径的条件，注意 也可能在一个连通块中。而这些集合的操作我们就用并查集来实现，对于每个集合，我们令集合中的某个最大值结点作为集合的主导结点，其长度 size[fx]，表示在 fx 主导的集合中，权值等于vals[fx]的结点个数，所以按照乘法原理，每次答案要加上 size[find(x)] * size[find(y)]。最后，我们更新答案后，还要将 与 相连，合并为一个连通块，并且将小的集合合并到大的上面\n\n# 代码\n\n\nclass solution {\npublic:\n  int numberofgoodpaths(vector<int>& vals, vector<vector<int>>& edges) {\n      int n = vals.size();\n      std::vector<int> id(n), p(n), size(n, 1);\n      std::vector<std::vector<int>> g(n);\n      for (int i = 0; i < n; i ++) p[i] = id[i] = i;\n      \n      std::sort(id.begin(), id.end(), [&](int i, int j) {\n          return vals[i] < vals[j];\n      });\n\n      for (auto e : edges) {\n          int u = e[0], v = e[1];\n          g[u].emplace_back(v);\n          g[v].emplace_back(u);\n      }\n\n      std::function<int(int)> find = [&](int x) { \n          return x == p[x] ? x : p[x] = find(p[x]); \n      };\n\n      int res = n;\n\n      for (int x : id) {\n          int fx = find(x);\n          for (int y : g[x]) {\n              int fy = find(y);\n              if (fy == fx || vals[y] > vals[x]) continue;\n              if (vals[fy] == vals[x]) {\n                  res += size[fy] * size[fx];\n                  size[fx] += size[fy];\n              }\n              p[fy] = fx;\n          }\n      }\n      return res;\n  }\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 313th Weekly Contest",frontmatter:{title:"LeetCode 313th Weekly Contest",date:"2022-10-07T17:52:09.000Z",permalink:"/pages/4c0651/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/06.LeetCode%20313th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/06.LeetCode 313th Weekly Contest.md",key:"v-30f35d12",path:"/pages/4c0651/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:44},{level:4,title:"1. 枚举 $O(n)$",slug:"_1-枚举",normalizedTitle:'1. 枚举 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:71},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:308},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:44},{level:4,title:"1. 枚举 $O(n)$",slug:"_1-枚举-2",normalizedTitle:'1. 枚举 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:71},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:34},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:44},{level:4,title:"1.贪心 + 分类讨论 + 位运算 $O(logn)$",slug:"_1-贪心-分类讨论-位运算",normalizedTitle:'1.贪心 + 分类讨论 + 位运算 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" viewbox="0 -750 3401 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(1450, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(1935, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(2412, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3012, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:71},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:2033},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:44},{level:4,title:"1. DP $O(n^2)$",slug:"_1-dp",normalizedTitle:'1. dp <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.757ex" height="2.452ex" viewbox="0 -833.9 2544.6 1083.9"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="msup" transform="translate(1152, 0)"><g data-mml-node="mi"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mn" transform="translate(600, 363) scale(0.707)"><path data-c="32" d="m109 429q82 429 66 447t50 491q50 562 103 614t235 666q326 666 387 610t449 465q449 422 429 383t381 315t301 241q265 210 201 149l142 93l218 92q375 92 385 97q392 99 409 186v189h449v186q448 183 436 95t421 3v0h50v19v31q50 38 56 46t86 81q115 113 136 137q145 147 170 174t204 211t233 244t261 278t284 308t305 340t320 369t333 401t340 431t343 464q343 527 309 573t212 619q179 619 154 602t119 569t109 550q109 549 114 549q132 549 151 535t170 489q170 464 154 447t109 429z"></path></g></g><g data-mml-node="mo" transform="translate(2155.6, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:71},{level:4,title:"2.非正解 DFS (本题数据交水，正常情况过不了本题)",slug:"_2-非正解-dfs-本题数据交水-正常情况过不了本题",normalizedTitle:"2.非正解 dfs (本题数据交水，正常情况过不了本题)",charIndex:2924},{level:4,title:"代码",slug:"代码-5",normalizedTitle:"代码",charIndex:71}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 枚举 $O(n)$ 代码 B 题目 思路 1. 枚举 $O(n)$ 代码 C 题目 思路 1.贪心 + 分类讨论 + 位运算 $O(logn)$ 代码 D 题目 思路 1. DP $O(n^2)$ 代码 2.非正解 DFS (本题数据交水，正常情况过不了本题) 代码",content:"# A\n\n\n# 题目\n\n2427. 公因子的数目 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n枚举所有公因子即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n    int commonFactors(int a, int b) {\n        int res = 0;\n        for (int i = 1; i <= std::min(a, b); i ++) {\n            if (a % i == 0 && b % i == 0) res ++;\n        }\n        return res;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2428. 沙漏的最大总和 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n暴力枚举左上角端点即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int maxSum(vector<vector<int>>& s) {\n      int res = 0;\n      int n = s.size(), m = s[0].size();\n      \n      for (int i = 0; i + 2 < n; i ++) {\n          for (int j = 0; j + 2 < m; j ++) {\n              int t = s[i][j] + s[i][j + 1] + s[i][j + 2] + s[i + 1][j + 1] + s[i + 2][j] + s[i + 2][j + 1] + s[i + 2][j + 2];\n              res = std::max(res, t);\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2429. 最小 XOR - 力扣（LeetCode）\n\n\n# 思路\n\n# 1.贪心 + 分类讨论 + 位运算\n\n首先我们令 z1 和 z2 分别表示 num1 和 num2 在二进制下的 1 的个数。\n\n接下来分三种情况讨论：\n\n 1. z1 = z2 此时我们直接令 x = num1，即 return num1 即可。\n 2. z1 < z2 这种情况下，对于我们要求的 x，根据贪心的思想我们要先让 x 在 num1 原本二进制位下为 1 的那些位赋值为 1，因为这样在 x 与 num1 异或后原本 num1 二进制下为 1 的那些位就为 0 了，接着多出来的 1，也就是 z2 - z1，我们对 x 从低位到高位将其二进制位仍为 0 的位依次赋值即可。\n 3. z1 > z2 在这种情况下，我们是要去尽可能削减 num1 的值，因此我们将 z2 个 1，依次从高位到低位看 num1 的每一位是否为 1，依次给 x 赋值来抵消即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int minimizeXor(int num1, int num2) {\n      int z1 = __builtin_popcount(num1), z2 = __builtin_popcount(num2);\n      if (z1 == z2) return num1;\n      \n      if (z1 < z2) {\n          int dif = z2 - z1;\n          int res = 0;\n          for (int i = 0; i < 32; i ++) {\n              int z = num1 >> i & 1;\n              if (!z) {\n                  num1 ^= 1 << i;\n                  dif --;\n              }\n              if (!dif) return num1;\n          }\n      } else {\n          int res = 0;\n          for (int i = 31; ~i; i --) {\n              int z = num1 >> i & 1;\n              if (z) {\n                  res ^= 1 << i;\n                  z2 --;\n              }\n              if (!z2) return res;\n          }\n      }\n      return 1;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2430. 对字母串可执行的最大删除数 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. DP\n\n我们先令 表示对 可执行的最大删除数，我们枚举这一次的删除长度 ，如果满足 ，即满足删除条件，就可以很容易得到状态转移方程 。最后输出 即可，在最后输出的时候需要 + 1 是因为我们字符串删到最后一步，一定是整个字符串全部删除，即找不到满足可以删除条件的长度 。\n\n参考：线性 DP（Python/Java/C++/Go） - 对字母串可执行的最大删除数 - 力扣（LeetCode）\n\n# 代码\n\n\nclass Solution {\npublic:\n  int deleteString(string s) {\n      int n = s.size();\n      std::vector dp(n + 1, std::vector<int> (n + 1));\n\n      for (int i = n - 1; ~i; i --) {\n          for (int j = n - 1; ~j; j --) {\n              if (s[i] == s[j]) {\n                  dp[i][j] = dp[i + 1][j + 1] + 1;\n              }\n          }\n      }\n\n      std::vector<int> f(n + 1);\n      for (int i = n - 1; ~i; i --) {\n          for (int j = 1; i + 2 * j - 1 < n; j ++) {\n              if (dp[i][i + j] >= j) {\n                  f[i] = std::max(f[i], f[i + j] + 1);\n              }\n          }\n      }\n\n      return f[0] + 1;\n  }\n};\n\n\n\n# 2.非正解 DFS (本题数据交水，正常情况过不了本题)\n\n暴搜所有的情况，加上记忆化 和 对特殊样例的特判即可，由于非正解就不细说了。。。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int n;\n  std::vector<int> f;\n  int deleteString(string s) {\n      n = s.size();\n      std::vector<int> to[n];\n      f.resize(n);\n      std::set<char> S;\n      for (auto x : s) \n          S.insert(x);\n      if (S.size() == 1) return n;\n      int INF = 1e9;\n      for (int i = 0; i < n; i ++) {\n          for (int z = 1; i + 2 * z - 1 < n && z <= n; z ++) {\n              int cnt = 0;\n              for (int k = 0; k < z; k ++) { \n                  if (s[i + k] == s[i + k + z]) {\n                      cnt ++;\n                  } else {\n                      cnt = INF;\n                      break;\n                  }\n              }\n              if (cnt != INF) to[i].emplace_back(cnt);\n          }\n      }\n      return dfs(0, to);\n  }\n  int dfs(int u, std::vector<int> to[]) {\n      if (to[u].size() == 0) return 1;\n      if (f[u]) return f[u];\n      int rax = -1;\n      for (auto len : to[u]) {\n          rax = std::max(dfs(u + len, to), rax);\n          if (rax == n - u - 1) break;\n      }\n      return f[u] = rax + 1;\n  };\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2427. 公因子的数目 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n枚举所有公因子即可。\n\n# 代码\n\n\nclass solution {\npublic:\n    int commonfactors(int a, int b) {\n        int res = 0;\n        for (int i = 1; i <= std::min(a, b); i ++) {\n            if (a % i == 0 && b % i == 0) res ++;\n        }\n        return res;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2428. 沙漏的最大总和 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n暴力枚举左上角端点即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int maxsum(vector<vector<int>>& s) {\n      int res = 0;\n      int n = s.size(), m = s[0].size();\n      \n      for (int i = 0; i + 2 < n; i ++) {\n          for (int j = 0; j + 2 < m; j ++) {\n              int t = s[i][j] + s[i][j + 1] + s[i][j + 2] + s[i + 1][j + 1] + s[i + 2][j] + s[i + 2][j + 1] + s[i + 2][j + 2];\n              res = std::max(res, t);\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2429. 最小 xor - 力扣（leetcode）\n\n\n# 思路\n\n# 1.贪心 + 分类讨论 + 位运算\n\n首先我们令 z1 和 z2 分别表示 num1 和 num2 在二进制下的 1 的个数。\n\n接下来分三种情况讨论：\n\n 1. z1 = z2 此时我们直接令 x = num1，即 return num1 即可。\n 2. z1 < z2 这种情况下，对于我们要求的 x，根据贪心的思想我们要先让 x 在 num1 原本二进制位下为 1 的那些位赋值为 1，因为这样在 x 与 num1 异或后原本 num1 二进制下为 1 的那些位就为 0 了，接着多出来的 1，也就是 z2 - z1，我们对 x 从低位到高位将其二进制位仍为 0 的位依次赋值即可。\n 3. z1 > z2 在这种情况下，我们是要去尽可能削减 num1 的值，因此我们将 z2 个 1，依次从高位到低位看 num1 的每一位是否为 1，依次给 x 赋值来抵消即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int minimizexor(int num1, int num2) {\n      int z1 = __builtin_popcount(num1), z2 = __builtin_popcount(num2);\n      if (z1 == z2) return num1;\n      \n      if (z1 < z2) {\n          int dif = z2 - z1;\n          int res = 0;\n          for (int i = 0; i < 32; i ++) {\n              int z = num1 >> i & 1;\n              if (!z) {\n                  num1 ^= 1 << i;\n                  dif --;\n              }\n              if (!dif) return num1;\n          }\n      } else {\n          int res = 0;\n          for (int i = 31; ~i; i --) {\n              int z = num1 >> i & 1;\n              if (z) {\n                  res ^= 1 << i;\n                  z2 --;\n              }\n              if (!z2) return res;\n          }\n      }\n      return 1;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2430. 对字母串可执行的最大删除数 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. dp\n\n我们先令 表示对 可执行的最大删除数，我们枚举这一次的删除长度 ，如果满足 ，即满足删除条件，就可以很容易得到状态转移方程 。最后输出 即可，在最后输出的时候需要 + 1 是因为我们字符串删到最后一步，一定是整个字符串全部删除，即找不到满足可以删除条件的长度 。\n\n参考：线性 dp（python/java/c++/go） - 对字母串可执行的最大删除数 - 力扣（leetcode）\n\n# 代码\n\n\nclass solution {\npublic:\n  int deletestring(string s) {\n      int n = s.size();\n      std::vector dp(n + 1, std::vector<int> (n + 1));\n\n      for (int i = n - 1; ~i; i --) {\n          for (int j = n - 1; ~j; j --) {\n              if (s[i] == s[j]) {\n                  dp[i][j] = dp[i + 1][j + 1] + 1;\n              }\n          }\n      }\n\n      std::vector<int> f(n + 1);\n      for (int i = n - 1; ~i; i --) {\n          for (int j = 1; i + 2 * j - 1 < n; j ++) {\n              if (dp[i][i + j] >= j) {\n                  f[i] = std::max(f[i], f[i + j] + 1);\n              }\n          }\n      }\n\n      return f[0] + 1;\n  }\n};\n\n\n\n# 2.非正解 dfs (本题数据交水，正常情况过不了本题)\n\n暴搜所有的情况，加上记忆化 和 对特殊样例的特判即可，由于非正解就不细说了。。。\n\n# 代码\n\n\nclass solution {\npublic:\n  int n;\n  std::vector<int> f;\n  int deletestring(string s) {\n      n = s.size();\n      std::vector<int> to[n];\n      f.resize(n);\n      std::set<char> s;\n      for (auto x : s) \n          s.insert(x);\n      if (s.size() == 1) return n;\n      int inf = 1e9;\n      for (int i = 0; i < n; i ++) {\n          for (int z = 1; i + 2 * z - 1 < n && z <= n; z ++) {\n              int cnt = 0;\n              for (int k = 0; k < z; k ++) { \n                  if (s[i + k] == s[i + k + z]) {\n                      cnt ++;\n                  } else {\n                      cnt = inf;\n                      break;\n                  }\n              }\n              if (cnt != inf) to[i].emplace_back(cnt);\n          }\n      }\n      return dfs(0, to);\n  }\n  int dfs(int u, std::vector<int> to[]) {\n      if (to[u].size() == 0) return 1;\n      if (f[u]) return f[u];\n      int rax = -1;\n      for (auto len : to[u]) {\n          rax = std::max(dfs(u + len, to), rax);\n          if (rax == n - u - 1) break;\n      }\n      return f[u] = rax + 1;\n  };\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 88th Biweekly Contest",frontmatter:{title:"LeetCode 88th Biweekly Contest",date:"2022-10-07T18:21:10.000Z",permalink:"/pages/3ceb05/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/07.LeetCode%2088th%20Biweekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/07.LeetCode 88th Biweekly Contest.md",key:"v-db77d4ca",path:"/pages/3ceb05/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:47},{level:4,title:"1. 枚举 + STL $O(nlogn)$",slug:"_1-枚举-stl",normalizedTitle:'1. 枚举 + stl <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" viewbox="0 -750 4001 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mi" transform="translate(1752, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(2050, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(2535, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(3012, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3612, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:166},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:175},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:47},{level:4,title:"1. 暴力 + 性质 $O(n)$",slug:"_1-暴力-性质",normalizedTitle:'1. 暴力 + 性质 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:166},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:37},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:47},{level:4,title:"1.位运算 + 思维 $O(n)$",slug:"_1-位运算-思维",normalizedTitle:'1.位运算 + 思维 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:166},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:1461},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:8},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:47},{level:4,title:"1. 树状数组 $O(nlogm)$，$m$ 为数组的范围，即数值最大值。",slug:"_1-树状数组-为数组的范围-即数值最大值。",normalizedTitle:'1. 树状数组 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.681ex" height="2.262ex" viewbox="0 -750 4279 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mi" transform="translate(1752, 0)"><path data-c="6c" d="m117 59q117 26 142 26q179 26 205 131q211 151 215 152q217 153 225 153h229q238 153 241 153t246 151t248 144q247 138 245 128t234 90t214 43t183 6t137 -11q101 -11 70 11t38 85q38 97 39 102l104 360q167 615 167 623q167 626 166 628t162 632t157 634t149 635t141 636t132 637t122 637q112 637 109 637t101 638t95 641t94 647q94 649 96 661q101 680 107 682t179 688q194 689 213 690t243 693t254 694q266 694 266 686q266 675 193 386t118 83q118 81 118 75t117 65v59z"></path></g><g data-mml-node="mi" transform="translate(2050, 0)"><path data-c="6f" d="m201 -11q126 -11 80 38t34 156q34 221 64 279t146 380q222 441 301 441q333 441 341 440q354 437 367 433t402 417t438 387t464 338t476 268q476 161 390 75t201 -11zm121 120q121 70 147 48t206 26q250 26 289 58t351 142q360 163 374 216t388 308q388 352 370 375q346 405 306 405q243 405 195 347q158 303 140 230t121 120z"></path></g><g data-mml-node="mi" transform="translate(2535, 0)"><path data-c="67" d="m311 43q296 30 267 15t206 0q143 0 105 45t66 160q66 265 143 353t314 442q361 442 401 394l404 398q406 401 409 404t418 412t431 419t447 422q461 422 470 413t480 394q480 379 423 152t363 -80q345 -134 286 -169t151 -205q10 -205 10 -137q10 -111 28 -91t74 -71q89 -71 102 -80t116 -111q116 -121 114 -130t107 -144t99 -154t92 -162l90 -164h91q101 -167 151 -167q189 -167 211 -155q234 -144 254 -122t282 -75q288 -56 298 -13q311 35 311 43zm384 328l380 339q377 350 375 354t369 368t359 382t346 393t328 402t306 405q262 405 221 352q191 313 171 233t151 117q151 38 213 38q269 38 323 108l331 118l384 328z"></path></g><g data-mml-node="mi" transform="translate(3012, 0)"><path data-c="6d" d="m21 287q22 293 24 303t36 341t56 388t88 425t132 442t175 435t205 417t221 395t229 376l231 369q231 367 232 367l243 378q303 442 384 442q401 442 415 440t441 433t460 423t475 411t485 398t493 385t497 373t500 364t502 357l510 367q573 442 659 442q713 442 746 415t780 336q780 285 742 178t704 50q705 36 709 31t724 26q752 26 776 56t815 138q818 149 821 151t837 153q857 153 857 145q857 144 853 130q845 101 831 73t785 17t716 -10q669 -10 648 17t627 73q627 92 663 193t700 345q700 404 656 404h651q565 404 506 303l499 291l466 157q433 26 428 16q415 -11 385 -11q372 -11 364 -4t353 8t350 18q350 29 384 161l420 307q423 322 423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 181q151 335 151 342q154 357 154 369q154 405 129 405q107 405 92 377t69 316t57 280q55 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(3890, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>，<mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" viewbox="0 -442 878 453"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="6d" d="m21 287q22 293 24 303t36 341t56 388t88 425t132 442t175 435t205 417t221 395t229 376l231 369q231 367 232 367l243 378q303 442 384 442q401 442 415 440t441 433t460 423t475 411t485 398t493 385t497 373t500 364t502 357l510 367q573 442 659 442q713 442 746 415t780 336q780 285 742 178t704 50q705 36 709 31t724 26q752 26 776 56t815 138q818 149 821 151t837 153q857 153 857 145q857 144 853 130q845 101 831 73t785 17t716 -10q669 -10 648 17t627 73q627 92 663 193t700 345q700 404 656 404h651q565 404 506 303l499 291l466 157q433 26 428 16q415 -11 385 -11q372 -11 364 -4t353 8t350 18q350 29 384 161l420 307q423 322 423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 181q151 335 151 342q154 357 154 369q154 405 129 405q107 405 92 377t69 316t57 280q55 278 41 278h27q21 284 21 287z"></path></g></g></g></svg></mjx-container> 为数组的范围，即数值最大值。',charIndex:null},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:166}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 枚举 + STL $O(nlogn)$ 代码 B 题目 思路 1. 暴力 + 性质 $O(n)$ 代码 C 题目 思路 1.位运算 + 思维 $O(n)$ 代码 D 题目 思路 1. 树状数组 $O(nlogm)$，$m$ 为数组的范围，即数值最大值。 代码",content:"# A\n\n\n# 题目\n\n2423. 删除字符使频率相同 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举 + STL\n\n因为数据范围小，比赛时选择了比较好写的方法。\n\n枚举删除每一位的情况，然后统计此时各个字母出现的次数的数量，用 map 统计(用数组也可以)，用 set 来判断不同次数的个数是否为 1 即可。\n\n# 代码\n\n\n\n\n# B\n\n\n# 题目\n\n2424. 最长上传前缀 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 暴力 + 性质\n\n难点在于 upload() 的实现，但我们可以发现每次 upload 之后，其最长上传前缀并会减小，始终单调递增，因此维护一下最长上传前缀的结尾指针即可。\n\n# 代码\n\n\nclass LUPrefix {\nprivate:\n  std::vector<bool> a;\n  int res = 1;\npublic:\n  LUPrefix(int n) {\n      a.resize(n + 2);\n  }\n  \n  void upload(int video) {\n      a[video] = 1;\n      while (a[res]) {\n          res ++;\n      }\n  }\n  \n  int longest() {\n      return res - 1;\n  }\n};\n\n/**\n* Your LUPrefix object will be instantiated and called as such:\n* LUPrefix* obj = new LUPrefix(n);\n* obj->upload(video);\n* int param_2 = obj->longest();\n*/\n\n\n\n\n# C\n\n\n# 题目\n\n2425. 所有数对的异或和 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1.位运算 + 思维\n\n首先我们要知道异或的一个性质：两个相同的数字异或的结果 0。\n\n我们不难发现 nums1 中的每一个数字，在最终结果中会被异或 nums2.size() 次，而同理 nums2 中的每一个数字，在最终结果中会被异或 nums1.size() 次。而当一个数字进行偶数次异或之后，其值为 0，所以不会对结果产生影响；同时当一个数字进行了奇数次异或后，就相当于只进行了 1 次异或。因此如果 nums2.size() 为奇数时，我们将答案异或上 nums1 的每一个数字，而对 nums2 的每一位数字同理进行计算即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\n      int res = 0;\n      int n = nums1.size(), m = nums2.size();\n      if (m & 1) {\n          for (auto x : nums1) {\n              res ^= x;\n          }\n      }\n      if (n & 1) {\n          for (auto x : nums2) {\n              res ^= x;\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2426. 满足不等式的数对数目 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 树状数组 ， 为数组的范围，即数值最大值。\n\n首先我们一下转化题目给定的等式 nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff，可得 nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff，我们再令 a[i] = nums1[i] - nums2[i]，可得 a[i] <= a[j] + diff\n\n因此题目就转化成了，对于数组 a[i]，有多少个数对 (i, j) 满足 a[i] <= a[j] + diff 并且 0 <= i < j <= n - 1。\n\n此时我们可以从前往后看，也就是对于下标 i，在它后面有多少个数满足上述条件，如果这样暴力做复杂度是 的，显然会 TLE。\n\n因此，我们改为从后往前看，对于下标 j，在它前面有多少个数字满足 b[i] = a[i] - diff <= a[j]，此时我们可以很容易联想到 树状数组求逆序对。\n\n但本题还有个问题，那就是数据中有负数存在的可能，因此我们要给每一个数字加一个偏移量，将所有数字映射到一个正数上即可，或者用离散化树状数组求解。\n\n对于数字 nums1[i] - nums2[i] + diff 其值最小可以到 -3e4，因此我们需要给每一个 a[i] 加上 3e4 + 1。而此时数据的最大值可以达到 6e4 + 1，也就是原本的最大值 3e4 加上偏移量，所以树状数组我们则需要开至少 6e4 + 1 的空间。\n\n我们从前往后遍历，对于 a[i] 答案每次都加上树状数组 [1, a[i]] 的和，也就是在 a[i] 前已经有多少个满足条件的值出现了，维护完答案后我们再更新树状数组，在 a[i] - diff 的地方加 1 即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int t[60005];\n  int m = 6e4 + 5;\n\n  void add(int x, int c) {\n      for (int i = x; i <= m; i += i & -i) \n          t[i] += c;\n  }\n\n  int sum(int x) {\n      int res = 0;\n      for (int i = x; i; i -= i & -i) \n          res += t[i];\n      return res;\n  }\n  \n  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\n      int n = nums1.size();\n      std::vector<int> a(n);\n\n      for (int i = 0; i < n; i ++) {\n          a[i] = nums1[i] - nums2[i];\n      }\n      for (auto &x : a)\n          x += 3e4 + 1;\n\n      std::vector<int> b(n);\n      for (int i = 0; i < n; i ++) {\n          b[i] = a[i] - diff;\n      }\n      \n      long long res = 0;\n      for (int i = 0; i < n; i ++) {\n          res += sum(a[i]);\n          add(b[i], 1);\n      }\n\n      return res;\n  }\n};\n\n",normalizedContent:"# a\n\n\n# 题目\n\n2423. 删除字符使频率相同 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举 + stl\n\n因为数据范围小，比赛时选择了比较好写的方法。\n\n枚举删除每一位的情况，然后统计此时各个字母出现的次数的数量，用 map 统计(用数组也可以)，用 set 来判断不同次数的个数是否为 1 即可。\n\n# 代码\n\n\n\n\n# b\n\n\n# 题目\n\n2424. 最长上传前缀 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 暴力 + 性质\n\n难点在于 upload() 的实现，但我们可以发现每次 upload 之后，其最长上传前缀并会减小，始终单调递增，因此维护一下最长上传前缀的结尾指针即可。\n\n# 代码\n\n\nclass luprefix {\nprivate:\n  std::vector<bool> a;\n  int res = 1;\npublic:\n  luprefix(int n) {\n      a.resize(n + 2);\n  }\n  \n  void upload(int video) {\n      a[video] = 1;\n      while (a[res]) {\n          res ++;\n      }\n  }\n  \n  int longest() {\n      return res - 1;\n  }\n};\n\n/**\n* your luprefix object will be instantiated and called as such:\n* luprefix* obj = new luprefix(n);\n* obj->upload(video);\n* int param_2 = obj->longest();\n*/\n\n\n\n\n# c\n\n\n# 题目\n\n2425. 所有数对的异或和 - 力扣（leetcode）\n\n\n# 思路\n\n# 1.位运算 + 思维\n\n首先我们要知道异或的一个性质：两个相同的数字异或的结果 0。\n\n我们不难发现 nums1 中的每一个数字，在最终结果中会被异或 nums2.size() 次，而同理 nums2 中的每一个数字，在最终结果中会被异或 nums1.size() 次。而当一个数字进行偶数次异或之后，其值为 0，所以不会对结果产生影响；同时当一个数字进行了奇数次异或后，就相当于只进行了 1 次异或。因此如果 nums2.size() 为奇数时，我们将答案异或上 nums1 的每一个数字，而对 nums2 的每一位数字同理进行计算即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int xorallnums(vector<int>& nums1, vector<int>& nums2) {\n      int res = 0;\n      int n = nums1.size(), m = nums2.size();\n      if (m & 1) {\n          for (auto x : nums1) {\n              res ^= x;\n          }\n      }\n      if (n & 1) {\n          for (auto x : nums2) {\n              res ^= x;\n          }\n      }\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2426. 满足不等式的数对数目 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 树状数组 ， 为数组的范围，即数值最大值。\n\n首先我们一下转化题目给定的等式 nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff，可得 nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff，我们再令 a[i] = nums1[i] - nums2[i]，可得 a[i] <= a[j] + diff\n\n因此题目就转化成了，对于数组 a[i]，有多少个数对 (i, j) 满足 a[i] <= a[j] + diff 并且 0 <= i < j <= n - 1。\n\n此时我们可以从前往后看，也就是对于下标 i，在它后面有多少个数满足上述条件，如果这样暴力做复杂度是 的，显然会 tle。\n\n因此，我们改为从后往前看，对于下标 j，在它前面有多少个数字满足 b[i] = a[i] - diff <= a[j]，此时我们可以很容易联想到 树状数组求逆序对。\n\n但本题还有个问题，那就是数据中有负数存在的可能，因此我们要给每一个数字加一个偏移量，将所有数字映射到一个正数上即可，或者用离散化树状数组求解。\n\n对于数字 nums1[i] - nums2[i] + diff 其值最小可以到 -3e4，因此我们需要给每一个 a[i] 加上 3e4 + 1。而此时数据的最大值可以达到 6e4 + 1，也就是原本的最大值 3e4 加上偏移量，所以树状数组我们则需要开至少 6e4 + 1 的空间。\n\n我们从前往后遍历，对于 a[i] 答案每次都加上树状数组 [1, a[i]] 的和，也就是在 a[i] 前已经有多少个满足条件的值出现了，维护完答案后我们再更新树状数组，在 a[i] - diff 的地方加 1 即可。\n\n# 代码\n\n\nclass solution {\npublic:\n  int t[60005];\n  int m = 6e4 + 5;\n\n  void add(int x, int c) {\n      for (int i = x; i <= m; i += i & -i) \n          t[i] += c;\n  }\n\n  int sum(int x) {\n      int res = 0;\n      for (int i = x; i; i -= i & -i) \n          res += t[i];\n      return res;\n  }\n  \n  long long numberofpairs(vector<int>& nums1, vector<int>& nums2, int diff) {\n      int n = nums1.size();\n      std::vector<int> a(n);\n\n      for (int i = 0; i < n; i ++) {\n          a[i] = nums1[i] - nums2[i];\n      }\n      for (auto &x : a)\n          x += 3e4 + 1;\n\n      std::vector<int> b(n);\n      for (int i = 0; i < n; i ++) {\n          b[i] = a[i] - diff;\n      }\n      \n      long long res = 0;\n      for (int i = 0; i < n; i ++) {\n          res += sum(a[i]);\n          add(b[i], 1);\n      }\n\n      return res;\n  }\n};\n\n",charsets:{cjk:!0}},{title:"LeetCode 321th Weekly Contest",frontmatter:{title:"LeetCode 321th Weekly Contest",date:"2022-11-28T16:56:39.000Z",permalink:"/pages/445c9b/",tags:["Competitive Programming","LeetCode周赛","Contests"]},regularPath:"/01.Competitive%20Programming/01.LeetCode%E5%91%A8%E8%B5%9B/01.Contests/08.LeetCode%20321th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/01.LeetCode周赛/01.Contests/08.LeetCode 321th Weekly Contest.md",key:"v-74aa51d7",path:"/pages/445c9b/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:44},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:50},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:86},{level:4,title:"1. 枚举 $O(n)$",slug:"_1-枚举",normalizedTitle:'1. 枚举 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:118},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:364},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:50},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:86},{level:4,title:"1. 双指针 + 遍历一次 $O(n)$",slug:"_1-双指针-遍历一次",normalizedTitle:'1. 双指针 + 遍历一次 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:118},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:76},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:50},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:86},{level:4,title:"1.后缀最大值 $O(n)$",slug:"_1-后缀最大值",normalizedTitle:'1.后缀最大值 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:118},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:1020},{level:3,title:"题目",slug:"题目-4",normalizedTitle:"题目",charIndex:50},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:86},{level:4,title:"1. 等价转换 + 哈希表 $O(n)$",slug:"_1-等价转换-哈希表",normalizedTitle:'1. 等价转换 + 哈希表 <mjx-container class="mathjax" jax="svg"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" viewbox="0 -750 2141 1000"><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4f" d="m740 435q740 320 676 213t511 42t304 -22q207 -22 138 35t51 201q50 209 50 244q50 346 98 438t227 601q351 704 476 704q514 704 524 703q621 689 680 617t740 435zm637 476q637 565 591 615t476 665q396 665 322 605q242 542 200 428t157 216q157 126 200 73t314 19q404 19 485 98t608 313q637 408 637 476z"></path></g><g data-mml-node="mo" transform="translate(763, 0)"><path data-c="28" d="m94 250q94 319 104 381t127 488t164 576t202 643t244 695t277 729t302 750h315h319q333 750 333 741q333 738 316 720t275 667t226 581t184 443t167 250t184 58t225 -81t274 -167t316 -220t333 -241q333 -250 318 -250h315h302l274 -226q180 -141 137 -14t94 250z"></path></g><g data-mml-node="mi" transform="translate(1152, 0)"><path data-c="6e" d="m21 287q22 293 24 303t36 341t56 388t89 425t135 442q171 442 195 424t225 390t231 369q231 367 232 367l243 378q304 442 382 442q436 442 469 415t503 336t465 179t427 52q427 26 444 26q450 26 453 27q482 32 505 65t540 145q542 153 560 153q580 153 580 145q580 144 576 130q568 101 554 73t508 17t439 -10q392 -10 371 17t350 73q350 92 386 193t423 345q423 404 379 404h374q288 404 229 303l222 291l189 157q156 26 151 16q138 -11 108 -11q95 -11 87 -5t76 7t74 17q74 30 112 180t152 343q153 348 153 366q153 405 129 405q91 405 66 305q60 285 60 284q58 278 41 278h27q21 284 21 287z"></path></g><g data-mml-node="mo" transform="translate(1752, 0)"><path data-c="29" d="m60 749l64 750q69 750 74 750h86l114 726q208 641 251 514t294 250q294 182 284 119t261 12t224 -76t186 -143t145 -194t113 -227t90 -246q87 -249 86 -250h74q66 -250 63 -250t58 -247t55 -238q56 -237 66 -225q221 -64 221 250t66 725q56 737 55 738q55 746 60 749z"></path></g></g></g></svg></mjx-container>',charIndex:null},{level:4,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:118},{level:4,title:"代码",slug:"代码-5",normalizedTitle:"代码",charIndex:118}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题目 思路 1. 枚举 $O(n)$ 代码 B 题目 思路 1. 双指针 + 遍历一次 $O(n)$ 代码 C 题目 思路 1.后缀最大值 $O(n)$ 代码 D 题目 思路 1. 等价转换 + 哈希表 $O(n)$ 代码 代码",content:"好久没打周赛了，这次比较简单，纯纯手速场，写的基本都是暴力，可能不是最优写法。\n\n\n# A\n\n\n# 题目\n\n2485. 找出中枢整数 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 枚举\n\n利用等差数列求和公式枚举即可。\n\n# 代码\n\n\nclass Solution {\npublic:\n    int pivotInteger(int n) {\n        for (int i = 1; i<= n; i++) {\n            if ((1 + i) * i / 2 == (i + n) * (n - i + 1) / 2) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\n\n# B\n\n\n# 题目\n\n2486. 追加字符以获得子序列 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 双指针 + 遍历一次\n\n只需要找到字符串 t 在 字符串 s 的子序列中存在的最长前缀即可，因此我们利用双指针分别指向两个数组，看看 s 能满足的 t 的最长前缀，最后答案是 t 的长度减去能满足的最长前缀的长度。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int appendCharacters(string s, string t) {\n      int i = 0, j = 0;\n      int n = s.size(), m = t.size();\n      for (; i < n; i++) {\n          if (s[i] == t[j]) {\n              j++;\n          }\n      }\n      return m - j;\n  }\n};\n\n\n\n\n# C\n\n\n# 题目\n\n2487. 从链表中移除节点 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1.后缀最大值\n\n比赛时写的代码，可能有点繁杂，也不是最优的，不过想法应该是比较简单的。\n\n先用数组 a 将链表存起来，然后得到后缀最大值数组 sufmax，我们要保留的元素满足其右侧不存在一个比他大的元素，所以对于下标 i，如果 a[i] == sufmax[i]，我们就保留下标为 i 的元素，最后用链表存起来即可\n\n# 代码\n\n\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n  ListNode* removeNodes(ListNode* head) {\n      std::vector<int> a;\n      while (head) {\n          a.emplace_back(head->val);\n          head = head->next;\n      }\n      int n = a.size();\n      std::vector<int> sufmax(n);\n      sufmax.back() = a.back();\n      for (int i = n - 2; ~i; i--) {\n          sufmax[i] = std::max(a[i], sufmax[i + 1]);\n      }\n      auto res = new ListNode();\n      auto t = res;\n      for (int i = 0; i < n; i++) {\n          if (sufmax[i] == a[i]) {\n              t->val = a[i];\n              t->next = new ListNode();\n              t = t->next;\n          }\n      }\n      auto tt = res;\n      while (tt->next != t) {\n          tt = tt->next;\n      }\n      tt->next = nullptr;\n      return res;\n  }\n};\n\n\n\n\n# D\n\n\n# 题目\n\n2488. 统计中位数为 K 的子数组 - 力扣（LeetCode）\n\n\n# 思路\n\n# 1. 等价转换 + 哈希表\n\n赛时的写法太烦了，不过整体思路差不多，数组的每个元素进行转换，如果大于 k 则为 1，小于 k 则为 -1，等于 k 则为 0。\n\n那么我们就可以将问题转化寻找满足条件的子数组个数，条件是如果子数组长度为奇数，则子数组和为 0，如果长度为 偶数，则子数组和为 1。\n\n我的写法因为 unordered_map 不支持复杂的映射，所以只能用 map 来实现哈希表，整体时间复杂度会因为排序多一个\n\n# 代码\n\n\nclass Solution {\npublic:\n  int countSubarrays(vector<int>& nums, int k) {\n      std::map<std::pair<int, int>, int> pos; \n      for (auto &x : nums) {\n          if (x > k) x = 1;\n          else if (x == k) x = 0;\n          else x = -1;\n      }\n      \n      int n = nums.size();\n      std::vector<int> psum(n);\n      psum[0] = nums[0];\n      for (int i = 1; i < n; i++) {\n          psum[i] = psum[i - 1] + nums[i];\n      }\n      int res = 0;\n      for (int i = 0; i < n; i++) {\n          int len = i + 1;\n          int tozero = psum[i];\n          int toone = psum[i] - 1;\n          if (((len & 1) && psum[i] == 0) || ((len % 2 == 0) && psum[i] == 1)) {\n              res++;\n          }\n          res += pos[{tozero, (len & 1) ^ 1}];\n          res += pos[{toone, (len & 1)}];\n          \n          pos[{psum[i], (i + 1) & 1}]++;\n      }\n      return res;\n  }\n};\n\n\n\n这里贴一下灵神的代码，比我的会高效简洁很多(%%%%)\n\n等价转换（Python/Java/C++/Go） - 统计中位数为 K 的子数组 - 力扣（LeetCode）\n\n很容易发现子数组一定是包含 k 的，因此可以从 k 的位置出发，向左向右进行延伸，这样更高效，而且更容易去判断长度的奇偶性，cnt[i] 如果 i 是 奇数，则一定是朝一个方向衍生了奇数个数字，偶数同理，（因为在这里排除了 k 的情况，所以只会 +1 -1）那么向一边衍生 cnt[i] 位，向另一边衍生 cnt[i] 位，加上中间的 k，数字个数一定是 2 * i + 1 个，也就是奇数，当另一边衍生 cnt[i + 1] 位时，则一定是偶数长度。\n\n# 代码\n\n\nclass Solution {\npublic:\n  int countSubarrays(vector<int> &nums, int k) {\n      int pos = find(nums.begin(), nums.end(), k) - nums.begin(), n = nums.size();\n      unordered_map<int, int> cnt;\n      cnt[0] = 1; // i=pos 的时候 c 是 0，直接记到 cnt 中，这样下面不是大于就是小于\n      for (int i = pos + 1, c = 0; i < n; ++i) {\n          c += nums[i] > k ? 1 : -1;\n          ++cnt[c];\n      }\n\n      int ans = cnt[0] + cnt[1]; // i=pos 的时候 c 是 0，直接加到答案中，这样下面不是大于就是小于\n      for (int i = pos - 1, c = 0; i >= 0; --i) {\n          c += nums[i] < k ? 1 : -1;\n          ans += cnt[c] + cnt[c + 1];\n      }\n      return ans;\n  }\n};\n\n",normalizedContent:"好久没打周赛了，这次比较简单，纯纯手速场，写的基本都是暴力，可能不是最优写法。\n\n\n# a\n\n\n# 题目\n\n2485. 找出中枢整数 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 枚举\n\n利用等差数列求和公式枚举即可。\n\n# 代码\n\n\nclass solution {\npublic:\n    int pivotinteger(int n) {\n        for (int i = 1; i<= n; i++) {\n            if ((1 + i) * i / 2 == (i + n) * (n - i + 1) / 2) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\n\n# b\n\n\n# 题目\n\n2486. 追加字符以获得子序列 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 双指针 + 遍历一次\n\n只需要找到字符串 t 在 字符串 s 的子序列中存在的最长前缀即可，因此我们利用双指针分别指向两个数组，看看 s 能满足的 t 的最长前缀，最后答案是 t 的长度减去能满足的最长前缀的长度。\n\n# 代码\n\n\nclass solution {\npublic:\n  int appendcharacters(string s, string t) {\n      int i = 0, j = 0;\n      int n = s.size(), m = t.size();\n      for (; i < n; i++) {\n          if (s[i] == t[j]) {\n              j++;\n          }\n      }\n      return m - j;\n  }\n};\n\n\n\n\n# c\n\n\n# 题目\n\n2487. 从链表中移除节点 - 力扣（leetcode）\n\n\n# 思路\n\n# 1.后缀最大值\n\n比赛时写的代码，可能有点繁杂，也不是最优的，不过想法应该是比较简单的。\n\n先用数组 a 将链表存起来，然后得到后缀最大值数组 sufmax，我们要保留的元素满足其右侧不存在一个比他大的元素，所以对于下标 i，如果 a[i] == sufmax[i]，我们就保留下标为 i 的元素，最后用链表存起来即可\n\n# 代码\n\n\n/**\n* definition for singly-linked list.\n* struct listnode {\n*     int val;\n*     listnode *next;\n*     listnode() : val(0), next(nullptr) {}\n*     listnode(int x) : val(x), next(nullptr) {}\n*     listnode(int x, listnode *next) : val(x), next(next) {}\n* };\n*/\nclass solution {\npublic:\n  listnode* removenodes(listnode* head) {\n      std::vector<int> a;\n      while (head) {\n          a.emplace_back(head->val);\n          head = head->next;\n      }\n      int n = a.size();\n      std::vector<int> sufmax(n);\n      sufmax.back() = a.back();\n      for (int i = n - 2; ~i; i--) {\n          sufmax[i] = std::max(a[i], sufmax[i + 1]);\n      }\n      auto res = new listnode();\n      auto t = res;\n      for (int i = 0; i < n; i++) {\n          if (sufmax[i] == a[i]) {\n              t->val = a[i];\n              t->next = new listnode();\n              t = t->next;\n          }\n      }\n      auto tt = res;\n      while (tt->next != t) {\n          tt = tt->next;\n      }\n      tt->next = nullptr;\n      return res;\n  }\n};\n\n\n\n\n# d\n\n\n# 题目\n\n2488. 统计中位数为 k 的子数组 - 力扣（leetcode）\n\n\n# 思路\n\n# 1. 等价转换 + 哈希表\n\n赛时的写法太烦了，不过整体思路差不多，数组的每个元素进行转换，如果大于 k 则为 1，小于 k 则为 -1，等于 k 则为 0。\n\n那么我们就可以将问题转化寻找满足条件的子数组个数，条件是如果子数组长度为奇数，则子数组和为 0，如果长度为 偶数，则子数组和为 1。\n\n我的写法因为 unordered_map 不支持复杂的映射，所以只能用 map 来实现哈希表，整体时间复杂度会因为排序多一个\n\n# 代码\n\n\nclass solution {\npublic:\n  int countsubarrays(vector<int>& nums, int k) {\n      std::map<std::pair<int, int>, int> pos; \n      for (auto &x : nums) {\n          if (x > k) x = 1;\n          else if (x == k) x = 0;\n          else x = -1;\n      }\n      \n      int n = nums.size();\n      std::vector<int> psum(n);\n      psum[0] = nums[0];\n      for (int i = 1; i < n; i++) {\n          psum[i] = psum[i - 1] + nums[i];\n      }\n      int res = 0;\n      for (int i = 0; i < n; i++) {\n          int len = i + 1;\n          int tozero = psum[i];\n          int toone = psum[i] - 1;\n          if (((len & 1) && psum[i] == 0) || ((len % 2 == 0) && psum[i] == 1)) {\n              res++;\n          }\n          res += pos[{tozero, (len & 1) ^ 1}];\n          res += pos[{toone, (len & 1)}];\n          \n          pos[{psum[i], (i + 1) & 1}]++;\n      }\n      return res;\n  }\n};\n\n\n\n这里贴一下灵神的代码，比我的会高效简洁很多(%%%%)\n\n等价转换（python/java/c++/go） - 统计中位数为 k 的子数组 - 力扣（leetcode）\n\n很容易发现子数组一定是包含 k 的，因此可以从 k 的位置出发，向左向右进行延伸，这样更高效，而且更容易去判断长度的奇偶性，cnt[i] 如果 i 是 奇数，则一定是朝一个方向衍生了奇数个数字，偶数同理，（因为在这里排除了 k 的情况，所以只会 +1 -1）那么向一边衍生 cnt[i] 位，向另一边衍生 cnt[i] 位，加上中间的 k，数字个数一定是 2 * i + 1 个，也就是奇数，当另一边衍生 cnt[i + 1] 位时，则一定是偶数长度。\n\n# 代码\n\n\nclass solution {\npublic:\n  int countsubarrays(vector<int> &nums, int k) {\n      int pos = find(nums.begin(), nums.end(), k) - nums.begin(), n = nums.size();\n      unordered_map<int, int> cnt;\n      cnt[0] = 1; // i=pos 的时候 c 是 0，直接记到 cnt 中，这样下面不是大于就是小于\n      for (int i = pos + 1, c = 0; i < n; ++i) {\n          c += nums[i] > k ? 1 : -1;\n          ++cnt[c];\n      }\n\n      int ans = cnt[0] + cnt[1]; // i=pos 的时候 c 是 0，直接加到答案中，这样下面不是大于就是小于\n      for (int i = pos - 1, c = 0; i >= 0; --i) {\n          c += nums[i] < k ? 1 : -1;\n          ans += cnt[c] + cnt[c + 1];\n      }\n      return ans;\n  }\n};\n\n",charsets:{cjk:!0}},{title:"Acwing 64th Weekly Contest",frontmatter:{title:"Acwing 64th Weekly Contest",date:"2022-08-14T17:12:15.000Z",permalink:"/pages/29a8bf/",tags:["Competitive Programming","Acwing周赛","Contests"]},regularPath:"/01.Competitive%20Programming/02.Acwing%E5%91%A8%E8%B5%9B/01.Contests/01.Acwing%2064th%20Weekly%20Contest.html",relativePath:"01.Competitive Programming/02.Acwing周赛/01.Contests/01.Acwing 64th Weekly Contest.md",key:"v-1211effb",path:"/pages/29a8bf/",headers:[{level:2,title:"A",slug:"a",normalizedTitle:"a",charIndex:2},{level:3,title:"题意",slug:"题意",normalizedTitle:"题意",charIndex:8},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:24},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:36},{level:2,title:"B",slug:"b",normalizedTitle:"b",charIndex:18},{level:3,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:262},{level:3,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:24},{level:3,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:36},{level:2,title:"C",slug:"c",normalizedTitle:"c",charIndex:660},{level:3,title:"题目",slug:"题目-2",normalizedTitle:"题目",charIndex:262},{level:3,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:24},{level:3,title:"代码",slug:"代码-3",normalizedTitle:"代码",charIndex:36},{level:2,title:"D",slug:"d",normalizedTitle:"d",charIndex:1430},{level:3,title:"题目",slug:"题目-3",normalizedTitle:"题目",charIndex:262},{level:3,title:"思路",slug:"思路-4",normalizedTitle:"思路",charIndex:24},{level:3,title:"代码",slug:"代码-4",normalizedTitle:"代码",charIndex:36}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"A 题意 思路 代码 B 题目 思路 代码 C 题目 思路 代码 D 题目 思路 代码",content:'# A\n\n\n# 题意\n\n求 A + B\n\n\n# 思路\n\n测试题\n\n\n# 代码\n\n\n  #include <bits/stdc++.h>\n\n  using ll = long long;\n\n  int main() {\t\n  \tstd::ios::sync_with_stdio(0); \n  \tstd::cin.tie(0);\n\n  \tll a, b;\n  \tstd::cin >> a >> b;\n  \tstd::cout << a + b << "\\n";\n\n  \treturn 0;\n  }\t\n\n\n\n\n# B\n\n\n# 题目\n\n4506. 三国语言 - AcWing题库\n\n\n# 思路\n\n只需要判断输入字符串的最后一个字符即可。\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n;\n  std::cin >> n;\n  while (n --) {\n  \tstd::string s;\n  \tstd::cin >> s;\n  \tif (s.back() == \'u\') puts("JAPANESE");\n  \telse if (s.back() == \'o\') puts("FILIPINO");\n  \telse puts("KOREAN");\n  }\n\n  return 0;\n}\t\n\n\n\n\n# C\n\n\n# 题目\n\n4507. 子数组异或和 - AcWing题库\n\n\n# 思路\n\n * 补充一下异或的性质：对任意数字 来说，\n\n对于符合条件的子数组满足：所有元素的异或和为 0 并且 数组长度为偶数。\n\n在这里我们采用前缀异或和的思路，输入数据时维护一个数组 ，对于 表示异或前缀和为，并且下标为偶数的个数。\n\n例如某个奇数下标的前缀异或和为，我们只需要知道将答案加上 即可。\n\n需要注意的是，对于前缀异或和为 0 的偶数项，需要额外加上 1，也可以建立完 数组后进行初始化 。\n\nPS：本题需要开long long\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\nconstexpr int N = 1 << 21 + 5;\nint mp[N][2];\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n;std::cin >> n;\n  std::vector<int> a(n + 1);\n  std::vector<int> suf(n + 1);\n  ll res = 0;\n  for (int i = 1; i <= n; i ++) {\n      std::cin >> a[i];\n      suf[i] = a[i] ^ suf[i - 1];\n      int s = i & 1;\n      res += mp[suf[i]][s] + (suf[i] == 0 && !s);\n      mp[suf[i]][s] ++;\n  }\n  std::cout << res <<"\\n";\n  \n  return 0;\n}\t\n\n\n\n\n# D\n\n\n# 题目\n\n4508. 移动的点 - AcWing题库\n\n\n# 思路\n\n本题我们考虑点之间的相对速度。\n\n图中黑线是两点的运动轨迹，红线是斜率为 a 的直线。很显然的可以看出，两点之间的连线始终与红线平行，因此如果两点能够相遇，则一定满足两点纵轴速度差与横轴速度差之比为 a，即\n\n因此我们对于每个点 只需要计算 ，并且用哈希表维护数量。同时在计算答案是要减去相对静止的两个点，可以发现当两点的速度分量都相同时，两点相对静止，我们也用哈希表进行维护。\n\n最后答案记得乘二，因为两个点发生相遇时，它们的 值都会增加。\n\nPS：本题需要开long long\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n, a, b;\n  std::map<ll, int> cnt;\n  std::map<std::pair<int, int>, int> para;\n  ll res = 0;\n  std::cin >> n >> a >> b;\n  for (int i = 0; i < n; i ++) {\n  \tint x, vx, vy;\n  \tstd::cin >> x >> vx >> vy;\n  \tint t = a * vx - vy;\n  \tres += cnt[t] - para[{vx, vy}];\n  \tcnt[t] ++, para[{vx, vy}] ++;\n  }\n  std::cout << res * 2 << "\\n";\n\n  return 0;\n}\t\n\n',normalizedContent:'# a\n\n\n# 题意\n\n求 a + b\n\n\n# 思路\n\n测试题\n\n\n# 代码\n\n\n  #include <bits/stdc++.h>\n\n  using ll = long long;\n\n  int main() {\t\n  \tstd::ios::sync_with_stdio(0); \n  \tstd::cin.tie(0);\n\n  \tll a, b;\n  \tstd::cin >> a >> b;\n  \tstd::cout << a + b << "\\n";\n\n  \treturn 0;\n  }\t\n\n\n\n\n# b\n\n\n# 题目\n\n4506. 三国语言 - acwing题库\n\n\n# 思路\n\n只需要判断输入字符串的最后一个字符即可。\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n;\n  std::cin >> n;\n  while (n --) {\n  \tstd::string s;\n  \tstd::cin >> s;\n  \tif (s.back() == \'u\') puts("japanese");\n  \telse if (s.back() == \'o\') puts("filipino");\n  \telse puts("korean");\n  }\n\n  return 0;\n}\t\n\n\n\n\n# c\n\n\n# 题目\n\n4507. 子数组异或和 - acwing题库\n\n\n# 思路\n\n * 补充一下异或的性质：对任意数字 来说，\n\n对于符合条件的子数组满足：所有元素的异或和为 0 并且 数组长度为偶数。\n\n在这里我们采用前缀异或和的思路，输入数据时维护一个数组 ，对于 表示异或前缀和为，并且下标为偶数的个数。\n\n例如某个奇数下标的前缀异或和为，我们只需要知道将答案加上 即可。\n\n需要注意的是，对于前缀异或和为 0 的偶数项，需要额外加上 1，也可以建立完 数组后进行初始化 。\n\nps：本题需要开long long\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\nconstexpr int n = 1 << 21 + 5;\nint mp[n][2];\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n;std::cin >> n;\n  std::vector<int> a(n + 1);\n  std::vector<int> suf(n + 1);\n  ll res = 0;\n  for (int i = 1; i <= n; i ++) {\n      std::cin >> a[i];\n      suf[i] = a[i] ^ suf[i - 1];\n      int s = i & 1;\n      res += mp[suf[i]][s] + (suf[i] == 0 && !s);\n      mp[suf[i]][s] ++;\n  }\n  std::cout << res <<"\\n";\n  \n  return 0;\n}\t\n\n\n\n\n# d\n\n\n# 题目\n\n4508. 移动的点 - acwing题库\n\n\n# 思路\n\n本题我们考虑点之间的相对速度。\n\n图中黑线是两点的运动轨迹，红线是斜率为 a 的直线。很显然的可以看出，两点之间的连线始终与红线平行，因此如果两点能够相遇，则一定满足两点纵轴速度差与横轴速度差之比为 a，即\n\n因此我们对于每个点 只需要计算 ，并且用哈希表维护数量。同时在计算答案是要减去相对静止的两个点，可以发现当两点的速度分量都相同时，两点相对静止，我们也用哈希表进行维护。\n\n最后答案记得乘二，因为两个点发生相遇时，它们的 值都会增加。\n\nps：本题需要开long long\n\n\n# 代码\n\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\n\nint main() {\t\n  std::ios::sync_with_stdio(0); \n  std::cin.tie(0);\n\n  int n, a, b;\n  std::map<ll, int> cnt;\n  std::map<std::pair<int, int>, int> para;\n  ll res = 0;\n  std::cin >> n >> a >> b;\n  for (int i = 0; i < n; i ++) {\n  \tint x, vx, vy;\n  \tstd::cin >> x >> vx >> vy;\n  \tint t = a * vx - vy;\n  \tres += cnt[t] - para[{vx, vy}];\n  \tcnt[t] ++, para[{vx, vy}] ++;\n  }\n  std::cout << res * 2 << "\\n";\n\n  return 0;\n}\t\n\n',charsets:{cjk:!0}},{title:"洛谷P6510",frontmatter:{title:"洛谷P6510",date:"2023-01-14T16:12:53.000Z",permalink:"/pages/bdac31/",tags:["Competitive Programming","题解"]},regularPath:"/01.Competitive%20Programming/04.%E9%A2%98%E8%A7%A3/01.%E6%B4%9B%E8%B0%B7P6510.html",relativePath:"01.Competitive Programming/04.题解/01.洛谷P6510.md",key:"v-0850134b",path:"/pages/bdac31/",headers:[{level:3,title:"思路:",slug:"思路",normalizedTitle:"思路:",charIndex:15},{level:3,title:"Code:",slug:"code",normalizedTitle:"code:",charIndex:366},{level:3,title:"PS",slug:"ps",normalizedTitle:"ps",charIndex:1048}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"思路: Code: PS",content:'题目链接：P6510\n\n\n# 思路:\n\n首先将题意转化，对于给定序列，求出最长的连续子序列，满足左端点 A 是子序列的最小值，右端点 B 是子序列最大值，同时左端点与右端点不同，子序列中间的数字也不能与端点相同。\n\n考虑枚举 B，确定 A。\n\n对于每一个 B，显然 A 一定在 B 左边第一个大于等于右端点值的右边，否则从 A 到 B 中一定有一个数字大于等于 B，显然不满足题意，因此我们可以用单调栈 lmax 维护每个下标 i 左边第一个大于等于 h[i] 的值的下标，我们令这个下标为 x。\n\n另外序列中的每个值一定小于右端点的值，所以我们可以再用一个单调栈 lmin 维护每个下标 i 左边第一个小于 h[i]的值的下标，此时单调栈的中所有元素都一定小于右端点的值。我们可以通过二分，来找到第一个大于 x 的下标。\n\n\n# Code:\n\n\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\t\n\tstd::ios::sync_with_stdio(0); \n\tstd::cin.tie(0);\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int> h(n);\n\tstd::vector<int> lmin, lmax;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> h[i];\n\t\twhile (!lmin.empty() && h[lmin.back()] >= h[i]) \n\t\t\tlmin.pop_back();\n\t\twhile (!lmax.empty() && h[lmax.back()] < h[i])\n\t\t\tlmax.pop_back();\n\n\t\tint k = (lmax.empty()) ? 0 : std::upper_bound(lmin.begin(), lmin.end(), lmax.back()) - lmin.begin();\n\t\tif (k != lmin.size()) {\n\t\t\tans = std::max(ans, i - lmin[k] + 1);\n\t\t}\n\t\tlmin.emplace_back(i);\n\t\tlmax.emplace_back(i);\n\t}\n\t\n\tstd::cout << ans << "\\n";\n\n\treturn 0;\n}\t\n\n\n\n\n# PS\n\n 1. 之所以单调栈 lmin 不能直接全部作为子序列，是因为此时 lmin 中的每个下标未必连续，中间空着的数字是被弹出去的数字，被弹出去的数字无法保证满足条件。\n 2. 如果 lmax 为空，则说明此时不存在大于等于 h[i] 的数字，故直接此时单调栈 lmin 所有数字都可以作为子序列的一部分。\n 3. 这里用的是 STL 实现单调栈，也可以用数组来模拟单调栈。',normalizedContent:'题目链接：p6510\n\n\n# 思路:\n\n首先将题意转化，对于给定序列，求出最长的连续子序列，满足左端点 a 是子序列的最小值，右端点 b 是子序列最大值，同时左端点与右端点不同，子序列中间的数字也不能与端点相同。\n\n考虑枚举 b，确定 a。\n\n对于每一个 b，显然 a 一定在 b 左边第一个大于等于右端点值的右边，否则从 a 到 b 中一定有一个数字大于等于 b，显然不满足题意，因此我们可以用单调栈 lmax 维护每个下标 i 左边第一个大于等于 h[i] 的值的下标，我们令这个下标为 x。\n\n另外序列中的每个值一定小于右端点的值，所以我们可以再用一个单调栈 lmin 维护每个下标 i 左边第一个小于 h[i]的值的下标，此时单调栈的中所有元素都一定小于右端点的值。我们可以通过二分，来找到第一个大于 x 的下标。\n\n\n# code:\n\n\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\t\n\tstd::ios::sync_with_stdio(0); \n\tstd::cin.tie(0);\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int> h(n);\n\tstd::vector<int> lmin, lmax;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> h[i];\n\t\twhile (!lmin.empty() && h[lmin.back()] >= h[i]) \n\t\t\tlmin.pop_back();\n\t\twhile (!lmax.empty() && h[lmax.back()] < h[i])\n\t\t\tlmax.pop_back();\n\n\t\tint k = (lmax.empty()) ? 0 : std::upper_bound(lmin.begin(), lmin.end(), lmax.back()) - lmin.begin();\n\t\tif (k != lmin.size()) {\n\t\t\tans = std::max(ans, i - lmin[k] + 1);\n\t\t}\n\t\tlmin.emplace_back(i);\n\t\tlmax.emplace_back(i);\n\t}\n\t\n\tstd::cout << ans << "\\n";\n\n\treturn 0;\n}\t\n\n\n\n\n# ps\n\n 1. 之所以单调栈 lmin 不能直接全部作为子序列，是因为此时 lmin 中的每个下标未必连续，中间空着的数字是被弹出去的数字，被弹出去的数字无法保证满足条件。\n 2. 如果 lmax 为空，则说明此时不存在大于等于 h[i] 的数字，故直接此时单调栈 lmin 所有数字都可以作为子序列的一部分。\n 3. 这里用的是 stl 实现单调栈，也可以用数组来模拟单调栈。',charsets:{cjk:!0}},{title:"ABC283_F",frontmatter:{title:"ABC283_F",date:"2023-02-20T08:22:25.000Z",permalink:"/pages/285600/",tags:["Competitive Programming","题解"]},regularPath:"/01.Competitive%20Programming/04.%E9%A2%98%E8%A7%A3/02.ABC283_F.html",relativePath:"01.Competitive Programming/04.题解/02.ABC283_F.md",key:"v-ca59abba",path:"/pages/285600/",headers:[{level:3,title:"题目大意：",slug:"题目大意",normalizedTitle:"题目大意：",charIndex:18},{level:3,title:"思路：",slug:"思路",normalizedTitle:"思路：",charIndex:50},{level:3,title:"Code：",slug:"code",normalizedTitle:"code：",charIndex:512}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"题目大意： 思路： Code：",content:'题目链接：ABC283_F\n\n\n# 题目大意：\n\n给定一个长度为 的排列 ，对每一个 求解\n\n\n# 思路：\n\n看到两个绝对值，我们不妨将绝对值拆除，分为四种情况来讨论。\n\n 1. ，\n    \n 2. ，\n    \n 3. ，\n    \n 4. ，\n    \n\n我们先考虑 的两种情况:\n\n\n * 如果 ，我们可以给 建立权值树状数组， 节点赋值为 。\n   我们从小到大遍历 i，可以保证之前出现过的项中 j 一定小于 i，然后遍历的过程中更新树状数组，如果我们用树状数组求 的前缀最大值，如此一来一定可以保证得到的最大值满足\n * 如果 我们与第一种情况处理方式类似，但是有一点不同的是我们此时要找到的是大于 的 ，因此此时应该在树状数组求 的后缀最大值。一种可行的方案是我们求前缀值的函数由从大到小遍历改为从小到大遍历。另一种更好的方法是，我们将树状数组下标 映射成 ，也就是相当于将树状数组整体反转了一下，如此一来我们求解后缀最大值就转化成了求解前缀最大值。因此我们再建立一个树状数组对这种情况特殊处理，对于 我们将节点 赋值为 即可。\n\n而 的情况也是类似，只需要改变 i 的遍历顺序为从大到小就可以了。\n\n\n# Code：\n\n\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate <typename T>\nstruct Fenwick {\n    std::vector<T> a;\n    int n;\n    \n    Fenwick(int n = 0) {\n        init(n);\n    }\n    \n    void init(int n) {    \n        this->n = n;\n        a.assign(n, T()); \n    }\n\n    void add(int x, T v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] += v;\n        }\n    }\n    \n    T get(int x) {\n        T ans = T();\n        for (int i = x; i >= 1; i -= i & -i) {\n            ans += a[i - 1];\n        }\n        return ans;\n    }\n    \n    T rangeSum(int l, int r) {\n        return get(r) - get(l - 1);\n    }\n\n    int kth(T k) {\n        int x = 0;\n        for (int i = 1 << (31 - __builtin_clz(n)); i >= 1; i >>= 1) {\n            if (x + i <= n && k >= a[x + i - 1]) {\n                x += i;\n                k -= a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\nconst int inf = 1e9;\n\nstruct Max {\n    int v;\n    Max(int x = -inf) : v(x) {};\n    Max &operator+=(const Max &rhs) {\n        v = std::max(v, rhs.v);\n        return *this;\n    }\n};\n\nint main() {\t\n\tstd::ios::sync_with_stdio(false); \n\tstd::cin.tie(nullptr);\n\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<int> p(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> p[i];\n\t\tp[i]--;\n\t}\n\n\tFenwick<Max> f1(n + 1), f2(n + 1);\n\n\tstd::vector<int> res(n);\n\tfor (int i = 0; i < n; i++) { \n\t\tres[i] = std::min(p[i] + i - f1.get(p[i] + 1).v, i - p[i] - f2.get(n - p[i]).v);\n\t\tf1.add(p[i], p[i] + i);\n\t\tf2.add(n - 1 - p[i], i - p[i]);\n\t}\n\n\tf1.init(n);\n\tf2.init(n);\n\n\tfor (int i = n - 1; i >= 0; i--) { \n\t\tres[i] = std::min({res[i], p[i] - i - f1.get(p[i] + 1).v, -p[i] - i - f2.get(n - p[i]).v});\n\t\tf1.add(p[i], p[i] - i);\n\t\tf2.add(n - 1 - p[i], -p[i] - i);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cout << res[i] << " \\n"[i == n - 1];\n\t}\n\n\treturn 0;\n}\t\n',normalizedContent:'题目链接：abc283_f\n\n\n# 题目大意：\n\n给定一个长度为 的排列 ，对每一个 求解\n\n\n# 思路：\n\n看到两个绝对值，我们不妨将绝对值拆除，分为四种情况来讨论。\n\n 1. ，\n    \n 2. ，\n    \n 3. ，\n    \n 4. ，\n    \n\n我们先考虑 的两种情况:\n\n\n * 如果 ，我们可以给 建立权值树状数组， 节点赋值为 。\n   我们从小到大遍历 i，可以保证之前出现过的项中 j 一定小于 i，然后遍历的过程中更新树状数组，如果我们用树状数组求 的前缀最大值，如此一来一定可以保证得到的最大值满足\n * 如果 我们与第一种情况处理方式类似，但是有一点不同的是我们此时要找到的是大于 的 ，因此此时应该在树状数组求 的后缀最大值。一种可行的方案是我们求前缀值的函数由从大到小遍历改为从小到大遍历。另一种更好的方法是，我们将树状数组下标 映射成 ，也就是相当于将树状数组整体反转了一下，如此一来我们求解后缀最大值就转化成了求解前缀最大值。因此我们再建立一个树状数组对这种情况特殊处理，对于 我们将节点 赋值为 即可。\n\n而 的情况也是类似，只需要改变 i 的遍历顺序为从大到小就可以了。\n\n\n# code：\n\n\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate <typename t>\nstruct fenwick {\n    std::vector<t> a;\n    int n;\n    \n    fenwick(int n = 0) {\n        init(n);\n    }\n    \n    void init(int n) {    \n        this->n = n;\n        a.assign(n, t()); \n    }\n\n    void add(int x, t v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] += v;\n        }\n    }\n    \n    t get(int x) {\n        t ans = t();\n        for (int i = x; i >= 1; i -= i & -i) {\n            ans += a[i - 1];\n        }\n        return ans;\n    }\n    \n    t rangesum(int l, int r) {\n        return get(r) - get(l - 1);\n    }\n\n    int kth(t k) {\n        int x = 0;\n        for (int i = 1 << (31 - __builtin_clz(n)); i >= 1; i >>= 1) {\n            if (x + i <= n && k >= a[x + i - 1]) {\n                x += i;\n                k -= a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\nconst int inf = 1e9;\n\nstruct max {\n    int v;\n    max(int x = -inf) : v(x) {};\n    max &operator+=(const max &rhs) {\n        v = std::max(v, rhs.v);\n        return *this;\n    }\n};\n\nint main() {\t\n\tstd::ios::sync_with_stdio(false); \n\tstd::cin.tie(nullptr);\n\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<int> p(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> p[i];\n\t\tp[i]--;\n\t}\n\n\tfenwick<max> f1(n + 1), f2(n + 1);\n\n\tstd::vector<int> res(n);\n\tfor (int i = 0; i < n; i++) { \n\t\tres[i] = std::min(p[i] + i - f1.get(p[i] + 1).v, i - p[i] - f2.get(n - p[i]).v);\n\t\tf1.add(p[i], p[i] + i);\n\t\tf2.add(n - 1 - p[i], i - p[i]);\n\t}\n\n\tf1.init(n);\n\tf2.init(n);\n\n\tfor (int i = n - 1; i >= 0; i--) { \n\t\tres[i] = std::min({res[i], p[i] - i - f1.get(p[i] + 1).v, -p[i] - i - f2.get(n - p[i]).v});\n\t\tf1.add(p[i], p[i] - i);\n\t\tf2.add(n - 1 - p[i], -p[i] - i);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cout << res[i] << " \\n"[i == n - 1];\n\t}\n\n\treturn 0;\n}\t\n',charsets:{cjk:!0}},{title:"整理：基于着色Petri网的无人机侦察战术规划",frontmatter:{title:"整理：基于着色Petri网的无人机侦察战术规划",date:"2022-08-13T23:35:57.000Z",permalink:"/pages/547f66/",tags:["Research","Paper Reading","Petri Net"]},regularPath:"/02.Research/01.Paper%20Reading/01.Petri%20Net/01.%E6%95%B4%E7%90%86%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%9D%80%E8%89%B2Petri%E7%BD%91%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BE%A6%E5%AF%9F%E6%88%98%E6%9C%AF%E8%A7%84%E5%88%92.html",relativePath:"02.Research/01.Paper Reading/01.Petri Net/01.整理：基于着色Petri网的无人机侦察战术规划.md",key:"v-4588700e",path:"/pages/547f66/",headers:[{level:2,title:"传统存在问题 and 本文提出方案",slug:"传统存在问题-and-本文提出方案",normalizedTitle:"传统存在问题 and 本文提出方案",charIndex:76},{level:2,title:"方案各环节浅析",slug:"方案各环节浅析",normalizedTitle:"方案各环节浅析",charIndex:202},{level:4,title:"着色Petri网",slug:"着色petri网",normalizedTitle:"着色petri网",charIndex:8},{level:4,title:"计划-目标层次分解",slug:"计划-目标层次分解",normalizedTitle:"计划-目标层次分解",charIndex:388},{level:4,title:"消耗类资源规划建模",slug:"消耗类资源规划建模",normalizedTitle:"消耗类资源规划建模",charIndex:653},{level:4,title:"正效应规划建模",slug:"正效应规划建模",normalizedTitle:"正效应规划建模",charIndex:1257},{level:4,title:"负效应规划建模",slug:"负效应规划建模",normalizedTitle:"负效应规划建模",charIndex:1588},{level:2,title:"方案的验证",slug:"方案的验证",normalizedTitle:"方案的验证",charIndex:1798},{level:4,title:"无人机侦察战术规划",slug:"无人机侦察战术规划",normalizedTitle:"无人机侦察战术规划",charIndex:1807},{level:2,title:"个人总结",slug:"个人总结",normalizedTitle:"个人总结",charIndex:2451}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"传统存在问题 and 本文提出方案 方案各环节浅析 着色Petri网 计划-目标层次分解 消耗类资源规划建模 正效应规划建模 负效应规划建模 方案的验证 无人机侦察战术规划 个人总结",content:'# 整理:《基于着色Petri网的无人机侦察规划》\n\n * 无人机任务规划可分为 路径规划、战术规划、航迹规划，本文侧重于对 战术规划 的设计\n\n\n# 传统存在问题 and 本文提出方案\n\n * 传统的 Petri 网不能准确模拟战术规划中资源及任务正负效应建模\n\n * 采用着色Petri网进一步设计网间结构，利用总体目标管理图以及变量管理图实现了消耗类资源以及多目标任务规划中的正负效应模拟\n\n\n# 方案各环节浅析\n\n# 着色Petri网\n\n基于Petri网上，主要对托肯以及有向弧进行了扩展：\n\n 1. 每个标记附加一个颜色数据值（可以用来表示消耗类资源）\n 2. 对各条有向弧定义标记类型和通过条件\n 3. 对变迁定义变迁表达式函数，对触发条件进行约束。\n\n笔记\n\n因为暂时还没系统学习过离散数学，并不能非常好的理解形式化定义的各个部分，但大致意思还是能明白的\n\n# 计划-目标层次分解\n\n使用树结构对计划和目标进行分解和描述\n\n * 目标／子目标节点可以包含多个计划节点实现任一计划，都可完成该目标\n\n笔记\n\n子目标节点的托肯可以通过任意一个变迁转移到某一个计划结点\n\n个人理解：要完成一个计划，可以分解为完成多个目标，例如实现一个战略计划，则需要达成多个目标\n\n * 计划节点可以包含多个子目标节点实现所有子目标，才可以完成该计划\n\n笔记\n\n计划节点的托肯会转移到各个子目标结点 个人理解：要完成一个目标，可以分解为完成多个计划中的一个，比如可以用PlanA，PlanB来达成一个目的。\n\n# 消耗类资源规划建模\n\n基于着色技术，通过资源信息总览实现对各类资源和资源消耗总量的记录，借此可以判断某目标能否安全完成(安全性)以及资源消耗总量情况(最优性)\n\n * 消耗类资源模型\n\n笔记\n\n对于 t1，当满足 q >= x 时，就进行变迁，从 P1 走 f1 给予 t1 q 个资源，进行检查后，再走 f1 返还给 P1 q 个资源。 对于t2，当满足 q >= x 时，就进行变迁，从 P1 走 f2 给予 t2 q个资源，再走 f3 从 t2 给予 P1 q - x 个资源 另外，双向箭头一般代表着比较、判断，尤其是在后面的 "与资源信息总览比较" 中\n\n * 最优计划推理结构图\n\n笔记\n\n先进行双向指向的变迁（用于比较和判断资），若ok，那么再继续进行最优计划的那条路进行变迁\n\n * 基于资源信息总览的任务目标推理\n\n笔记\n\n首先 有向弧 指向 资源信息总览的库所 则一定是 R_new，因为是要更新资源；而返回回去的时候则是把原资源返回回去，所以是 R_old。 另外第一次更新，会先更新新目标的资源消耗量(第一类)，同时判断执行该目标的安全性；接着执行完该目标后再次更新，此时更新执行该目标后的资源消耗总量(第二类)。 中间执行该目标的过程很好理解，不知道这里想的对不对。 图五的中的计划执行前会先获取计划的资源消耗信息来更新资源信息总览，随后再执行计划，计划结束后又会再次更新。\n\n# 正效应规划建模\n\n * 正效应： 对于拥有相同触发条件的多个目标，我们只需只执行一次对应的计划。\n   \n   * 可以避免大量的重复工作、资源消耗\n   * 正效应推理是对目标的触发条件判断是否已经满足\n\n * 正效应推理模型\n\n笔记\n\n对于一个子目标，先传递给 P2，P5 托肯，P5 开始的正效应推理判断此时目标是否已经达成了。此推理过程会触发 变量管理图中的变迁 t3，如果目标未达成，则 P6 获得 托肯，接着开始执行计划。开始执行后，会通过触发变迁 t2，来给P1设置目标效果值，接着会触发 t1，用来更新总体目标，P7 中的这一个新的满足条件的托肯便会移入 P8，当 P7 中所有托肯移入 P8，则会触发 t5，最终到达 P9，总目标达成。\n\n# 负效应规划建模\n\n * 负效应： 对于3个及3个以上的目标，目标的触发条件之间存在着因果、阻碍关系。通过负效应推理，正确安排事件的执行顺序。\n   \n   * 达到目标的完全实现，避免资源浪费\n   * 本文负效应推理的实现基于保护托肯\n\n * 负效应推理模型\n\n笔记\n\n当一个目标执行时，会对库所 P1 添加保护托肯。只有当该目标执行完成后，才会移除保护托肯。 当有保护托肯时，别的目标无法更改库所 P1 值\n\n\n# 方案的验证\n\n# 无人机侦察战术规划\n\n * 侦查任务层次分解结构图\n\n笔记\n\n流程分析(照搬阅读笔记的)：\n\n1、首先总目标下分为很多个小目标，对于这些小目标有依次执行的顺序，①飞至区域 X，一定在传输 X 区域信息之前 ②飞至一个区域时不能飞往另一个区域（保护托肯）③飞至一个区域时可以传输另一个区域的信息(如果去过的话)\n\n2、在准备开始执行一个子目标时，会先触发相关变迁，随后 t32 触发，会将获取到的消耗量信息更新给资源信息总览(同时判断执行安全性)，以及添加保护托肯(飞往任务)，这些变迁是 t32 关联的\n\n3、在结束一个子目标后，与(2)相同，应该也会触发相关的变迁，随后将 t34 触发，更新资源信息总览、设置保护托肯，当然还会触发 t37 来更新消耗类资源\n\n4、传输信息的任务进去时会先执行正效应推理，来判断是否已完成，以防浪费资源，但这里不存在正效应\n\n5、本任务中的负效应主要是飞至任务区域A和侦查任务区域A时不能飞往任务区域B，在结束侦查A的任务后会移除保护托肯，而在开始飞往一个区域的任务执行时会添加保护托肯\n\n6、总体上，每完成一个子目标，P50 就会获得一个托肯，当获得 6 个托肯时，就会触发一系列表示最终任务完成的变迁和库所\n\nPS：\n\n1、橙色部分是正效应推理 2、传输区域的任务部分，目标下有两个计划，一个计划是传输工作，另一个是直接返回基地 一般会优先执行传输计划，无论是飞往B地(保护托肯制约)，还是未执行飞往B地（因为根据燃油消耗量选择最优计划)\n\n\n# 个人总结\n\n * 文章方面\n   \n   * 在阅读图表的时候，文章没有对所有标记都写上含义，导致有些地方可能是个人理解，难免会产生偏差\n   * 在负效应规划建模方法里，有一句话个人觉得可能是写错了图７中，P2库所与P7库所表示的子目标g1与g2同属于一个计划\n   * 文章脉络清晰，对现存问题和改进方案，包括方案具体缓解都进行了详细的分析，配以图表；同时应用相关案例对方案进行了验证；最终进行总结，并提出研究缺陷不能表达任务执行的时间因素 和 未来研究方向将分层及时延概念引入结构图。\n\n * 个人方面\n   \n   * 作为第一次阅读学术论文，确实存在大量的前置概念不了解，尤其是离散数学只有算法图论的一些概念，没有系统学过。借此补上了相关知识点 Petri Net基础 、部分离散数学的符号意义\n   * 对学术论文写作有了大致的了解，包括其框架、内容等\n   * 增加了对Petri网的相关研究的了解',normalizedContent:'# 整理:《基于着色petri网的无人机侦察规划》\n\n * 无人机任务规划可分为 路径规划、战术规划、航迹规划，本文侧重于对 战术规划 的设计\n\n\n# 传统存在问题 and 本文提出方案\n\n * 传统的 petri 网不能准确模拟战术规划中资源及任务正负效应建模\n\n * 采用着色petri网进一步设计网间结构，利用总体目标管理图以及变量管理图实现了消耗类资源以及多目标任务规划中的正负效应模拟\n\n\n# 方案各环节浅析\n\n# 着色petri网\n\n基于petri网上，主要对托肯以及有向弧进行了扩展：\n\n 1. 每个标记附加一个颜色数据值（可以用来表示消耗类资源）\n 2. 对各条有向弧定义标记类型和通过条件\n 3. 对变迁定义变迁表达式函数，对触发条件进行约束。\n\n笔记\n\n因为暂时还没系统学习过离散数学，并不能非常好的理解形式化定义的各个部分，但大致意思还是能明白的\n\n# 计划-目标层次分解\n\n使用树结构对计划和目标进行分解和描述\n\n * 目标／子目标节点可以包含多个计划节点实现任一计划，都可完成该目标\n\n笔记\n\n子目标节点的托肯可以通过任意一个变迁转移到某一个计划结点\n\n个人理解：要完成一个计划，可以分解为完成多个目标，例如实现一个战略计划，则需要达成多个目标\n\n * 计划节点可以包含多个子目标节点实现所有子目标，才可以完成该计划\n\n笔记\n\n计划节点的托肯会转移到各个子目标结点 个人理解：要完成一个目标，可以分解为完成多个计划中的一个，比如可以用plana，planb来达成一个目的。\n\n# 消耗类资源规划建模\n\n基于着色技术，通过资源信息总览实现对各类资源和资源消耗总量的记录，借此可以判断某目标能否安全完成(安全性)以及资源消耗总量情况(最优性)\n\n * 消耗类资源模型\n\n笔记\n\n对于 t1，当满足 q >= x 时，就进行变迁，从 p1 走 f1 给予 t1 q 个资源，进行检查后，再走 f1 返还给 p1 q 个资源。 对于t2，当满足 q >= x 时，就进行变迁，从 p1 走 f2 给予 t2 q个资源，再走 f3 从 t2 给予 p1 q - x 个资源 另外，双向箭头一般代表着比较、判断，尤其是在后面的 "与资源信息总览比较" 中\n\n * 最优计划推理结构图\n\n笔记\n\n先进行双向指向的变迁（用于比较和判断资），若ok，那么再继续进行最优计划的那条路进行变迁\n\n * 基于资源信息总览的任务目标推理\n\n笔记\n\n首先 有向弧 指向 资源信息总览的库所 则一定是 r_new，因为是要更新资源；而返回回去的时候则是把原资源返回回去，所以是 r_old。 另外第一次更新，会先更新新目标的资源消耗量(第一类)，同时判断执行该目标的安全性；接着执行完该目标后再次更新，此时更新执行该目标后的资源消耗总量(第二类)。 中间执行该目标的过程很好理解，不知道这里想的对不对。 图五的中的计划执行前会先获取计划的资源消耗信息来更新资源信息总览，随后再执行计划，计划结束后又会再次更新。\n\n# 正效应规划建模\n\n * 正效应： 对于拥有相同触发条件的多个目标，我们只需只执行一次对应的计划。\n   \n   * 可以避免大量的重复工作、资源消耗\n   * 正效应推理是对目标的触发条件判断是否已经满足\n\n * 正效应推理模型\n\n笔记\n\n对于一个子目标，先传递给 p2，p5 托肯，p5 开始的正效应推理判断此时目标是否已经达成了。此推理过程会触发 变量管理图中的变迁 t3，如果目标未达成，则 p6 获得 托肯，接着开始执行计划。开始执行后，会通过触发变迁 t2，来给p1设置目标效果值，接着会触发 t1，用来更新总体目标，p7 中的这一个新的满足条件的托肯便会移入 p8，当 p7 中所有托肯移入 p8，则会触发 t5，最终到达 p9，总目标达成。\n\n# 负效应规划建模\n\n * 负效应： 对于3个及3个以上的目标，目标的触发条件之间存在着因果、阻碍关系。通过负效应推理，正确安排事件的执行顺序。\n   \n   * 达到目标的完全实现，避免资源浪费\n   * 本文负效应推理的实现基于保护托肯\n\n * 负效应推理模型\n\n笔记\n\n当一个目标执行时，会对库所 p1 添加保护托肯。只有当该目标执行完成后，才会移除保护托肯。 当有保护托肯时，别的目标无法更改库所 p1 值\n\n\n# 方案的验证\n\n# 无人机侦察战术规划\n\n * 侦查任务层次分解结构图\n\n笔记\n\n流程分析(照搬阅读笔记的)：\n\n1、首先总目标下分为很多个小目标，对于这些小目标有依次执行的顺序，①飞至区域 x，一定在传输 x 区域信息之前 ②飞至一个区域时不能飞往另一个区域（保护托肯）③飞至一个区域时可以传输另一个区域的信息(如果去过的话)\n\n2、在准备开始执行一个子目标时，会先触发相关变迁，随后 t32 触发，会将获取到的消耗量信息更新给资源信息总览(同时判断执行安全性)，以及添加保护托肯(飞往任务)，这些变迁是 t32 关联的\n\n3、在结束一个子目标后，与(2)相同，应该也会触发相关的变迁，随后将 t34 触发，更新资源信息总览、设置保护托肯，当然还会触发 t37 来更新消耗类资源\n\n4、传输信息的任务进去时会先执行正效应推理，来判断是否已完成，以防浪费资源，但这里不存在正效应\n\n5、本任务中的负效应主要是飞至任务区域a和侦查任务区域a时不能飞往任务区域b，在结束侦查a的任务后会移除保护托肯，而在开始飞往一个区域的任务执行时会添加保护托肯\n\n6、总体上，每完成一个子目标，p50 就会获得一个托肯，当获得 6 个托肯时，就会触发一系列表示最终任务完成的变迁和库所\n\nps：\n\n1、橙色部分是正效应推理 2、传输区域的任务部分，目标下有两个计划，一个计划是传输工作，另一个是直接返回基地 一般会优先执行传输计划，无论是飞往b地(保护托肯制约)，还是未执行飞往b地（因为根据燃油消耗量选择最优计划)\n\n\n# 个人总结\n\n * 文章方面\n   \n   * 在阅读图表的时候，文章没有对所有标记都写上含义，导致有些地方可能是个人理解，难免会产生偏差\n   * 在负效应规划建模方法里，有一句话个人觉得可能是写错了图７中，p2库所与p7库所表示的子目标g1与g2同属于一个计划\n   * 文章脉络清晰，对现存问题和改进方案，包括方案具体缓解都进行了详细的分析，配以图表；同时应用相关案例对方案进行了验证；最终进行总结，并提出研究缺陷不能表达任务执行的时间因素 和 未来研究方向将分层及时延概念引入结构图。\n\n * 个人方面\n   \n   * 作为第一次阅读学术论文，确实存在大量的前置概念不了解，尤其是离散数学只有算法图论的一些概念，没有系统学过。借此补上了相关知识点 petri net基础 、部分离散数学的符号意义\n   * 对学术论文写作有了大致的了解，包括其框架、内容等\n   * 增加了对petri网的相关研究的了解',charsets:{cjk:!0}},{title:"01 - Introduction",frontmatter:{title:"01 - Introduction",date:"2023-09-18T19:28:17.000Z",permalink:"/pages/2498ed/",tags:["Research","Static Analysis","NJU Course Notes"]},regularPath:"/02.Research/02.Static%20Analysis/01.NJU%20Course%20Notes/01.Introduction.html",relativePath:"02.Research/02.Static Analysis/01.NJU Course Notes/01.Introduction.md",key:"v-10dcc84e",path:"/pages/2498ed/",headers:[{level:3,title:"什么是静态分析：静态分析在 PL 研究领域下的划分以及其背景和挑战",slug:"什么是静态分析-静态分析在-pl-研究领域下的划分以及其背景和挑战",normalizedTitle:"什么是静态分析：静态分析在 pl 研究领域下的划分以及其背景和挑战",charIndex:50},{level:3,title:"为什么需要静态分析？",slug:"为什么需要静态分析",normalizedTitle:"为什么需要静态分析？",charIndex:88},{level:3,title:"静态分析和莱斯定理",slug:"静态分析和莱斯定理",normalizedTitle:"静态分析和莱斯定理",charIndex:143},{level:3,title:"Perfect static analysis 是不存在的",slug:"perfect-static-analysis-是不存在的",normalizedTitle:"perfect static analysis 是不存在的",charIndex:581},{level:3,title:"Static Analysis — Bird’s Eye View",slug:"static-analysis-bird-s-eye-view",normalizedTitle:"static analysis — bird’s eye view",charIndex:1075},{level:3,title:"Static Analysis(most)：Abstraction + Over-approximation",slug:"static-analysis-most-abstraction-over-approximation",normalizedTitle:"static analysis(most)：abstraction + over-approximation",charIndex:1398},{level:3,title:"需要掌握的重点",slug:"需要掌握的重点",normalizedTitle:"需要掌握的重点",charIndex:1723}],lastUpdated:"9/22/2023, 7:07:10 PM",lastUpdatedTimestamp:169538083e4,headersStr:"什么是静态分析：静态分析在 PL 研究领域下的划分以及其背景和挑战 为什么需要静态分析？ 静态分析和莱斯定理 Perfect static analysis 是不存在的 Static Analysis — Bird’s Eye View Static Analysis(most)：Abstraction + Over-approximation 需要掌握的重点",content:"# Introduction\n\n> 本系列笔记的课程地址：南京大学《软件分析》课程2020\n\n\n# 什么是静态分析：静态分析在 PL 研究领域下的划分以及其背景和挑战\n\n\n# 为什么需要静态分析？\n\n 1. 程序可靠性\n 2. 程序安全性\n 3. 编译优化\n 4. 程序的理解\n\n\n# 静态分析和莱斯定理\n\n * SA 会分析一个程序 P，去推导 P 的一些行为和 properties\n   * 内存泄漏、空指针、强制类型转换的安全、数据竞争、断言失败、无效代码等...（下面的 non-trivial properties）\n * 莱斯（Rice)定理：Any non-trivial property of the behavior of programs in a r.e. language is undecidable.\n   * r.e. (recursively enumerable)递归可枚举 = recognizable by a Turing-machine 能被图灵机识别\n   * non-trivial properties 一般指 我们关心的、和运行时行为有关的一些 properies\n   * 简单来说就是，这些我们一般会去关心的一些运行时的行为问题，例如空指针、内存泄漏等，静态分析是不能给出一个完成精确的答案的。\n\n\n# Perfect static analysis 是不存在的\n\n * 何为 Perfect ？\n   * Truth：满足 Sound and Complete，包含的内容就是所有可能的错误\n * Sound：包含了所有真实错误，但也可能包含了误报的错误，即 Overapproximate\n * Complete：包含了的错误全是真实错误，但可能漏报，即 Underapproximate\n * 关系图：\n\n * 根据 Rice 定理，完美的静态分析是不存在的，但我们可以进行 useful 的静态分析\n   * 两种选择：1. 妥协 Soundness 2. 妥协 Completeness\n   * Compromise soundness 会造成 false negative（漏报）\n   * Compromise completeness 会造成 false positive（误报）⭐️\n     * 大部分下更追求 sound 的静态分析\n     * sound 一般会更被优先考虑，例如在 bug 检测里，满足了 soundness 意味着能检测出更多 bug\n\n\n# Static Analysis — Bird’s Eye View\n\nif (input) {\n\tx = 1;\n} else {\n\tx = 0;\n}\nx = ?\n\n\n对于 x = ? 的分析，下面有两种分析结果：\n\n 1. input 为 true，则 x = 1；input 为 false，则 x = 0\n    \n    * 特点：sound，precise，expensive\n\n 2. x = 1 or x = 0\n    \n    * 特点：sound，imprecise，cheap\n\n * 这两种结果都满足了 sound，但精确度和生成代价不同，往往就是在 precision 和 speed 之间做 trade-off\n\n\n# Static Analysis(most)：Abstraction + Over-approximation\n\n * Abstraction，以下面的例子为例，在静态分析中我们所关心的 domain 往往不是程序中的 domain，我们要对程序中的具体域的值映射到抽象域\n\n * Over-approximate\n   \n   1. Transfer Function 定义了如何在抽象值上去评估程序语句，它是由 “分析问题” 和 ”不同程序语句的语义“ 所定义的。\n   * eg：以上面的正负为例\n   2. Control Flows\n   * 但实际情况下枚举所有路径往往是不太可能的，所以我们一般默认采用 flow merging\n\n\n# 需要掌握的重点\n\n 1. 静态分析和（动态）测试的区别？\n 2. 理解 soundness，completeness，false negatives 和 false postives\n 3. 为什么 soundness 在静态分析中是必需的？\n 4. 如何理解 abstraction 和 over-approximation",normalizedContent:"# introduction\n\n> 本系列笔记的课程地址：南京大学《软件分析》课程2020\n\n\n# 什么是静态分析：静态分析在 pl 研究领域下的划分以及其背景和挑战\n\n\n# 为什么需要静态分析？\n\n 1. 程序可靠性\n 2. 程序安全性\n 3. 编译优化\n 4. 程序的理解\n\n\n# 静态分析和莱斯定理\n\n * sa 会分析一个程序 p，去推导 p 的一些行为和 properties\n   * 内存泄漏、空指针、强制类型转换的安全、数据竞争、断言失败、无效代码等...（下面的 non-trivial properties）\n * 莱斯（rice)定理：any non-trivial property of the behavior of programs in a r.e. language is undecidable.\n   * r.e. (recursively enumerable)递归可枚举 = recognizable by a turing-machine 能被图灵机识别\n   * non-trivial properties 一般指 我们关心的、和运行时行为有关的一些 properies\n   * 简单来说就是，这些我们一般会去关心的一些运行时的行为问题，例如空指针、内存泄漏等，静态分析是不能给出一个完成精确的答案的。\n\n\n# perfect static analysis 是不存在的\n\n * 何为 perfect ？\n   * truth：满足 sound and complete，包含的内容就是所有可能的错误\n * sound：包含了所有真实错误，但也可能包含了误报的错误，即 overapproximate\n * complete：包含了的错误全是真实错误，但可能漏报，即 underapproximate\n * 关系图：\n\n * 根据 rice 定理，完美的静态分析是不存在的，但我们可以进行 useful 的静态分析\n   * 两种选择：1. 妥协 soundness 2. 妥协 completeness\n   * compromise soundness 会造成 false negative（漏报）\n   * compromise completeness 会造成 false positive（误报）⭐️\n     * 大部分下更追求 sound 的静态分析\n     * sound 一般会更被优先考虑，例如在 bug 检测里，满足了 soundness 意味着能检测出更多 bug\n\n\n# static analysis — bird’s eye view\n\nif (input) {\n\tx = 1;\n} else {\n\tx = 0;\n}\nx = ?\n\n\n对于 x = ? 的分析，下面有两种分析结果：\n\n 1. input 为 true，则 x = 1；input 为 false，则 x = 0\n    \n    * 特点：sound，precise，expensive\n\n 2. x = 1 or x = 0\n    \n    * 特点：sound，imprecise，cheap\n\n * 这两种结果都满足了 sound，但精确度和生成代价不同，往往就是在 precision 和 speed 之间做 trade-off\n\n\n# static analysis(most)：abstraction + over-approximation\n\n * abstraction，以下面的例子为例，在静态分析中我们所关心的 domain 往往不是程序中的 domain，我们要对程序中的具体域的值映射到抽象域\n\n * over-approximate\n   \n   1. transfer function 定义了如何在抽象值上去评估程序语句，它是由 “分析问题” 和 ”不同程序语句的语义“ 所定义的。\n   * eg：以上面的正负为例\n   2. control flows\n   * 但实际情况下枚举所有路径往往是不太可能的，所以我们一般默认采用 flow merging\n\n\n# 需要掌握的重点\n\n 1. 静态分析和（动态）测试的区别？\n 2. 理解 soundness，completeness，false negatives 和 false postives\n 3. 为什么 soundness 在静态分析中是必需的？\n 4. 如何理解 abstraction 和 over-approximation",charsets:{cjk:!0}},{title:"Dive into Deep Learning",frontmatter:{title:"Dive into Deep Learning",date:"2024-01-27T21:44:53.000Z",permalink:"/pages/382964/",tags:["AI","Deep Learning"]},regularPath:"/02.Research/03.Deep%20Learning/01.Dive%20into%20Deep%20Learning.html",relativePath:"02.Research/03.Deep Learning/01.Dive into Deep Learning.md",key:"v-62cfc316",path:"/pages/382964/",lastUpdated:"1/27/2024, 11:09:55 PM",lastUpdatedTimestamp:1706368195e3,headersStr:null,content:"> 我会在这里记录下学习《动手学深度学习v2》课程的过程\n> \n> 课程网站：https://courses.d2l.ai/zh-v2/\n> \n> 还在备战考研，容易拖（",normalizedContent:"> 我会在这里记录下学习《动手学深度学习v2》课程的过程\n> \n> 课程网站：https://courses.d2l.ai/zh-v2/\n> \n> 还在备战考研，容易拖（",charsets:{cjk:!0}},{title:"简简单单刷个题⑧",frontmatter:{title:"简简单单刷个题⑧",date:"2023-01-12T15:45:56.000Z",permalink:"/pages/0b751d/",tags:["Competitive Programming","刷题日寄"]},regularPath:"/01.Competitive%20Programming/03.%E5%88%B7%E9%A2%98%E6%97%A5%E5%AF%84/01.%E7%AE%80%E7%AE%80%E5%8D%95%E5%8D%95%E5%88%B7%E4%B8%AA%E9%A2%98%E2%91%A7.html",relativePath:"01.Competitive Programming/03.刷题日寄/01.简简单单刷个题⑧.md",key:"v-5dd5a642",path:"/pages/0b751d/",headers:[{level:3,title:"二分答案",slug:"二分答案",normalizedTitle:"二分答案",charIndex:100},{level:3,title:"单调栈",slug:"单调栈",normalizedTitle:"单调栈",charIndex:140},{level:3,title:"贪心",slug:"贪心",normalizedTitle:"贪心",charIndex:172},{level:3,title:"并查集",slug:"并查集",normalizedTitle:"并查集",charIndex:222},{level:3,title:"ST表",slug:"st表",normalizedTitle:"st表",charIndex:281},{level:3,title:"树状数组",slug:"树状数组",normalizedTitle:"树状数组",charIndex:340},{level:3,title:"最短路",slug:"最短路",normalizedTitle:"最短路",charIndex:392},{level:3,title:"LCA",slug:"lca",normalizedTitle:"lca",charIndex:461},{level:3,title:"DP",slug:"dp",normalizedTitle:"dp",charIndex:487},{level:3,title:"连通性问题 （Tarjan、Kosaraju）",slug:"连通性问题-tarjan、kosaraju",normalizedTitle:"连通性问题 （tarjan、kosaraju）",charIndex:653},{level:3,title:"线段树",slug:"线段树",normalizedTitle:"线段树",charIndex:711}],lastUpdated:"4/7/2023, 4:44:17 PM",lastUpdatedTimestamp:1680857057e3,headersStr:"二分答案 单调栈 贪心 并查集 ST表 树状数组 最短路 LCA DP 连通性问题 （Tarjan、Kosaraju） 线段树",content:"# 简简单单刷个题⑧\n\n决定从头开始重新刷一下题，打一下基础，写个文章记录一下刷的题吧。\n\n由于不是主线，纯兴趣，所以刷的比较慢就是了。\n\n只记录专题，不记录日常的各种每日一题、CF等比赛题\n\n\n# 二分答案\n\nP1024 P2678 P1902 P1314 P1083\n\n\n# 单调栈\n\nCF547B P5788 P6510(题解)\n\n\n# 贪心\n\nP1208 P4995 P1094 P2672 P1080 P2123 P5521\n\n\n# 并查集\n\nP1111 P3958 P1525 P2024 P1197 P1196 P1955 CF1594D\n\n\n# ST表\n\nP3865 P2251 P1890 CF1691D P1816 P1198 P2880 P2048\n\n\n# 树状数组\n\nP3374 P3368 P3605 P1972 P3586 P4113 P4054\n\n\n# 最短路\n\nP3371(dij、bellmanford、spfa) P4779(堆优化dij) P3385 P4568 P5304\n\n\n# LCA\n\n3379 P3938 P4281\n\n\n# DP\n\n『背包』\n\nP1855 CF189A CF855B(感觉不用背包) CF19B P1833 P1757 P2014(树形背包)\n\n『树形』\n\nP1122 P2899 P1352 P2458 abc287_f(树形背包计数) P1272 P1273 CF212E CF161D CF274B\n\n『数位』\n\nP2602\n\n\n# 连通性问题 （Tarjan、Kosaraju）\n\nP3388 P2860 P3387 P2341 2746\n\n\n# 线段树\n\nP3372 CF242E CF444C P6492 CF620E P2894 P1438 CF438D DMY469",normalizedContent:"# 简简单单刷个题⑧\n\n决定从头开始重新刷一下题，打一下基础，写个文章记录一下刷的题吧。\n\n由于不是主线，纯兴趣，所以刷的比较慢就是了。\n\n只记录专题，不记录日常的各种每日一题、cf等比赛题\n\n\n# 二分答案\n\np1024 p2678 p1902 p1314 p1083\n\n\n# 单调栈\n\ncf547b p5788 p6510(题解)\n\n\n# 贪心\n\np1208 p4995 p1094 p2672 p1080 p2123 p5521\n\n\n# 并查集\n\np1111 p3958 p1525 p2024 p1197 p1196 p1955 cf1594d\n\n\n# st表\n\np3865 p2251 p1890 cf1691d p1816 p1198 p2880 p2048\n\n\n# 树状数组\n\np3374 p3368 p3605 p1972 p3586 p4113 p4054\n\n\n# 最短路\n\np3371(dij、bellmanford、spfa) p4779(堆优化dij) p3385 p4568 p5304\n\n\n# lca\n\n3379 p3938 p4281\n\n\n# dp\n\n『背包』\n\np1855 cf189a cf855b(感觉不用背包) cf19b p1833 p1757 p2014(树形背包)\n\n『树形』\n\np1122 p2899 p1352 p2458 abc287_f(树形背包计数) p1272 p1273 cf212e cf161d cf274b\n\n『数位』\n\np2602\n\n\n# 连通性问题 （tarjan、kosaraju）\n\np3388 p2860 p3387 p2341 2746\n\n\n# 线段树\n\np3372 cf242e cf444c p6492 cf620e p2894 p1438 cf438d dmy469",charsets:{cjk:!0}},{title:"[MIT6.S081]Lab1: Unix utilities",frontmatter:{title:null,date:"2023-02-01T21:20:08.000Z",permalink:"/pages/80231f/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/01.Lab1:%20Unix%20utilities.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/01.Lab1: Unix utilities.md",key:"v-ea6ca4f0",path:"/pages/80231f/",headers:[{level:3,title:"1、Sleep",slug:"_1、sleep",normalizedTitle:"1、sleep",charIndex:77},{level:3,title:"2、Pingpong",slug:"_2、pingpong",normalizedTitle:"2、pingpong",charIndex:470},{level:3,title:"3、Primes",slug:"_3、primes",normalizedTitle:"3、primes",charIndex:1206},{level:3,title:"4、Find",slug:"_4、find",normalizedTitle:"4、find",charIndex:2820},{level:3,title:"5、xargs",slug:"_5、xargs",normalizedTitle:"5、xargs",charIndex:4564},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:6022}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"1、Sleep 2、Pingpong 3、Primes 4、Find 5、xargs 实验结果",content:'# [MIT6.S081]Lab1: Unix utilities\n\nLab: Xv6 and Unix utilities (mit.edu)\n\n\n# 1、Sleep\n\n直接调用 sleep 系统调用即可，注意没有参数时要报错，并且要 exit()\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n\nint main(int argc, char *argv[]) {\n    if (argc <= 1) {\n        fprintf(2, "sleep: missing parameter\\n");\n        exit(1);\n    }\n\n    int n = atoi(argv[1]);\n    if (sleep(n) < 0) {\n        fprintf(2, "sleep: sleep error\\n");\n        exit(1);\n    }\n    exit(0);\n}\n\n\n\n# 2、Pingpong\n\n先在父进程中创建一个管道，文件描述符存在 pipe_fds 中，之后 fork 一份子进程，子进程有着父进程文件描述符的一份拷贝，接下来都是非常基础的系统调用。\n\n要注意父进程需要 wait，等待子进程结束才可以输出 received pong。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n\nint main(int argc, char *argv[]) {\n    int pipe_fds[2]; // 管道读写口 0写 1读\n    if (pipe(pipe_fds) < 0) {\n        fprintf(2, "pipe: error\\n");\n        exit(1);\n    }\n    int pid = fork();\n    if (pid == 0) { // child process\n        char *ch = "";\n        read(pipe_fds[0], ch, 1);\n        fprintf(1, "%d: received ping\\n", pid);\n        exit(0);\n    } else { // parent process\n        char *ch = "a";\n        write(pipe_fds[1], ch, 1); \n        wait(0);\n        fprintf(1, "%d: received pong\\n", pid);\n    }\n    exit(0);\n}\n\n\n\n# 3、Primes\n\n利用管道和进程来筛质数，每一个子进程筛某一个质数的倍数。\n\n思路：\n\n对于每一个 work 函数，参数是左管道的两个文件描述符，每次先读取第一个目前没有被筛掉，也就是当前这一轮的第一个数字，其一定是质数，将其输出。接着我们创建一个新的右管道，用来传递给下一轮进程当前未被筛掉的数字。每个 work 中创建的子进程进入下一轮筛数字，而父进程则执行将这一轮的数字继续读完，并把未被筛掉的数字通过右管道的形式传递给下一轮。\n\n注意点：\n\n 1. 文件描述符上限是 35 个，所以要将无需使用的文件描述符关闭，注释中有标注\n 2. 父进程读取完这一轮的所有数字之后，一定要关闭写入描述符。因为当写口关闭后，read 会返回 0，此时表示没有可以筛的数字了，应该直接关闭进程。\n 3. 另外每个父进程都要等待子进程结束，父进程等待子进程，而子进程又等待子进程的子进程结束。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\nint cnt = 0;\n\nvoid work(int pl[])  {\n    close(pl[1]); // 无需写入\n    int n;\n    if (read(pl[0], &n, sizeof(n)) == 0) { // 如果写口关闭了，read 将会返回 0，即最后一个数字读完后要退出进程\n        exit(0);\n    }\n    fprintf(1, "prime %d\\n", n); // 第一个未被筛去的数字，一定是质数\n\n    int pr[2]; // 右管道，用来传递当前未被筛去的数组\n    pipe(pr);\n\n    if (fork() == 0) { // 子进程递归进行下一轮质数筛\n        work(pr);\n    } else {\n        close(pr[0]); // 父进程无需读入\n        int x = 0;\n        while (read(pl[0], &x, sizeof(x)) != 0) { //从 pl 读取剩余传递来的数字\n            if (x % n != 0) { // 如果未被筛去则进入下一轮筛\n                write(pr[1], &x, sizeof(x));\n            }\n        }\n        close(pr[1]); // 一定要关闭写入符，否则读第一个质数没读到不会变成 0，那么会一直递归下去了。\n        wait(0); // 父进程等待\n    }\n    exit(0);\n}\n\nint main(int argc, char *argv[]) {\n    \n    int pipe_fds[2];\n    pipe(pipe_fds);\n\n    if (fork() == 0) {\n        close(pipe_fds[1]); // 子进程无需写入\n        work(pipe_fds);\n    } else {\n        close(pipe_fds[0]); // 父进程无需读入\n        for (int i = 2; i <= 35; i++) {\n            write(pipe_fds[1], &i, sizeof(i)); // 传递数字\n        }\n        close(pipe_fds[1]); // 一定要关闭写入符，否则读第一个质数不会变成 0，那么会一直递归下去了。\n        wait(0); // 一定要等待\n    }\n    exit(0);\n}\n\n\n\n# 4、Find\n\n大题内容都是仿照 ls.c 的，具体看注释即可\n\npath 是当前目录的路径，buf 是添加文件名后的路径，每次将文件 cp 到 buf 后面进行判断，如果是 FILE 且与我们要的文件名相等则输出，如果是目录且不是 . 和 ..，则递归查找下去。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n#include "kernel/fs.h"\n\nvoid fmtpath(char *path) {\n    char *p;\n    for (p = path + strlen(path); p >= path && *p != \'/\'; p--);\n    *(++p) = 0;\n}\n\nvoid find(char *path, char *fn) {\n    char buf[512], *p;\n    int fd;\n    struct dirent de;\n    struct stat st;\n\n    if((fd = open(path, 0)) < 0){\n        fprintf(2, "ls: cannot open %s\\n", path);\n        return;\n    }\n\n    if(fstat(fd, &st) < 0){\n        fprintf(2, "ls: cannot stat %s\\n", path);\n        close(fd);\n        return;\n    }\n\n    // 读取当前路径下的所有数据\n    while (read(fd, &de, sizeof(de)) == sizeof(de)) {\n        strcpy(buf, path);\n        p = buf + strlen(buf);\n        *p++ = \'/\';\n        if (de.inum == 0) {\n            continue;\n        }\n        memcpy(p, de.name, DIRSIZ); // 将名字加在 buf 后面\n        p[DIRSIZ] = 0;\n    \n        if (stat(buf, &st) < 0) { \n            fprintf(2, "ls: cannot stat %s\\n", buf);\n        }\n\n        switch(st.type) {\n            case T_FILE: // 如果是文件\n                if (strcmp(p, fn) == 0) { // 文件名 和 fn 相同则输出\n                    fprintf(1, "%s\\n", buf);\n                }\n                break;\n\n            case T_DIR: // 如果是目录\n                if (strcmp(p, ".") != 0 && strcmp(p, "..") != 0) { // 且不是 . 和 ..\n                    find(buf, fn); // 递归查询这个目录\n                }\n        }\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[]) {\n\n    if (argc < 3) {\n        fprintf(2, "find: miss parameter\\n");\n        exit(1);\n    }\n\n    char *path = argv[1]; // path \n    char *fn = argv[2]; // file name\n    find(path, fn);\n\n    exit(0);\n}\n\n\n\n# 5、xargs\n\n注释写的很详细了，主要是从标准输入里面读取参数然后将参数保存，然后创建子进程执行命令。\n\n需要注意的点是每次标准输入中读取完一行的参数后要执行一次命令，并且初始参数不变！！！也就是代码中 init_para 之前的参数每次都要(这里我开始没注意，debug 了好久，也是对 xargs 理解不够吧)\n\n#include "kernel/param.h"\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n#include "kernel/fs.h"\n\n#define ARGLEN 50\n\nint main(int argc, char *argv[]) {\n\n    char *cmd = argv[1];\n    int N = argc - 1;\n    char *para[MAXARG]; // 所有参数\n    for (int i = 0; i < N; i++) {\n        para[i] = argv[i + 1];\n    }\n    char **init_para = para + N; // init_para 指向右边指令参数的末尾\n    char arg[MAXARG * ARGLEN]; // 内存池，存放标准输入读取进来的参数\n    char *p = arg; // 用来在 arg 中存储参数，参数之间用 \'\\0\' 分割\n    char ch;\n    int cnt = 0;\n    char **lp = init_para; // lp 用来移动并存储标准输入当前一行的参数\n    while (read(0, &ch, 1) != 0) {\n        if (ch == \' \' || ch == \'\\n\') {\n            *p = 0; // 一个参数或者一行读完，0 分割\n            *lp++ = arg + ARGLEN * cnt; // lp 指向 arg 中当前所有参数存放的末尾\n            cnt++; // 参数个数加一\n            p = arg + ARGLEN * cnt; // p 指向了下一个参数的开头存放的位置\n            \n            if (ch == \'\\n\') { // 如果是换行符，则要执行 exec 了\n                *lp = 0; // para 以 0 为结尾作为参数结束的标志\n                if (fork() == 0) { //创建子进程执行 exec\n                    exec(cmd, para);\n                    exit(0);\n                } else {\n                    wait(0);\n                    lp = init_para; // lp 回到 init_para，重新读取下一行的所有参数\n                }\n            }\n        } else {\n            *p++ = ch;\n        }\n    }\n    exit(0);\n}\n\n\n\n# 实验结果\n',normalizedContent:'# [mit6.s081]lab1: unix utilities\n\nlab: xv6 and unix utilities (mit.edu)\n\n\n# 1、sleep\n\n直接调用 sleep 系统调用即可，注意没有参数时要报错，并且要 exit()\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n\nint main(int argc, char *argv[]) {\n    if (argc <= 1) {\n        fprintf(2, "sleep: missing parameter\\n");\n        exit(1);\n    }\n\n    int n = atoi(argv[1]);\n    if (sleep(n) < 0) {\n        fprintf(2, "sleep: sleep error\\n");\n        exit(1);\n    }\n    exit(0);\n}\n\n\n\n# 2、pingpong\n\n先在父进程中创建一个管道，文件描述符存在 pipe_fds 中，之后 fork 一份子进程，子进程有着父进程文件描述符的一份拷贝，接下来都是非常基础的系统调用。\n\n要注意父进程需要 wait，等待子进程结束才可以输出 received pong。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n\nint main(int argc, char *argv[]) {\n    int pipe_fds[2]; // 管道读写口 0写 1读\n    if (pipe(pipe_fds) < 0) {\n        fprintf(2, "pipe: error\\n");\n        exit(1);\n    }\n    int pid = fork();\n    if (pid == 0) { // child process\n        char *ch = "";\n        read(pipe_fds[0], ch, 1);\n        fprintf(1, "%d: received ping\\n", pid);\n        exit(0);\n    } else { // parent process\n        char *ch = "a";\n        write(pipe_fds[1], ch, 1); \n        wait(0);\n        fprintf(1, "%d: received pong\\n", pid);\n    }\n    exit(0);\n}\n\n\n\n# 3、primes\n\n利用管道和进程来筛质数，每一个子进程筛某一个质数的倍数。\n\n思路：\n\n对于每一个 work 函数，参数是左管道的两个文件描述符，每次先读取第一个目前没有被筛掉，也就是当前这一轮的第一个数字，其一定是质数，将其输出。接着我们创建一个新的右管道，用来传递给下一轮进程当前未被筛掉的数字。每个 work 中创建的子进程进入下一轮筛数字，而父进程则执行将这一轮的数字继续读完，并把未被筛掉的数字通过右管道的形式传递给下一轮。\n\n注意点：\n\n 1. 文件描述符上限是 35 个，所以要将无需使用的文件描述符关闭，注释中有标注\n 2. 父进程读取完这一轮的所有数字之后，一定要关闭写入描述符。因为当写口关闭后，read 会返回 0，此时表示没有可以筛的数字了，应该直接关闭进程。\n 3. 另外每个父进程都要等待子进程结束，父进程等待子进程，而子进程又等待子进程的子进程结束。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\nint cnt = 0;\n\nvoid work(int pl[])  {\n    close(pl[1]); // 无需写入\n    int n;\n    if (read(pl[0], &n, sizeof(n)) == 0) { // 如果写口关闭了，read 将会返回 0，即最后一个数字读完后要退出进程\n        exit(0);\n    }\n    fprintf(1, "prime %d\\n", n); // 第一个未被筛去的数字，一定是质数\n\n    int pr[2]; // 右管道，用来传递当前未被筛去的数组\n    pipe(pr);\n\n    if (fork() == 0) { // 子进程递归进行下一轮质数筛\n        work(pr);\n    } else {\n        close(pr[0]); // 父进程无需读入\n        int x = 0;\n        while (read(pl[0], &x, sizeof(x)) != 0) { //从 pl 读取剩余传递来的数字\n            if (x % n != 0) { // 如果未被筛去则进入下一轮筛\n                write(pr[1], &x, sizeof(x));\n            }\n        }\n        close(pr[1]); // 一定要关闭写入符，否则读第一个质数没读到不会变成 0，那么会一直递归下去了。\n        wait(0); // 父进程等待\n    }\n    exit(0);\n}\n\nint main(int argc, char *argv[]) {\n    \n    int pipe_fds[2];\n    pipe(pipe_fds);\n\n    if (fork() == 0) {\n        close(pipe_fds[1]); // 子进程无需写入\n        work(pipe_fds);\n    } else {\n        close(pipe_fds[0]); // 父进程无需读入\n        for (int i = 2; i <= 35; i++) {\n            write(pipe_fds[1], &i, sizeof(i)); // 传递数字\n        }\n        close(pipe_fds[1]); // 一定要关闭写入符，否则读第一个质数不会变成 0，那么会一直递归下去了。\n        wait(0); // 一定要等待\n    }\n    exit(0);\n}\n\n\n\n# 4、find\n\n大题内容都是仿照 ls.c 的，具体看注释即可\n\npath 是当前目录的路径，buf 是添加文件名后的路径，每次将文件 cp 到 buf 后面进行判断，如果是 file 且与我们要的文件名相等则输出，如果是目录且不是 . 和 ..，则递归查找下去。\n\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n#include "kernel/fs.h"\n\nvoid fmtpath(char *path) {\n    char *p;\n    for (p = path + strlen(path); p >= path && *p != \'/\'; p--);\n    *(++p) = 0;\n}\n\nvoid find(char *path, char *fn) {\n    char buf[512], *p;\n    int fd;\n    struct dirent de;\n    struct stat st;\n\n    if((fd = open(path, 0)) < 0){\n        fprintf(2, "ls: cannot open %s\\n", path);\n        return;\n    }\n\n    if(fstat(fd, &st) < 0){\n        fprintf(2, "ls: cannot stat %s\\n", path);\n        close(fd);\n        return;\n    }\n\n    // 读取当前路径下的所有数据\n    while (read(fd, &de, sizeof(de)) == sizeof(de)) {\n        strcpy(buf, path);\n        p = buf + strlen(buf);\n        *p++ = \'/\';\n        if (de.inum == 0) {\n            continue;\n        }\n        memcpy(p, de.name, dirsiz); // 将名字加在 buf 后面\n        p[dirsiz] = 0;\n    \n        if (stat(buf, &st) < 0) { \n            fprintf(2, "ls: cannot stat %s\\n", buf);\n        }\n\n        switch(st.type) {\n            case t_file: // 如果是文件\n                if (strcmp(p, fn) == 0) { // 文件名 和 fn 相同则输出\n                    fprintf(1, "%s\\n", buf);\n                }\n                break;\n\n            case t_dir: // 如果是目录\n                if (strcmp(p, ".") != 0 && strcmp(p, "..") != 0) { // 且不是 . 和 ..\n                    find(buf, fn); // 递归查询这个目录\n                }\n        }\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[]) {\n\n    if (argc < 3) {\n        fprintf(2, "find: miss parameter\\n");\n        exit(1);\n    }\n\n    char *path = argv[1]; // path \n    char *fn = argv[2]; // file name\n    find(path, fn);\n\n    exit(0);\n}\n\n\n\n# 5、xargs\n\n注释写的很详细了，主要是从标准输入里面读取参数然后将参数保存，然后创建子进程执行命令。\n\n需要注意的点是每次标准输入中读取完一行的参数后要执行一次命令，并且初始参数不变！！！也就是代码中 init_para 之前的参数每次都要(这里我开始没注意，debug 了好久，也是对 xargs 理解不够吧)\n\n#include "kernel/param.h"\n#include "kernel/types.h"\n#include "kernel/stat.h"\n#include "user/user.h"\n#include "kernel/fs.h"\n\n#define arglen 50\n\nint main(int argc, char *argv[]) {\n\n    char *cmd = argv[1];\n    int n = argc - 1;\n    char *para[maxarg]; // 所有参数\n    for (int i = 0; i < n; i++) {\n        para[i] = argv[i + 1];\n    }\n    char **init_para = para + n; // init_para 指向右边指令参数的末尾\n    char arg[maxarg * arglen]; // 内存池，存放标准输入读取进来的参数\n    char *p = arg; // 用来在 arg 中存储参数，参数之间用 \'\\0\' 分割\n    char ch;\n    int cnt = 0;\n    char **lp = init_para; // lp 用来移动并存储标准输入当前一行的参数\n    while (read(0, &ch, 1) != 0) {\n        if (ch == \' \' || ch == \'\\n\') {\n            *p = 0; // 一个参数或者一行读完，0 分割\n            *lp++ = arg + arglen * cnt; // lp 指向 arg 中当前所有参数存放的末尾\n            cnt++; // 参数个数加一\n            p = arg + arglen * cnt; // p 指向了下一个参数的开头存放的位置\n            \n            if (ch == \'\\n\') { // 如果是换行符，则要执行 exec 了\n                *lp = 0; // para 以 0 为结尾作为参数结束的标志\n                if (fork() == 0) { //创建子进程执行 exec\n                    exec(cmd, para);\n                    exit(0);\n                } else {\n                    wait(0);\n                    lp = init_para; // lp 回到 init_para，重新读取下一行的所有参数\n                }\n            }\n        } else {\n            *p++ = ch;\n        }\n    }\n    exit(0);\n}\n\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"02 - Intermediate Representation(IR)",frontmatter:{title:"02 - Intermediate Representation(IR)",date:"2023-09-22T19:01:04.000Z",permalink:"/pages/6818d5/",tags:["Research","Static Analysis","NJU Course Notes"]},regularPath:"/02.Research/02.Static%20Analysis/01.NJU%20Course%20Notes/02.Intermediate%20Representation(IR).html",relativePath:"02.Research/02.Static Analysis/01.NJU Course Notes/02.Intermediate Representation(IR).md",key:"v-07a99e36",path:"/pages/6818d5/",headers:[{level:3,title:"Compilers and Static Analyzers",slug:"compilers-and-static-analyzers",normalizedTitle:"compilers and static analyzers",charIndex:74},{level:4,title:"Compiler",slug:"compiler",normalizedTitle:"compiler",charIndex:74},{level:3,title:"Abstract Syntax Tree(AST) vs. IR",slug:"abstract-syntax-tree-ast-vs-ir",normalizedTitle:"abstract syntax tree(ast) vs. ir",charIndex:517},{level:4,title:"AST",slug:"ast",normalizedTitle:"ast",charIndex:313},{level:4,title:"IR（三地址码形式）",slug:"ir-三地址码形式",normalizedTitle:"ir（三地址码形式）",charIndex:616},{level:3,title:"IR: Three-Address Code(3AC)",slug:"ir-three-address-code-3ac",normalizedTitle:"ir: three-address code(3ac)",charIndex:697},{level:3,title:"3AC in real Static Analyzer: Soot",slug:"_3ac-in-real-static-analyzer-soot",normalizedTitle:"3ac in real static analyzer: soot",charIndex:978},{level:5,title:"Do-While Loop",slug:"do-while-loop",normalizedTitle:"do-while loop",charIndex:1099},{level:5,title:"Method Call",slug:"method-call",normalizedTitle:"method call",charIndex:1141},{level:5,title:"Class",slug:"class",normalizedTitle:"class",charIndex:1665},{level:3,title:"Static Single Assignment(SSA) 「optional material」",slug:"static-single-assignment-ssa-「optional-material」",normalizedTitle:"static single assignment(ssa) 「optional material」",charIndex:1704},{level:4,title:"什么是 SSA ？",slug:"什么是-ssa",normalizedTitle:"什么是 ssa ？",charIndex:1757},{level:4,title:"SSA 的好处（核心点在于变量名的 distinct）",slug:"ssa-的好处-核心点在于变量名的-distinct",normalizedTitle:"ssa 的好处（核心点在于变量名的 distinct）",charIndex:1829},{level:4,title:"SSA 的坏处",slug:"ssa-的坏处",normalizedTitle:"ssa 的坏处",charIndex:2026},{level:3,title:"Control Flow Analysis",slug:"control-flow-analysis",normalizedTitle:"control flow analysis",charIndex:2070},{level:4,title:"Basic Blocks(BB)",slug:"basic-blocks-bb",normalizedTitle:"basic blocks(bb)",charIndex:2200},{level:5,title:"如何构建 Basic Blocks？",slug:"如何构建-basic-blocks",normalizedTitle:"如何构建 basic blocks？",charIndex:2292},{level:4,title:"构建 Control Flow Graph（CFG)",slug:"构建-control-flow-graph-cfg",normalizedTitle:"构建 control flow graph（cfg)",charIndex:2569},{level:3,title:"需要掌握的重点",slug:"需要掌握的重点",normalizedTitle:"需要掌握的重点",charIndex:3132}],lastUpdated:"9/22/2023, 7:07:10 PM",lastUpdatedTimestamp:169538083e4,headersStr:"Compilers and Static Analyzers Compiler Abstract Syntax Tree(AST) vs. IR AST IR（三地址码形式） IR: Three-Address Code(3AC) 3AC in real Static Analyzer: Soot Do-While Loop Method Call Class Static Single Assignment(SSA) 「optional material」 什么是 SSA ？ SSA 的好处（核心点在于变量名的 distinct） SSA 的坏处 Control Flow Analysis Basic Blocks(BB) 如何构建 Basic Blocks？ 构建 Control Flow Graph（CFG) 需要掌握的重点",content:"# 02 - Intermediate Representation(IR)\n\n> 本系列笔记的课程地址：南京大学《软件分析》课程2020\n\n\n# Compilers and Static Analyzers\n\n# Compiler\n\n流程：\n\n 1. 源码 -> (Scanner；进行词法分析；用到 正则表达式) ->\n\n 2. Tokens -> (Parser；进行语法分析；用到 Context-Free Grammar) ->\n    \n    * Context-Free 上下文无关文法，更适合且足够用于代码\n    \n    * Context-Sensitive 上下文敏感文法，更适合人类语言\n\n 3. AST -> (Type Checker；进行语义分析；用到 Attribute Grammar) ->\n\n 4. Decorated AST -> (Translator) ->\n\n 5. IR -> (Code Generator) ->\n\n 6. Machine Code\n\nIR 之间是编译器前端，IR 之后是编译器后端\n\n静态分析需要在编译器前端生成的 IR 上进行，例如：代码编译优化\n\n\n\n# Abstract Syntax Tree(AST) vs. IR\n\n# AST\n\n * 更接近语法结构；语言相关\n\n * 适合用来做快速的类型检查\n\n * 缺少了控制流信息（看不出来控制流）\n\n# IR（三地址码形式）\n\n * 更接近汇编、机器语言；语言无关\n\n * 紧凑且统一\n\n * 包含了控制流信息\n\n * 通常被用来作为静态分析的基础\n   \n\n\n# IR: Three-Address Code(3AC)\n\n3-Address Code(3AC)：一条指令右边最多只有一个运算符\n\n每个三地址码指令包含最多 3 个 addresses\n\n * Address 可以是\n   \n   1. Name：a, b\n   \n   2. Constant：3\n   \n   3. Compiler-generated temporary：t1，t2\n\n * eg. a + b + 3 -> t1 = a + b; t2 = t1 + 3;\n\n每一种指令都有自己的 3AC Form，下面是一个常见的三地址码：\n\n\n\n# 3AC in real Static Analyzer: Soot\n\n * Soot 是 Java 领域非常常用的静态分析框架\n\n * Soot 的 IR 是 Jimple（三地址码形式的）\n\n下面是一些 Jimple 的例子\n\n 1. # Do-While Loop\n    \n\n * 「$」 标注了临时变量\n\n 2. # Method Call\n    \n\n * JVM 中的四种 invoke 调用\n   \n   * invoke speciall：call constructor、call superclass(父类) methods、call private methods\n   \n   * invoke virtual：call instance methods(virtual dispatch，虚函数查表，即会先从调用该方法的对象的类实现中找，找不到再去父类找)\n   \n   * invoke interface：类似 invoke virtual，但不做优化，且会进行 checking interface implementation(实现接口时方法时候都实现了)\n   \n   * invoke static：call static methods\n   \n   * Java 7 还引入了 invoke dynamic\n\n * <...> 尖括号里的是 method signature：\n   \n   * [class name]: [return type] [method name](parameter type...)\n\n 3. # Class\n    \n\n * clinit 是对静态变量的初始化方法\n\n\n# Static Single Assignment(SSA) 「optional material」\n\n# 什么是 SSA ？\n\n\n * 需要记住的两点特征：1. 每个变量都有个准确的定义、名字；2. 当变量名有多种可能性时，会引入 来进行合并\n\n# SSA 的好处（核心点在于变量名的 distinct）\n\n * 程序流可以被间接的融入在 unique variable names 中\n   \n   * 携带了更多信息，可以帮助提供一些更简单的分析，例如：flow-insensitive analysis 可以无需提高 cost 就能获取部分 flow-sensitive analysis 的精度\n\n * 定义与使用更为清楚、明确\n\n# SSA 的坏处\n\n * 引入更多变量和 函数\n\n * 导致一些性能问题\n   \n\n\n# Control Flow Analysis\n\n * 一般指建立控制流图 Control Flow Graph（CFG)\n\n * CFG 是静态分析的基础结构\n\n * CFG 中的 node 可以是一个三地址码指令，或者通常是一个 Basic Block\n\n# Basic Blocks(BB)\n\nBB 是连续三地址码指令的最大序列，且满足 1. 入口唯一(第一条指令)；2. 出口唯一(最后一条指令)\n\n这里的入口和出口指的是一条语句\n\n\n# 如何构建 Basic Blocks？\n\n * 输入：P 的三地址码序列\n\n * 输出：P 的 BB 列表\n\n * 算法：\n   \n   1. 决定 P 的入口\n      \n      * P 的第一条语句一定是入口\n      \n      * 跳转命令的 target 指令一定是入口\n      \n      * 跳转命令后紧跟的一条语句也一定是入口（因为跳转命令一定是唯一的出口）\n   \n   2. 构建 P 的 BBs\n      \n      * 一个 BB 包含了一个入口和直到下一个入口前的所有子序列指令\n\n * eg：\n   \n\n# 构建 Control Flow Graph（CFG)\n\n * CFG 的每个 node 是一个 BB\n\n * 连接一条 from A to B 的边，需要且仅需要满足下面的条件\n   \n   * A 的出口有一个条件跳转或无条件跳转到 B 的入口\n   \n   * B 按指令初始顺序紧跟在 A 的后面，且 A 的出口不是一条无条件跳转（如下图右一为例，(j) goto (i) 是无跳转指令，A 不能连边到 B）\n     \n\n * 替换指令 label 的跳转为 BB 的跳转\n   \n\n * A 到 B 有一条边，则我们称 A 是 B 的前驱 predecessor，B 是 A 的后继 successor\n\n * 我们还要添加两个特殊节点，Entry 和 Exit\n   \n   * 他们与可执行 IR 无关，引入只是为了方便后续静态分析算法设计的初始化\n   \n   * Entry 节点连了一条边到包含了 IR 的第一条指令的 BB（本课程中 Entry 只有一条，例如多线程下可能有多个 Entry）\n   \n   * Exit 节点作为后继，与任何包含了 IR 的最后一条指令的 BB 相连，可能有多条边\n     \n\n * 【Input：3AC of P】 -> 【Output：CFG of P】\n\n\n# 需要掌握的重点\n\n 1. 理解编译器和静态分析的关系\n\n 2. 理解 3AC 和他的常见形式（in IR Jimple）\n\n 3. 如何在 IR 上构建 Basic Blocks\n\n 4. 在 Basic Blocks 上构建控制流图",normalizedContent:"# 02 - intermediate representation(ir)\n\n> 本系列笔记的课程地址：南京大学《软件分析》课程2020\n\n\n# compilers and static analyzers\n\n# compiler\n\n流程：\n\n 1. 源码 -> (scanner；进行词法分析；用到 正则表达式) ->\n\n 2. tokens -> (parser；进行语法分析；用到 context-free grammar) ->\n    \n    * context-free 上下文无关文法，更适合且足够用于代码\n    \n    * context-sensitive 上下文敏感文法，更适合人类语言\n\n 3. ast -> (type checker；进行语义分析；用到 attribute grammar) ->\n\n 4. decorated ast -> (translator) ->\n\n 5. ir -> (code generator) ->\n\n 6. machine code\n\nir 之间是编译器前端，ir 之后是编译器后端\n\n静态分析需要在编译器前端生成的 ir 上进行，例如：代码编译优化\n\n\n\n# abstract syntax tree(ast) vs. ir\n\n# ast\n\n * 更接近语法结构；语言相关\n\n * 适合用来做快速的类型检查\n\n * 缺少了控制流信息（看不出来控制流）\n\n# ir（三地址码形式）\n\n * 更接近汇编、机器语言；语言无关\n\n * 紧凑且统一\n\n * 包含了控制流信息\n\n * 通常被用来作为静态分析的基础\n   \n\n\n# ir: three-address code(3ac)\n\n3-address code(3ac)：一条指令右边最多只有一个运算符\n\n每个三地址码指令包含最多 3 个 addresses\n\n * address 可以是\n   \n   1. name：a, b\n   \n   2. constant：3\n   \n   3. compiler-generated temporary：t1，t2\n\n * eg. a + b + 3 -> t1 = a + b; t2 = t1 + 3;\n\n每一种指令都有自己的 3ac form，下面是一个常见的三地址码：\n\n\n\n# 3ac in real static analyzer: soot\n\n * soot 是 java 领域非常常用的静态分析框架\n\n * soot 的 ir 是 jimple（三地址码形式的）\n\n下面是一些 jimple 的例子\n\n 1. # do-while loop\n    \n\n * 「$」 标注了临时变量\n\n 2. # method call\n    \n\n * jvm 中的四种 invoke 调用\n   \n   * invoke speciall：call constructor、call superclass(父类) methods、call private methods\n   \n   * invoke virtual：call instance methods(virtual dispatch，虚函数查表，即会先从调用该方法的对象的类实现中找，找不到再去父类找)\n   \n   * invoke interface：类似 invoke virtual，但不做优化，且会进行 checking interface implementation(实现接口时方法时候都实现了)\n   \n   * invoke static：call static methods\n   \n   * java 7 还引入了 invoke dynamic\n\n * <...> 尖括号里的是 method signature：\n   \n   * [class name]: [return type] [method name](parameter type...)\n\n 3. # class\n    \n\n * clinit 是对静态变量的初始化方法\n\n\n# static single assignment(ssa) 「optional material」\n\n# 什么是 ssa ？\n\n\n * 需要记住的两点特征：1. 每个变量都有个准确的定义、名字；2. 当变量名有多种可能性时，会引入 来进行合并\n\n# ssa 的好处（核心点在于变量名的 distinct）\n\n * 程序流可以被间接的融入在 unique variable names 中\n   \n   * 携带了更多信息，可以帮助提供一些更简单的分析，例如：flow-insensitive analysis 可以无需提高 cost 就能获取部分 flow-sensitive analysis 的精度\n\n * 定义与使用更为清楚、明确\n\n# ssa 的坏处\n\n * 引入更多变量和 函数\n\n * 导致一些性能问题\n   \n\n\n# control flow analysis\n\n * 一般指建立控制流图 control flow graph（cfg)\n\n * cfg 是静态分析的基础结构\n\n * cfg 中的 node 可以是一个三地址码指令，或者通常是一个 basic block\n\n# basic blocks(bb)\n\nbb 是连续三地址码指令的最大序列，且满足 1. 入口唯一(第一条指令)；2. 出口唯一(最后一条指令)\n\n这里的入口和出口指的是一条语句\n\n\n# 如何构建 basic blocks？\n\n * 输入：p 的三地址码序列\n\n * 输出：p 的 bb 列表\n\n * 算法：\n   \n   1. 决定 p 的入口\n      \n      * p 的第一条语句一定是入口\n      \n      * 跳转命令的 target 指令一定是入口\n      \n      * 跳转命令后紧跟的一条语句也一定是入口（因为跳转命令一定是唯一的出口）\n   \n   2. 构建 p 的 bbs\n      \n      * 一个 bb 包含了一个入口和直到下一个入口前的所有子序列指令\n\n * eg：\n   \n\n# 构建 control flow graph（cfg)\n\n * cfg 的每个 node 是一个 bb\n\n * 连接一条 from a to b 的边，需要且仅需要满足下面的条件\n   \n   * a 的出口有一个条件跳转或无条件跳转到 b 的入口\n   \n   * b 按指令初始顺序紧跟在 a 的后面，且 a 的出口不是一条无条件跳转（如下图右一为例，(j) goto (i) 是无跳转指令，a 不能连边到 b）\n     \n\n * 替换指令 label 的跳转为 bb 的跳转\n   \n\n * a 到 b 有一条边，则我们称 a 是 b 的前驱 predecessor，b 是 a 的后继 successor\n\n * 我们还要添加两个特殊节点，entry 和 exit\n   \n   * 他们与可执行 ir 无关，引入只是为了方便后续静态分析算法设计的初始化\n   \n   * entry 节点连了一条边到包含了 ir 的第一条指令的 bb（本课程中 entry 只有一条，例如多线程下可能有多个 entry）\n   \n   * exit 节点作为后继，与任何包含了 ir 的最后一条指令的 bb 相连，可能有多条边\n     \n\n * 【input：3ac of p】 -> 【output：cfg of p】\n\n\n# 需要掌握的重点\n\n 1. 理解编译器和静态分析的关系\n\n 2. 理解 3ac 和他的常见形式（in ir jimple）\n\n 3. 如何在 ir 上构建 basic blocks\n\n 4. 在 basic blocks 上构建控制流图",charsets:{cjk:!0}},{title:"[MIT6.S081]Lab10: Mmap",frontmatter:{title:null,date:"2023-02-24T20:38:13.000Z",permalink:"/pages/4708e0/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/010.Lab10:%20Mmap.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/010.Lab10: Mmap.md",key:"v-08d656b6",path:"/pages/4708e0/",headers:[{level:2,title:"mmap",slug:"mmap",normalizedTitle:"mmap",charIndex:31},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:6587},{level:3,title:"课程实验总结",slug:"课程实验总结",normalizedTitle:"课程实验总结",charIndex:6597}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"mmap 实验结果 课程实验总结",content:'# [MIT6.S081]Lab10: Mmap\n\nLab: mmap (mit.edu)\n\n\n# mmap\n\n最后一个 lab，也是最后一个 assignment🌟！\n\n我们要实现一个简易版的 mmap 和 munmap，具体的 mmap 可以查看手册 man 2 mmap，非常简单易读。\n\n简单来说 mmap 可以在一个文件描述符和一段虚拟地址之间建立起映射，而 munmap 可以解除这个映射，而在本实验中我们将专注于 memory-mapped files。\n\n而 mmap 又分 shared 映射 和 private 映射，我们知道可以将一个文件映射到多个进程的地址空间。如果此时是 shared 映射，那么我们会对该文件的修改会实际写回文件，那么不同进程都会接收到这一修改；而如果是 private 映射，那么就类似于写时复制 copy-on-write，当一个进程修改这部分内容后会拷贝独立的一份，这是对其他进程不可见的。不过在实验文档里说明了在本实验中如果被 shared 映射的文件是可以不共享物理页的。\n\n另外在本实验中，第一个参数 void *addr 我们默认为 0，也就是 NULL，要求内核自己寻找合适的位置来进行映射，同时第六个参数 off_t offset 我们也默认为 0。\n\n与此同时，每个进程中都维护了一段线性空间 VMA (Virtual Memory Area)，其用来描述了虚拟空间的一些属性，在这里我们用它来描述不同虚拟地址的大小以及映射关系等信息。\n\n我们先在 proc.h 中添加这部分内容\n\nstruct vma {\n  int valid; // 0 表示空闲，1 表示不空闲\n  uint64 addr; // 一段虚拟地址的起始点\n  int len; // 这段虚拟地址的长度\n  int offset; // 映射的偏移量\n  int prot; // protection，标记读写执行权限\n  int flags; // flags，比如标记文件是共享文件，还是私有文件 \n  struct file *f;\n};\n\nstruct proc {\n// ......\n  struct vma vmas[NVMA];\n};\n\n\n\n接着我们要添加两个系统调用 sys_mmap 和 sys_munmap，具体添加流程可以看之前的记录，这里不再阐述。\n\n我们先开始实现 sys_mmap，我们要选用一段合适的虚拟空间来和文件进行映射，我们直接用 p->sz 作为起点，随后每添加一次映射，我们就令 p->sz += len。所以我们就先遍历 vmas 数组，找到一个空闲的 vma，接着填入一些参数即可。\n\nuint64 sys_mmap(void) {\n  int len, prot, flags, fd;\n  struct file *f;\n\n  if (argint(1, &len) < 0 || argint(2, &prot) < 0 || argint(3, &flags) < 0 || argfd(4, &fd, &f) < 0) { // 获取参数\n    return -1;\n  }\n\n  if ((!f->readable && (prot & PROT_READ)) || ((flags & MAP_SHARED) && (!f->writable && (prot & PROT_WRITE)))) { // 共享文件要检查权限位一致\n    return -1;\n  }\n\n  struct proc *p = myproc();\n  struct vma *vma = p->vmas;\n\n  for (int i = 0; i < NVMA; i++) {\n    if (vma[i].valid == 0) { // 找到一个空闲的 VMA\n      vma[i].valid = 1;\n      vma[i].addr = p->sz;\n      vma[i].len = PGROUNDUP(len); // page-aligned\n      p->sz += vma[i].len;\n      vma[i].flags = flags;\n      vma[i].prot = prot;\n      vma[i].f = filedup(f);\n      return vma[i].addr;\n    }\n  }\n  return -1;\n}\n\n\n需要注意的是，我们还要检查 prot 与文件的权限是否一致，并对 shared 文件进行特殊检查。\n\n建立完映射后，当产生 page fault 时我们才会实际去分配页面，类似于 lazy allocation (不过 2021 的 lab 里没有这个实验，估计是和 mmap lab 合并了)\n\n这里的处理方式我参考了 [mit6.s081] 笔记 Lab10: Mmap | 文件内存映射 | Miigon\'s blog，模块化的写法感觉简洁很多，好处理很多。\n\n// trap.c\nvoid usertrap(void) {\n// ......\n  } else if((which_dev = devintr()) != 0){\n    // ok\n  } else if (r_scause() == 13 || r_scause() == 15) { // 处理 page fault \n    uint64 va = r_stval();\n    if (!vmalazyload(va)) {\n      goto error;\n    }\n  } else {\n    error:\n    printf("usertrap(): unexpected scause %p pid=%d\\n", r_scause(), p->pid);\n    printf("            sepc=%p stval=%p\\n", r_sepc(), r_stval());\n    p->killed = 1;\n  }\n// ......\n}\n\n\nstruct vma *findvma(struct proc *p, uint64 va) {\n  for (int i = 0; i < NVMA; i++) {\n    struct vma *vma   = p->vmas + i;\n    if (vma->valid == 1 && vma->addr <= va && vma->addr + vma->len > va) { // va 在其所属范围内\n      return vma;\n    }\n  }\n  return 0;\n}\n\nint vmalazyload(uint64 va) {\n  struct proc *p = myproc();\n  struct vma *vma = findvma(p, va); // 找 va 所在的合法的 vma\n  if (vma == 0) {\n    return 0;\n  }\n\n  // 分配物理页\n  void *pa = kalloc();\n  if (pa == 0) {\n    panic("vmalazyload: kalloc");\n  }\n  memset(pa, 0, PGSIZE);\n\n  // 从文件中读取数据到 pa 里\n  struct inode *ip = vma->f->ip;\n  begin_op();\n  ilock(ip);\n  readi(ip, 0, (uint64)pa, vma->offset + va - vma->addr, PGSIZE);\n  iunlock(ip);\n  end_op();\n\n  //进行映射，先设置权限位\n  uint flags = PTE_U;\n  if (vma->prot & PROT_READ) {\n    flags |= PTE_R;\n  }\n  if (vma->prot & PROT_WRITE) {\n    flags |= PTE_W;\n  }\n  if (vma->prot & PROT_EXEC) {\n    flags |= PTE_X;\n  }\n\n  if (mappages(p->pagetable, va, PGSIZE, (uint64)pa, flags) < 0) {\n    panic("vmalazyload: mappages"); \n  }\n\n  return 1;\n}\n\n\nfindvma() 函数根据传入的 va，找到一个合法的 vma，并且满足 va 在 vma 指向的虚拟空间内。\n\n在找到 vma 后我们要先实际的分配一块物理内存，然后将被映射的文件的内容拷贝到其中，最后我们设置权限以及添加映射。\n\n如此一来我们的 mmap 部分就是实现完了，下面是 munmap 部分\n\n这部分实现思路上有参考 xv6-labs-2020.lab9.mmap | Banbao (banbao991.github.io)\n\n不过在分类讨论的地方可以进一步细化，但本实验并不需要）\n\n在找到 vma 后，我们先将 addr 和 len 进行页对齐，接着我分为了两种情况，一种是整个空间全部正好释放，而其他情况我们又分为是否从头开始 unmap。\n\n对于全部释放，则我们要关闭 vma->f，具体引用计数的讨论可以查看 fileclose() 函数的源码。\n\n而其他情况中，如果释放从头开始，则我们要额外修改 vma->addr ，也就是虚拟空间的起始点。而最后我们如果文件是 shared 映射的话，我们还要把当前修改写回文件。\n\nuint64 sys_munmap(void) {\n  uint64 addr;\n  int len;\n\n  if (argaddr(0, &addr) < 0 || argint(1, &len) < 0) {\n    return -1;\n  }\n\n  struct proc *p = myproc();\n  struct vma *vma = findvma(p, addr);\n  if (vma == 0) {\n    return -1;\n  }\n\n  uint64 va = (uint64)addr;\n  len += va - PGROUNDDOWN(va);\n  va = PGROUNDDOWN(va); // page-aligned\n  int offset = vma->offset;\n  int flag = 0; // 记录是否要关闭文件\n  if (addr == vma->addr && len == vma->len) { // 全部释放\n      vma->len = 0;\n      flag = 1;\n  } else {\n    vma->len -= len;\n    if (va == vma->addr) { // 从头释放\n      vma->addr += len;\n    }\n  }\n\n  if (vma->flags & MAP_SHARED) {\n    if (filewrite_offset(vma->f, va, len, offset) == 0) {\n      return -1;\n    }\n  }\n\n  if (walkaddr(p->pagetable, va) != 0) { // 如果映射了\n    uvmunmap(p->pagetable, va, len / PGSIZE, 0);\n  }\n  if (flag) {\n    fileclose(vma->f);\n  }\n\n  return 0;\n} \n\n\nfilewrite_offset() 函数的实现可以直接抄 filewrite 的源码，但需要注意修改一下 offset，并且确保文件类型是 FD_INODE\n\nint filewrite_offset(struct file *f, uint64 addr, int n, int offset) {\n  int r, ret = 0;\n\n  if (f->writable == 0)\n    return 0;\n\n  if (f->type == FD_INODE) {\n    // write a few blocks at a time to avoid exceeding\n    // the maximum log transaction size, including\n    // i-node, indirect block, allocation blocks,\n    // and 2 blocks of slop for non-aligned writes.\n    // this really belongs lower down, since writei()\n    // might be writing a device like the console.\n    int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;\n    int i = 0;\n    while(i < n){\n      int n1 = n - i;\n      if(n1 > max)\n        n1 = max;\n\n      begin_op();\n      ilock(f->ip);\n      if ((r = writei(f->ip, 1, addr + i, offset, n1)) > 0)\n        offset += r;\n      iunlock(f->ip);\n      end_op();\n\n      if(r != n1) {\n        // error from writei\n        break;\n      }\n      i += r;\n    }\n    ret = (i == n ? n : -1);\n  } else {\n    panic("filewrite");\n  }\n\n  return ret;\n}\n\n\n这样 unmap 也基本实现了，但我们还要按照文档的 hints 修改一下 exit() 以及 fork()，以确保进程结束后其相关映射都会解除以及 fork 出子进程后，子进程有着一模一样的映射，当然引用计数还要自增一。\n\nvoid exit(int status) {\n// ......\n  for (int i = 0; i < NVMA; i++) {\n    struct vma *vma = p->vmas + i;\n    if (vma->len) {\n      uvmunmap(p->pagetable, vma->addr, vma->len / PGSIZE, 0);\n      vma->len = 0;\n    }\n  }\n// ......\n}\n\n\nint fork(void) {\n// ......\n  for (int i = 0; i < NVMA; i++) {\n    struct vma *vma = p->vmas + i;\n    if (vma->len) {\n      memmove(np->vmas + i, vma, sizeof(struct vma));\n      filedup(vma->f);\n    } else {\n      (np->vmas + i)->len = 0;\n    }\n  }\n\n  return pid;\n}\n\n\n本实验到此结束！\n\n\n# 实验结果\n\n\n\n# 课程实验总结\n\n在做 MIT6.S081 这门课程的 lab 之前，我并没有看过其官方课程，所以在做 lab 的过程中挺折磨的，遇到英文的官方文档说实话也不是很能读下去，经常会去网上找其他的中文资料(感觉在读手册这方面自己还得再加把劲)。\n\n个人感觉 2021 的 lab 会比 2020 更加精简一点，感觉 20 版的会更好点，不过大差也不差。\n\n在做实验之前，我是粗略地过过一遍蒋炎岩老师的课，已经看过 csapp，所以也不算零基础，还是在对 os 有一定理解的基础上做的吧，做完所有 lab 之后也确实感觉对操作系统有了更进一步感受，不过目前还有系统地读过一本 os 方面专门的书，目前是打算后面再刷一遍蒋炎岩老师 2023 年的课，并且顺带读一遍 OSTEP，希望自己能坚持读完英语版的，不过中文版的自己倒是有。当然最近还买了本交大 IPADS 组写的银杏书，像在进一步深入一下，就是可能得安排到大三上了。\n\n所有实验中让我影响最深刻的其实是系统调用，虽然并不难实现，但因为之前听课一直会听到这个词，lab 做完后确实让我对系统调用有了个非常实际性的理解，而不仅仅停留在纸面上，不过自己在 networking 和 file system 上感觉掌握的不是很好，是后面要花时间补的。\n\n不管怎么说，mit 的 lab 都让我确实有了很好的体验，设计精妙的 xv6，一环扣一环的 lab，还有这如此丰富详尽的文档，当然还有很重要且友好的本地 test！我看了部分的课程视频，老师也讲的非常清晰 (%%% Morris教授)\n\n老实说，做 lab 的过程中我多么希望自己学校的课程也是如此精彩，多么希望我以及无数计算机专业的学子可以不用去国外名校寻找课程资源，而是在自己的学校课程中收获满满......这个学期大二下，我有计组和计网两门计算机专业课，听了后感觉真的非常应试，我在想如果是不考研的同学，听了这个课程刷了很多应试题，一行代码不写一学期下来真的能学到什么吗...在这种答辩的环境中真的好窒息，自己也只能像逆行者一样，与别人格格不入。\n\n不过最近自己拉了个小群，希望能带着大伙尽可能的跳出国内的教学方案，避免成为做了大量无用功的理论做题小子，而是去接触更新更精彩的计算机世界，学到真本事，也期待着国内会涌现出更多类似于蒋炎岩老师的操作系统课程，交大 IPADS 组的银杏书这类优秀的学习资源。',normalizedContent:'# [mit6.s081]lab10: mmap\n\nlab: mmap (mit.edu)\n\n\n# mmap\n\n最后一个 lab，也是最后一个 assignment🌟！\n\n我们要实现一个简易版的 mmap 和 munmap，具体的 mmap 可以查看手册 man 2 mmap，非常简单易读。\n\n简单来说 mmap 可以在一个文件描述符和一段虚拟地址之间建立起映射，而 munmap 可以解除这个映射，而在本实验中我们将专注于 memory-mapped files。\n\n而 mmap 又分 shared 映射 和 private 映射，我们知道可以将一个文件映射到多个进程的地址空间。如果此时是 shared 映射，那么我们会对该文件的修改会实际写回文件，那么不同进程都会接收到这一修改；而如果是 private 映射，那么就类似于写时复制 copy-on-write，当一个进程修改这部分内容后会拷贝独立的一份，这是对其他进程不可见的。不过在实验文档里说明了在本实验中如果被 shared 映射的文件是可以不共享物理页的。\n\n另外在本实验中，第一个参数 void *addr 我们默认为 0，也就是 null，要求内核自己寻找合适的位置来进行映射，同时第六个参数 off_t offset 我们也默认为 0。\n\n与此同时，每个进程中都维护了一段线性空间 vma (virtual memory area)，其用来描述了虚拟空间的一些属性，在这里我们用它来描述不同虚拟地址的大小以及映射关系等信息。\n\n我们先在 proc.h 中添加这部分内容\n\nstruct vma {\n  int valid; // 0 表示空闲，1 表示不空闲\n  uint64 addr; // 一段虚拟地址的起始点\n  int len; // 这段虚拟地址的长度\n  int offset; // 映射的偏移量\n  int prot; // protection，标记读写执行权限\n  int flags; // flags，比如标记文件是共享文件，还是私有文件 \n  struct file *f;\n};\n\nstruct proc {\n// ......\n  struct vma vmas[nvma];\n};\n\n\n\n接着我们要添加两个系统调用 sys_mmap 和 sys_munmap，具体添加流程可以看之前的记录，这里不再阐述。\n\n我们先开始实现 sys_mmap，我们要选用一段合适的虚拟空间来和文件进行映射，我们直接用 p->sz 作为起点，随后每添加一次映射，我们就令 p->sz += len。所以我们就先遍历 vmas 数组，找到一个空闲的 vma，接着填入一些参数即可。\n\nuint64 sys_mmap(void) {\n  int len, prot, flags, fd;\n  struct file *f;\n\n  if (argint(1, &len) < 0 || argint(2, &prot) < 0 || argint(3, &flags) < 0 || argfd(4, &fd, &f) < 0) { // 获取参数\n    return -1;\n  }\n\n  if ((!f->readable && (prot & prot_read)) || ((flags & map_shared) && (!f->writable && (prot & prot_write)))) { // 共享文件要检查权限位一致\n    return -1;\n  }\n\n  struct proc *p = myproc();\n  struct vma *vma = p->vmas;\n\n  for (int i = 0; i < nvma; i++) {\n    if (vma[i].valid == 0) { // 找到一个空闲的 vma\n      vma[i].valid = 1;\n      vma[i].addr = p->sz;\n      vma[i].len = pgroundup(len); // page-aligned\n      p->sz += vma[i].len;\n      vma[i].flags = flags;\n      vma[i].prot = prot;\n      vma[i].f = filedup(f);\n      return vma[i].addr;\n    }\n  }\n  return -1;\n}\n\n\n需要注意的是，我们还要检查 prot 与文件的权限是否一致，并对 shared 文件进行特殊检查。\n\n建立完映射后，当产生 page fault 时我们才会实际去分配页面，类似于 lazy allocation (不过 2021 的 lab 里没有这个实验，估计是和 mmap lab 合并了)\n\n这里的处理方式我参考了 [mit6.s081] 笔记 lab10: mmap | 文件内存映射 | miigon\'s blog，模块化的写法感觉简洁很多，好处理很多。\n\n// trap.c\nvoid usertrap(void) {\n// ......\n  } else if((which_dev = devintr()) != 0){\n    // ok\n  } else if (r_scause() == 13 || r_scause() == 15) { // 处理 page fault \n    uint64 va = r_stval();\n    if (!vmalazyload(va)) {\n      goto error;\n    }\n  } else {\n    error:\n    printf("usertrap(): unexpected scause %p pid=%d\\n", r_scause(), p->pid);\n    printf("            sepc=%p stval=%p\\n", r_sepc(), r_stval());\n    p->killed = 1;\n  }\n// ......\n}\n\n\nstruct vma *findvma(struct proc *p, uint64 va) {\n  for (int i = 0; i < nvma; i++) {\n    struct vma *vma   = p->vmas + i;\n    if (vma->valid == 1 && vma->addr <= va && vma->addr + vma->len > va) { // va 在其所属范围内\n      return vma;\n    }\n  }\n  return 0;\n}\n\nint vmalazyload(uint64 va) {\n  struct proc *p = myproc();\n  struct vma *vma = findvma(p, va); // 找 va 所在的合法的 vma\n  if (vma == 0) {\n    return 0;\n  }\n\n  // 分配物理页\n  void *pa = kalloc();\n  if (pa == 0) {\n    panic("vmalazyload: kalloc");\n  }\n  memset(pa, 0, pgsize);\n\n  // 从文件中读取数据到 pa 里\n  struct inode *ip = vma->f->ip;\n  begin_op();\n  ilock(ip);\n  readi(ip, 0, (uint64)pa, vma->offset + va - vma->addr, pgsize);\n  iunlock(ip);\n  end_op();\n\n  //进行映射，先设置权限位\n  uint flags = pte_u;\n  if (vma->prot & prot_read) {\n    flags |= pte_r;\n  }\n  if (vma->prot & prot_write) {\n    flags |= pte_w;\n  }\n  if (vma->prot & prot_exec) {\n    flags |= pte_x;\n  }\n\n  if (mappages(p->pagetable, va, pgsize, (uint64)pa, flags) < 0) {\n    panic("vmalazyload: mappages"); \n  }\n\n  return 1;\n}\n\n\nfindvma() 函数根据传入的 va，找到一个合法的 vma，并且满足 va 在 vma 指向的虚拟空间内。\n\n在找到 vma 后我们要先实际的分配一块物理内存，然后将被映射的文件的内容拷贝到其中，最后我们设置权限以及添加映射。\n\n如此一来我们的 mmap 部分就是实现完了，下面是 munmap 部分\n\n这部分实现思路上有参考 xv6-labs-2020.lab9.mmap | banbao (banbao991.github.io)\n\n不过在分类讨论的地方可以进一步细化，但本实验并不需要）\n\n在找到 vma 后，我们先将 addr 和 len 进行页对齐，接着我分为了两种情况，一种是整个空间全部正好释放，而其他情况我们又分为是否从头开始 unmap。\n\n对于全部释放，则我们要关闭 vma->f，具体引用计数的讨论可以查看 fileclose() 函数的源码。\n\n而其他情况中，如果释放从头开始，则我们要额外修改 vma->addr ，也就是虚拟空间的起始点。而最后我们如果文件是 shared 映射的话，我们还要把当前修改写回文件。\n\nuint64 sys_munmap(void) {\n  uint64 addr;\n  int len;\n\n  if (argaddr(0, &addr) < 0 || argint(1, &len) < 0) {\n    return -1;\n  }\n\n  struct proc *p = myproc();\n  struct vma *vma = findvma(p, addr);\n  if (vma == 0) {\n    return -1;\n  }\n\n  uint64 va = (uint64)addr;\n  len += va - pgrounddown(va);\n  va = pgrounddown(va); // page-aligned\n  int offset = vma->offset;\n  int flag = 0; // 记录是否要关闭文件\n  if (addr == vma->addr && len == vma->len) { // 全部释放\n      vma->len = 0;\n      flag = 1;\n  } else {\n    vma->len -= len;\n    if (va == vma->addr) { // 从头释放\n      vma->addr += len;\n    }\n  }\n\n  if (vma->flags & map_shared) {\n    if (filewrite_offset(vma->f, va, len, offset) == 0) {\n      return -1;\n    }\n  }\n\n  if (walkaddr(p->pagetable, va) != 0) { // 如果映射了\n    uvmunmap(p->pagetable, va, len / pgsize, 0);\n  }\n  if (flag) {\n    fileclose(vma->f);\n  }\n\n  return 0;\n} \n\n\nfilewrite_offset() 函数的实现可以直接抄 filewrite 的源码，但需要注意修改一下 offset，并且确保文件类型是 fd_inode\n\nint filewrite_offset(struct file *f, uint64 addr, int n, int offset) {\n  int r, ret = 0;\n\n  if (f->writable == 0)\n    return 0;\n\n  if (f->type == fd_inode) {\n    // write a few blocks at a time to avoid exceeding\n    // the maximum log transaction size, including\n    // i-node, indirect block, allocation blocks,\n    // and 2 blocks of slop for non-aligned writes.\n    // this really belongs lower down, since writei()\n    // might be writing a device like the console.\n    int max = ((maxopblocks-1-1-2) / 2) * bsize;\n    int i = 0;\n    while(i < n){\n      int n1 = n - i;\n      if(n1 > max)\n        n1 = max;\n\n      begin_op();\n      ilock(f->ip);\n      if ((r = writei(f->ip, 1, addr + i, offset, n1)) > 0)\n        offset += r;\n      iunlock(f->ip);\n      end_op();\n\n      if(r != n1) {\n        // error from writei\n        break;\n      }\n      i += r;\n    }\n    ret = (i == n ? n : -1);\n  } else {\n    panic("filewrite");\n  }\n\n  return ret;\n}\n\n\n这样 unmap 也基本实现了，但我们还要按照文档的 hints 修改一下 exit() 以及 fork()，以确保进程结束后其相关映射都会解除以及 fork 出子进程后，子进程有着一模一样的映射，当然引用计数还要自增一。\n\nvoid exit(int status) {\n// ......\n  for (int i = 0; i < nvma; i++) {\n    struct vma *vma = p->vmas + i;\n    if (vma->len) {\n      uvmunmap(p->pagetable, vma->addr, vma->len / pgsize, 0);\n      vma->len = 0;\n    }\n  }\n// ......\n}\n\n\nint fork(void) {\n// ......\n  for (int i = 0; i < nvma; i++) {\n    struct vma *vma = p->vmas + i;\n    if (vma->len) {\n      memmove(np->vmas + i, vma, sizeof(struct vma));\n      filedup(vma->f);\n    } else {\n      (np->vmas + i)->len = 0;\n    }\n  }\n\n  return pid;\n}\n\n\n本实验到此结束！\n\n\n# 实验结果\n\n\n\n# 课程实验总结\n\n在做 mit6.s081 这门课程的 lab 之前，我并没有看过其官方课程，所以在做 lab 的过程中挺折磨的，遇到英文的官方文档说实话也不是很能读下去，经常会去网上找其他的中文资料(感觉在读手册这方面自己还得再加把劲)。\n\n个人感觉 2021 的 lab 会比 2020 更加精简一点，感觉 20 版的会更好点，不过大差也不差。\n\n在做实验之前，我是粗略地过过一遍蒋炎岩老师的课，已经看过 csapp，所以也不算零基础，还是在对 os 有一定理解的基础上做的吧，做完所有 lab 之后也确实感觉对操作系统有了更进一步感受，不过目前还有系统地读过一本 os 方面专门的书，目前是打算后面再刷一遍蒋炎岩老师 2023 年的课，并且顺带读一遍 ostep，希望自己能坚持读完英语版的，不过中文版的自己倒是有。当然最近还买了本交大 ipads 组写的银杏书，像在进一步深入一下，就是可能得安排到大三上了。\n\n所有实验中让我影响最深刻的其实是系统调用，虽然并不难实现，但因为之前听课一直会听到这个词，lab 做完后确实让我对系统调用有了个非常实际性的理解，而不仅仅停留在纸面上，不过自己在 networking 和 file system 上感觉掌握的不是很好，是后面要花时间补的。\n\n不管怎么说，mit 的 lab 都让我确实有了很好的体验，设计精妙的 xv6，一环扣一环的 lab，还有这如此丰富详尽的文档，当然还有很重要且友好的本地 test！我看了部分的课程视频，老师也讲的非常清晰 (%%% morris教授)\n\n老实说，做 lab 的过程中我多么希望自己学校的课程也是如此精彩，多么希望我以及无数计算机专业的学子可以不用去国外名校寻找课程资源，而是在自己的学校课程中收获满满......这个学期大二下，我有计组和计网两门计算机专业课，听了后感觉真的非常应试，我在想如果是不考研的同学，听了这个课程刷了很多应试题，一行代码不写一学期下来真的能学到什么吗...在这种答辩的环境中真的好窒息，自己也只能像逆行者一样，与别人格格不入。\n\n不过最近自己拉了个小群，希望能带着大伙尽可能的跳出国内的教学方案，避免成为做了大量无用功的理论做题小子，而是去接触更新更精彩的计算机世界，学到真本事，也期待着国内会涌现出更多类似于蒋炎岩老师的操作系统课程，交大 ipads 组的银杏书这类优秀的学习资源。',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab2: System Calls",frontmatter:{title:null,date:"2023-02-06T12:26:04.000Z",permalink:"/pages/e84f04/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/02.Lab2:%20System%20Calls.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/02.Lab2: System Calls.md",key:"v-24a8be88",path:"/pages/e84f04/",headers:[{level:3,title:"1、System call tracing",slug:"_1、system-call-tracing",normalizedTitle:"1、system call tracing",charIndex:65},{level:3,title:"2、Sysinfo",slug:"_2、sysinfo",normalizedTitle:"2、sysinfo",charIndex:3977},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:5208}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"1、System call tracing 2、Sysinfo 实验结果",content:'# [MIT6.S081]Lab2: System Calls\n\nLab: System calls (mit.edu)\n\n\n# 1、System call tracing\n\n这个 assignment 让自己更了解了 xv6 内部系统调用的实现方式，以及用户态和内核态是如何隔离的。\n\n我们要实现一个 trace 系统调用，使得我们能够跟踪 command 中所调用的我们想要追踪的系统调用，以及其返回值。\n\n我们正常执行指令时，如果遇到了系统调用，则会从用户态切换到内核态，提升硬件的特权，来执行系统调用，而在 xv6 中这个切换的操作就由 ecall 来执行。\n\n要实现一个新的系统调用函数，我们就必须在用户态中提供切换到内核态并执行该系统调用的一个接口，这个接口，也就是一个跳板函数，由 usys.pl 自动生成，名字叫 SYS_trace, 并加入到 usys.S 中。\n\n在 usys.S中 ，我们将 SYS_trace 放入 a7 寄存器\n\n所以我们先在 usys.pl 中加入对应的接口\n\n#!/usr/bin/perl -w\n\n# Generate usys.S, the stubs for syscalls.\n\nprint "# generated by usys.pl - do not edit\\n";\n\nprint "#include \\"kernel/syscall.h\\"\\n";\n\nsub entry {\n    my $name = shift;\n    print ".global $name\\n";\n    print "${name}:\\n";\n    print " li a7, SYS_${name}\\n";\n    print " ecall\\n";\n    print " ret\\n";\n}\n\n# 生成每个系统调用从用户态 到 内核态的跳板函数，通过 ecall 从 user mode 切换到 supervisor mode，实现了用户态和内核态的隔离\n\nentry("fork");\nentry("exit");\nentry("wait");\nentry("pipe");\nentry("read");\nentry("write");\nentry("close");\nentry("kill");\nentry("exec");\nentry("open");\nentry("mknod");\nentry("unlink");\nentry("fstat");\nentry("link");\nentry("mkdir");\nentry("chdir");\nentry("dup");\nentry("getpid");\nentry("sbrk");\nentry("sleep");\nentry("uptime");\nentry("trace"); # 在这里添加跳板入口\n\n\n而在用户态中，官方已经帮我们实现好了 user/trace.c，直接在 shell 中使用即可，该文件中调用了 trace 函数，因此我们还要在 user.h 加入这个函数的声明。\n\n上面是用户态中我们所需要执行的，而通过 ecall 我们便进入了内核态，内核态中所有的系统调用都会在 kernel/syscall.c 中处理执行，我们先要在这个文件中对前面汇编生成的 SYS_trace 进行注册。\n\n我们先在 syscall.h 中加入宏定义，为 SYS_trace 指定了一个数字\n\n#define SYS_trace  22\n\n\n接着在 syscall.c 中的系统调用函数数组中添加 sys_trace 函数，并用 SYS_trace 作为下标来指定，另外我们并不在 syscall.c 中实现这个函数，所以还要从外部 extern 进来\n\nextern uint64 sys_trace(void);\n\nstatic uint64 (*syscalls[])(void) = {\n[SYS_fork]    sys_fork,\n[SYS_exit]    sys_exit,\n[SYS_wait]    sys_wait,\n[SYS_pipe]    sys_pipe,\n[SYS_read]    sys_read,\n[SYS_kill]    sys_kill,\n[SYS_exec]    sys_exec,\n[SYS_fstat]   sys_fstat,\n[SYS_chdir]   sys_chdir,\n[SYS_dup]     sys_dup,\n[SYS_getpid]  sys_getpid,\n[SYS_sbrk]    sys_sbrk,\n[SYS_sleep]   sys_sleep,\n[SYS_uptime]  sys_uptime,\n[SYS_open]    sys_open,\n[SYS_write]   sys_write,\n[SYS_mknod]   sys_mknod,\n[SYS_unlink]  sys_unlink,\n[SYS_link]    sys_link,\n[SYS_mkdir]   sys_mkdir,\n[SYS_close]   sys_close,\n[SYS_trace]   sys_trace, // C语言的语法，表明 sys_trace 的下标是 SYS_trace\n};\n\n\n而这个系统调用的具体实现，我们则在 sysproc.c 中进行，\n\n首先我们要获取 trace 系统调用的参数，由于该参数是在用户态下传入的，因为用户态和内核态是相互隔离的，所以我们无法直接像 C 语言传参那样，需要从进程的 trapframe 中读取寄存器中的值，我们用 int argint(int, int) 实现，并将这个值保存到进程一个新变量中，我们在 proc.h 中的 struct proc 中添加变量 int sysc_trace 。另外记得要在分配一个新进程的时候将这个新变量的值初始化为 0，避免出现混乱的初始值，也就是在 proc.c 中的 allocproc 函数中合适的位置添加 p->sysc_trace = 0;\n\n回到具体实现上，我们获取到的参数是一个掩码，其二进制下的每一位表示着我们想要追踪的系统调用，我们将这个信息保存到当前进程的 sysc_trace 中，实现如下：\n\nuint64 sys_trace(void) {\n  int msk;\n  if(argint(0, &msk) < 0)\n    return -1;\n  myproc()->sysc_trace = msk;\n  return 0;\n}\n\n\n为了能够打印我们追踪的信息，我们还要在 syscall.c 中的 void syscall(void) 添加一些内容。\n\n我们之前已经将系统调用专属的数字标号放入了 a7 寄存器中， num = p->trapframe->a7; 将该值赋给 num 。\n\n而从 p->trapframe->a0 = syscalls[num](); 可以看出这句执行了系统调用，并将结果保存在了 a0 寄存器中。\n\n因此我们这行下面加入打印信息\n\nif ((p->sysc_trace >> num) & 1) {\n    printf("%d: syscall %s -> %d\\n", p->pid, syscalls_names[num], p->trapframe->a0);\n}\n\n\np->pid 是当前进程的 pid 号，syscalls_names 需要我们在 syscall.c 中额外定义一下。\n\nconst char *syscalls_names[] = {\n[SYS_fork]    "fork",\n[SYS_exit]    "exit",\n[SYS_wait]    "wait",\n[SYS_pipe]    "pipe",\n[SYS_read]    "read",\n[SYS_kill]    "kill",\n[SYS_exec]    "exec",\n[SYS_fstat]   "fstat",\n[SYS_chdir]   "chdir",\n[SYS_dup]     "dup",\n[SYS_getpid]  "getpid",\n[SYS_sbrk]    "sbrk",\n[SYS_sleep]   "sleep",\n[SYS_uptime]  "uptime",\n[SYS_open]    "open",\n[SYS_write]   "write",\n[SYS_mknod]   "mknod",\n[SYS_unlink]  "unlink",\n[SYS_link]    "link",\n[SYS_mkdir]   "mkdir",\n[SYS_close]   "close",\n[SYS_trace]   "trace",\n};\n\n\n最后我们还要在 fork 系统调用的时候将父进程的 sysc_trace copy 给子进程，故在 proc.c 的 int fork(void) 中添加 np->sysc_trace = p->sysc_trace; 即可。\n\n**PS：**由于测试点 Test trace children 耗时可能比较长(至少我是的)，所以可能需要在 gradelib.py 中修改一下 timeout，如下\n\ndef run_qemu_kw(target_base="qemu", make_args=[], timeout=50):\n\n\n# 2、Sysinfo\n\n这个 assignment 要我们实现 Sysinfo 系统调用，让我们可以得到此时内核中空闲的内存大小以及不在 UNUSED 状态下的进程个数，而以上信息用 struct sysinfo 保存。\n\n前面声明注册系统调用的步骤和前面的任务差不多，在这里我们就直接跳过了。\n\n首先我们要在 kalloc.c 中实现函数来获取空闲内存大小。xv6 采用的是空闲链表分配法，我们只需要遍历一下链表，统计空闲的页数，乘上每个页的内存大小即可\n\nvoid get_freemem(uint64 *freemem) {\n  struct run *node = kmem.freelist;\n  uint64 res = 0;\n  while (node) {\n    res += PGSIZE;\n    node = node->next;\n  }\n  *freemem = res;\n}\n\n\n接着我们在 proc.c 中实现函数来获取状态不为 UNUSED 的进程个数，更简单了，只需要遍历一下就行\n\nvoid get_nproc(uint64 *nproc) {\n  int cnt = 0;\n  struct proc *p;\n  for (p = proc; p < &proc[NPROC]; p++) {\n    if (p->state != UNUSED) {\n      cnt++;\n    }\n  }\n  *nproc = cnt;\n}\n\n\n另外记得在 def.h 中声明一下这两个函数。\n\n然后我们在 sysproc.c 里实现一下 sys_sysinfo 这个函数就 ok 了\n\nuint64 sys_sysinfo(void) {\n\n  struct proc *p = myproc();\n  struct sysinfo info;\n  uint64 addr;\n  get_freemem(&info.freemem);\n  get_nproc(&info.nproc);\n  if (argaddr(0, &addr) < 0) { // 获取地址参数\n    return -1;\n  }  \n  if(copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0) { // 将 info 拷贝到对应的地方\n    return -1;\n  }\n  return 0;\n}\n\n\n这里我们调用了函数 copyout(p->pagetable, addr, (char *)&info, sizeof(info)，需要注意的是这里的 addr 是个虚拟地址，我们将 info 的信息拷贝到给定的当前进程的页表 p->pagetable 中的 addr 处。\n\n如此一来我们就实现了系统调用 sysinfo，可以在用户态下获取内核里的相关信息。\n\n\n# 实验结果\n',normalizedContent:'# [mit6.s081]lab2: system calls\n\nlab: system calls (mit.edu)\n\n\n# 1、system call tracing\n\n这个 assignment 让自己更了解了 xv6 内部系统调用的实现方式，以及用户态和内核态是如何隔离的。\n\n我们要实现一个 trace 系统调用，使得我们能够跟踪 command 中所调用的我们想要追踪的系统调用，以及其返回值。\n\n我们正常执行指令时，如果遇到了系统调用，则会从用户态切换到内核态，提升硬件的特权，来执行系统调用，而在 xv6 中这个切换的操作就由 ecall 来执行。\n\n要实现一个新的系统调用函数，我们就必须在用户态中提供切换到内核态并执行该系统调用的一个接口，这个接口，也就是一个跳板函数，由 usys.pl 自动生成，名字叫 sys_trace, 并加入到 usys.s 中。\n\n在 usys.s中 ，我们将 sys_trace 放入 a7 寄存器\n\n所以我们先在 usys.pl 中加入对应的接口\n\n#!/usr/bin/perl -w\n\n# generate usys.s, the stubs for syscalls.\n\nprint "# generated by usys.pl - do not edit\\n";\n\nprint "#include \\"kernel/syscall.h\\"\\n";\n\nsub entry {\n    my $name = shift;\n    print ".global $name\\n";\n    print "${name}:\\n";\n    print " li a7, sys_${name}\\n";\n    print " ecall\\n";\n    print " ret\\n";\n}\n\n# 生成每个系统调用从用户态 到 内核态的跳板函数，通过 ecall 从 user mode 切换到 supervisor mode，实现了用户态和内核态的隔离\n\nentry("fork");\nentry("exit");\nentry("wait");\nentry("pipe");\nentry("read");\nentry("write");\nentry("close");\nentry("kill");\nentry("exec");\nentry("open");\nentry("mknod");\nentry("unlink");\nentry("fstat");\nentry("link");\nentry("mkdir");\nentry("chdir");\nentry("dup");\nentry("getpid");\nentry("sbrk");\nentry("sleep");\nentry("uptime");\nentry("trace"); # 在这里添加跳板入口\n\n\n而在用户态中，官方已经帮我们实现好了 user/trace.c，直接在 shell 中使用即可，该文件中调用了 trace 函数，因此我们还要在 user.h 加入这个函数的声明。\n\n上面是用户态中我们所需要执行的，而通过 ecall 我们便进入了内核态，内核态中所有的系统调用都会在 kernel/syscall.c 中处理执行，我们先要在这个文件中对前面汇编生成的 sys_trace 进行注册。\n\n我们先在 syscall.h 中加入宏定义，为 sys_trace 指定了一个数字\n\n#define sys_trace  22\n\n\n接着在 syscall.c 中的系统调用函数数组中添加 sys_trace 函数，并用 sys_trace 作为下标来指定，另外我们并不在 syscall.c 中实现这个函数，所以还要从外部 extern 进来\n\nextern uint64 sys_trace(void);\n\nstatic uint64 (*syscalls[])(void) = {\n[sys_fork]    sys_fork,\n[sys_exit]    sys_exit,\n[sys_wait]    sys_wait,\n[sys_pipe]    sys_pipe,\n[sys_read]    sys_read,\n[sys_kill]    sys_kill,\n[sys_exec]    sys_exec,\n[sys_fstat]   sys_fstat,\n[sys_chdir]   sys_chdir,\n[sys_dup]     sys_dup,\n[sys_getpid]  sys_getpid,\n[sys_sbrk]    sys_sbrk,\n[sys_sleep]   sys_sleep,\n[sys_uptime]  sys_uptime,\n[sys_open]    sys_open,\n[sys_write]   sys_write,\n[sys_mknod]   sys_mknod,\n[sys_unlink]  sys_unlink,\n[sys_link]    sys_link,\n[sys_mkdir]   sys_mkdir,\n[sys_close]   sys_close,\n[sys_trace]   sys_trace, // c语言的语法，表明 sys_trace 的下标是 sys_trace\n};\n\n\n而这个系统调用的具体实现，我们则在 sysproc.c 中进行，\n\n首先我们要获取 trace 系统调用的参数，由于该参数是在用户态下传入的，因为用户态和内核态是相互隔离的，所以我们无法直接像 c 语言传参那样，需要从进程的 trapframe 中读取寄存器中的值，我们用 int argint(int, int) 实现，并将这个值保存到进程一个新变量中，我们在 proc.h 中的 struct proc 中添加变量 int sysc_trace 。另外记得要在分配一个新进程的时候将这个新变量的值初始化为 0，避免出现混乱的初始值，也就是在 proc.c 中的 allocproc 函数中合适的位置添加 p->sysc_trace = 0;\n\n回到具体实现上，我们获取到的参数是一个掩码，其二进制下的每一位表示着我们想要追踪的系统调用，我们将这个信息保存到当前进程的 sysc_trace 中，实现如下：\n\nuint64 sys_trace(void) {\n  int msk;\n  if(argint(0, &msk) < 0)\n    return -1;\n  myproc()->sysc_trace = msk;\n  return 0;\n}\n\n\n为了能够打印我们追踪的信息，我们还要在 syscall.c 中的 void syscall(void) 添加一些内容。\n\n我们之前已经将系统调用专属的数字标号放入了 a7 寄存器中， num = p->trapframe->a7; 将该值赋给 num 。\n\n而从 p->trapframe->a0 = syscalls[num](); 可以看出这句执行了系统调用，并将结果保存在了 a0 寄存器中。\n\n因此我们这行下面加入打印信息\n\nif ((p->sysc_trace >> num) & 1) {\n    printf("%d: syscall %s -> %d\\n", p->pid, syscalls_names[num], p->trapframe->a0);\n}\n\n\np->pid 是当前进程的 pid 号，syscalls_names 需要我们在 syscall.c 中额外定义一下。\n\nconst char *syscalls_names[] = {\n[sys_fork]    "fork",\n[sys_exit]    "exit",\n[sys_wait]    "wait",\n[sys_pipe]    "pipe",\n[sys_read]    "read",\n[sys_kill]    "kill",\n[sys_exec]    "exec",\n[sys_fstat]   "fstat",\n[sys_chdir]   "chdir",\n[sys_dup]     "dup",\n[sys_getpid]  "getpid",\n[sys_sbrk]    "sbrk",\n[sys_sleep]   "sleep",\n[sys_uptime]  "uptime",\n[sys_open]    "open",\n[sys_write]   "write",\n[sys_mknod]   "mknod",\n[sys_unlink]  "unlink",\n[sys_link]    "link",\n[sys_mkdir]   "mkdir",\n[sys_close]   "close",\n[sys_trace]   "trace",\n};\n\n\n最后我们还要在 fork 系统调用的时候将父进程的 sysc_trace copy 给子进程，故在 proc.c 的 int fork(void) 中添加 np->sysc_trace = p->sysc_trace; 即可。\n\n**ps：**由于测试点 test trace children 耗时可能比较长(至少我是的)，所以可能需要在 gradelib.py 中修改一下 timeout，如下\n\ndef run_qemu_kw(target_base="qemu", make_args=[], timeout=50):\n\n\n# 2、sysinfo\n\n这个 assignment 要我们实现 sysinfo 系统调用，让我们可以得到此时内核中空闲的内存大小以及不在 unused 状态下的进程个数，而以上信息用 struct sysinfo 保存。\n\n前面声明注册系统调用的步骤和前面的任务差不多，在这里我们就直接跳过了。\n\n首先我们要在 kalloc.c 中实现函数来获取空闲内存大小。xv6 采用的是空闲链表分配法，我们只需要遍历一下链表，统计空闲的页数，乘上每个页的内存大小即可\n\nvoid get_freemem(uint64 *freemem) {\n  struct run *node = kmem.freelist;\n  uint64 res = 0;\n  while (node) {\n    res += pgsize;\n    node = node->next;\n  }\n  *freemem = res;\n}\n\n\n接着我们在 proc.c 中实现函数来获取状态不为 unused 的进程个数，更简单了，只需要遍历一下就行\n\nvoid get_nproc(uint64 *nproc) {\n  int cnt = 0;\n  struct proc *p;\n  for (p = proc; p < &proc[nproc]; p++) {\n    if (p->state != unused) {\n      cnt++;\n    }\n  }\n  *nproc = cnt;\n}\n\n\n另外记得在 def.h 中声明一下这两个函数。\n\n然后我们在 sysproc.c 里实现一下 sys_sysinfo 这个函数就 ok 了\n\nuint64 sys_sysinfo(void) {\n\n  struct proc *p = myproc();\n  struct sysinfo info;\n  uint64 addr;\n  get_freemem(&info.freemem);\n  get_nproc(&info.nproc);\n  if (argaddr(0, &addr) < 0) { // 获取地址参数\n    return -1;\n  }  \n  if(copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0) { // 将 info 拷贝到对应的地方\n    return -1;\n  }\n  return 0;\n}\n\n\n这里我们调用了函数 copyout(p->pagetable, addr, (char *)&info, sizeof(info)，需要注意的是这里的 addr 是个虚拟地址，我们将 info 的信息拷贝到给定的当前进程的页表 p->pagetable 中的 addr 处。\n\n如此一来我们就实现了系统调用 sysinfo，可以在用户态下获取内核里的相关信息。\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab4: Traps",frontmatter:{title:null,date:"2023-02-11T17:09:39.000Z",permalink:"/pages/80245f/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/04.Lab4:%20Traps.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/04.Lab4: Traps.md",key:"v-e38ed39e",path:"/pages/80245f/",headers:[{level:3,title:"1、RISC-V assembly",slug:"_1、risc-v-assembly",normalizedTitle:"1、risc-v assembly",charIndex:51},{level:3,title:"2、Backtrace",slug:"_2、backtrace",normalizedTitle:"2、backtrace",charIndex:1610},{level:3,title:"3.Alarm",slug:"_3-alarm",normalizedTitle:"3.alarm",charIndex:2127},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:4048},{level:3,title:"存在问题",slug:"存在问题",normalizedTitle:"存在问题",charIndex:4058}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"1、RISC-V assembly 2、Backtrace 3.Alarm 实验结果 存在问题",content:'# [MIT6.S081]Lab4: Traps\n\nLab: Traps (mit.edu)\n\n\n# 1、RISC-V assembly\n\n这个 assignment 主要是用来熟悉一些简单的 RISCV 的汇编。\n\n 1. Which registers contain arguments to functions? For example, which register holds 13 in main\'s call to printf?\n\n一般用 a0 - a7 来存放参数，显然参数 13 放在 a2 寄存器中。\n\n 2. Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)\n\n * 根据下面两行汇编，显然两个函数都被内联优化了\n\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n\n\n 3. At what address is the function printf located?\n\n * 由下面两行汇编可以看出，我们在修改完 pc 的值之后跳转到了 0x30 + 1536 的地方，1536 的十六进制是 0x600，所以我们最后会跳转到 printf 所在的地方 0x630\n\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t600080e7          \tjalr\t1536(ra) # 630 <printf>\n\n\n 4. What value is in the register ra just after the jalr to printf in main?\n\n * 由下图可以看出，我们会把 原 pc + 4 的值写入寄存器 ra，因此此时他的值是 0x38\n\n 5. Run the following code.\n    \n    unsigned int i = 0x00646c72;\n    printf("H%x Wo%s", 57616, &i);\n    \n    \n    What is the output?\n    \n    The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?\n\n * 输出是 He110 World\n * 整体按字节逆转一下顺序就行，0x726c6400\n * 不用，大小端是存储的形式，与数值无关，无论 57616 如何被存储，其十六进制都是 0xe110\n\n 6. In the following code, what is going to be printed after \'y=\'? (note: the answer is not a specific value.) Why does this happen?\n    \n    printf("x=%d y=%d", 3);\n    \n\n * 从汇编我们可以很容易知道参数传递是通过寄存器实现的，在这里的两个参数分别由 a1 和 a2 传递。由于我们没有给第二个参数，因此这里会由当前 a2 中的值代替，这取决于这行代码之前的部分了。\n\n\n# 2、Backtrace\n\n在这个 assignment 中，我们调用系统调用 sys_sleep 后，要递归打印被调用的函数的 return address。\n\n这张图展现了栈的地址空间，可以看出我们要打印的 return address 在 fp -8 的位置，而前一个栈的 fp，存在了 fp - 16 的位置，了解了这些后，这个 assigment 就非常好实现了，我们直接看代码：\n\nvoid backtrace(void) {\n  uint64 fp = r_fp(); // 系统提供的，获取了当前执行函数的 fp \n  uint64 top = PGROUNDUP(fp); // 系统提供的\n  uint64 bottom = PGROUNDDOWN(fp);\n  printf("backtrace:\\n");\n  while (fp > bottom && fp < top) {\n    uint64 ra = *(uint64 *)(fp - 8); // 转化成指针再解引用\n    fp = *(uint64 *)(fp - 16);\n    printf("%p\\n", ra);\n  }\n}\n\n\n\n# 3.Alarm\n\n这个 assignment 比较复杂，简单来说就是要我们自己实现两个系统调用，能够通过倒计时来陷入 timer interrupt，来执行相关函数。\n\n我们先要添加两个系统调用 sys_sigalarm、sys_sigreturn，添加流程和之前一致，就不赘述了。\n\n为了实现要求，我们先要在 struct proc 中添加一些新的变量\n\nstruct proc {\n//..................\n  int interval; // 计时器间隔\n  uint64 handler; // 倒计时结束后执行的函数地址\n  int passed_ticks; // 当前过了多久时间\n  struct trapframe *saved_trapframe; // 执行 handler 之前要保存 trapframe\n  int in_trap; // 当前是否在 trap 中，如果在要避免再次遇到 trap\n};\n\n\n对应的要在 proc.c 中进行初始化，以及 free\n\nstatic struct proc* allocproc(void) {\n// ...................\n  // Allocate a saved_trapframe page.\n  if((p->saved_trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  p->interval = 0;\n  p->passed_ticks = 0;\n  p->in_trap = 0;\n\n  return p;\n}\n\n\nstatic void freeproc(struct proc *p) {\n// ......\n  if(p->saved_trapframe)\n    kfree((void*)p->saved_trapframe);\n  p->handler = 0;\n  p->in_trap = 0;\n  p->interval = 0;\n  p->passed_ticks = 0;\n// ......\n}\n\n\n接着我们在 trap.c 中实现倒计时和切换函数。\n\n  // give up the CPU if this is a timer interrupt.\n  if(which_dev == 2) {\n    if (p->in_trap == 0) { // 保证当前不在 trap 里\n      p->passed_ticks++; // 经过时间 + 1\n      if (p->passed_ticks == p->interval) { // 倒计时结束\n        p->passed_ticks = 0; // 重置时间\n        p->in_trap = 1; // 进入trap\n        *p->saved_trapframe = *p->trapframe; // 保存当前的 trapframe\n        p->trapframe->epc = p->handler; // 切换执行函数\n      }\n      \n    }\n    yield();\n  }\n\n\n具体的看注释就可以了，需要注意的是我们通过修改 p->trapframe->epc = p->handler 来切换到相关函数并执行\n\n另外我们还需要实现一下两个系统调用\n\nuint64 sys_sigalarm(void) { // 获取相关参数并赋值\n  int ticks;\n  uint64 handler;\n  if(argint(0, &ticks) < 0)\n    return -1;\n  if(argaddr(1, &handler) < 0)\n    return -1;\n\n  myproc()->interval = ticks;\n  myproc()->handler = handler;\n  return 0;\n}\n\nuint64 sys_sigreturn(void) { \n    myproc()->in_trap = 0; // 又恢复了不在 trap 的转台\n    *myproc()->trapframe = *myproc()->saved_trapframe; // 恢复现场，将之前保存下来的 trapframe 恢复\n  return 0;\n}\n\n\n\n# 实验结果\n\n\n\n# 存在问题\n\n\n\n不知道是我的问题还是有 bug，我特地跑了 origin/traps 的原代码最后还是没有通过 usertests 🥲，后面的 labs 就',normalizedContent:'# [mit6.s081]lab4: traps\n\nlab: traps (mit.edu)\n\n\n# 1、risc-v assembly\n\n这个 assignment 主要是用来熟悉一些简单的 riscv 的汇编。\n\n 1. which registers contain arguments to functions? for example, which register holds 13 in main\'s call to printf?\n\n一般用 a0 - a7 来存放参数，显然参数 13 放在 a2 寄存器中。\n\n 2. where is the call to function f in the assembly code for main? where is the call to g? (hint: the compiler may inline functions.)\n\n * 根据下面两行汇编，显然两个函数都被内联优化了\n\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n\n\n 3. at what address is the function printf located?\n\n * 由下面两行汇编可以看出，我们在修改完 pc 的值之后跳转到了 0x30 + 1536 的地方，1536 的十六进制是 0x600，所以我们最后会跳转到 printf 所在的地方 0x630\n\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t600080e7          \tjalr\t1536(ra) # 630 <printf>\n\n\n 4. what value is in the register ra just after the jalr to printf in main?\n\n * 由下图可以看出，我们会把 原 pc + 4 的值写入寄存器 ra，因此此时他的值是 0x38\n\n 5. run the following code.\n    \n    unsigned int i = 0x00646c72;\n    printf("h%x wo%s", 57616, &i);\n    \n    \n    what is the output?\n    \n    the output depends on that fact that the risc-v is little-endian. if the risc-v were instead big-endian what would you set i to in order to yield the same output? would you need to change 57616 to a different value?\n\n * 输出是 he110 world\n * 整体按字节逆转一下顺序就行，0x726c6400\n * 不用，大小端是存储的形式，与数值无关，无论 57616 如何被存储，其十六进制都是 0xe110\n\n 6. in the following code, what is going to be printed after \'y=\'? (note: the answer is not a specific value.) why does this happen?\n    \n    printf("x=%d y=%d", 3);\n    \n\n * 从汇编我们可以很容易知道参数传递是通过寄存器实现的，在这里的两个参数分别由 a1 和 a2 传递。由于我们没有给第二个参数，因此这里会由当前 a2 中的值代替，这取决于这行代码之前的部分了。\n\n\n# 2、backtrace\n\n在这个 assignment 中，我们调用系统调用 sys_sleep 后，要递归打印被调用的函数的 return address。\n\n这张图展现了栈的地址空间，可以看出我们要打印的 return address 在 fp -8 的位置，而前一个栈的 fp，存在了 fp - 16 的位置，了解了这些后，这个 assigment 就非常好实现了，我们直接看代码：\n\nvoid backtrace(void) {\n  uint64 fp = r_fp(); // 系统提供的，获取了当前执行函数的 fp \n  uint64 top = pgroundup(fp); // 系统提供的\n  uint64 bottom = pgrounddown(fp);\n  printf("backtrace:\\n");\n  while (fp > bottom && fp < top) {\n    uint64 ra = *(uint64 *)(fp - 8); // 转化成指针再解引用\n    fp = *(uint64 *)(fp - 16);\n    printf("%p\\n", ra);\n  }\n}\n\n\n\n# 3.alarm\n\n这个 assignment 比较复杂，简单来说就是要我们自己实现两个系统调用，能够通过倒计时来陷入 timer interrupt，来执行相关函数。\n\n我们先要添加两个系统调用 sys_sigalarm、sys_sigreturn，添加流程和之前一致，就不赘述了。\n\n为了实现要求，我们先要在 struct proc 中添加一些新的变量\n\nstruct proc {\n//..................\n  int interval; // 计时器间隔\n  uint64 handler; // 倒计时结束后执行的函数地址\n  int passed_ticks; // 当前过了多久时间\n  struct trapframe *saved_trapframe; // 执行 handler 之前要保存 trapframe\n  int in_trap; // 当前是否在 trap 中，如果在要避免再次遇到 trap\n};\n\n\n对应的要在 proc.c 中进行初始化，以及 free\n\nstatic struct proc* allocproc(void) {\n// ...................\n  // allocate a saved_trapframe page.\n  if((p->saved_trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  p->interval = 0;\n  p->passed_ticks = 0;\n  p->in_trap = 0;\n\n  return p;\n}\n\n\nstatic void freeproc(struct proc *p) {\n// ......\n  if(p->saved_trapframe)\n    kfree((void*)p->saved_trapframe);\n  p->handler = 0;\n  p->in_trap = 0;\n  p->interval = 0;\n  p->passed_ticks = 0;\n// ......\n}\n\n\n接着我们在 trap.c 中实现倒计时和切换函数。\n\n  // give up the cpu if this is a timer interrupt.\n  if(which_dev == 2) {\n    if (p->in_trap == 0) { // 保证当前不在 trap 里\n      p->passed_ticks++; // 经过时间 + 1\n      if (p->passed_ticks == p->interval) { // 倒计时结束\n        p->passed_ticks = 0; // 重置时间\n        p->in_trap = 1; // 进入trap\n        *p->saved_trapframe = *p->trapframe; // 保存当前的 trapframe\n        p->trapframe->epc = p->handler; // 切换执行函数\n      }\n      \n    }\n    yield();\n  }\n\n\n具体的看注释就可以了，需要注意的是我们通过修改 p->trapframe->epc = p->handler 来切换到相关函数并执行\n\n另外我们还需要实现一下两个系统调用\n\nuint64 sys_sigalarm(void) { // 获取相关参数并赋值\n  int ticks;\n  uint64 handler;\n  if(argint(0, &ticks) < 0)\n    return -1;\n  if(argaddr(1, &handler) < 0)\n    return -1;\n\n  myproc()->interval = ticks;\n  myproc()->handler = handler;\n  return 0;\n}\n\nuint64 sys_sigreturn(void) { \n    myproc()->in_trap = 0; // 又恢复了不在 trap 的转台\n    *myproc()->trapframe = *myproc()->saved_trapframe; // 恢复现场，将之前保存下来的 trapframe 恢复\n  return 0;\n}\n\n\n\n# 实验结果\n\n\n\n# 存在问题\n\n\n\n不知道是我的问题还是有 bug，我特地跑了 origin/traps 的原代码最后还是没有通过 usertests 🥲，后面的 labs 就',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab3: Page Tables",frontmatter:{title:null,date:"2023-02-08T21:23:53.000Z",permalink:"/pages/aa266f/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/03.Lab3:%20Page%20Tables.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/03.Lab3: Page Tables.md",key:"v-0f826bae",path:"/pages/aa266f/",headers:[{level:3,title:"1、Speed up system calls",slug:"_1、speed-up-system-calls",normalizedTitle:"1、speed up system calls",charIndex:63},{level:3,title:"2、Print a page table",slug:"_2、print-a-page-table",normalizedTitle:"2、print a page table",charIndex:1320},{level:3,title:"3、Detecting which pages have been accessed",slug:"_3、detecting-which-pages-have-been-accessed",normalizedTitle:"3、detecting which pages have been accessed",charIndex:2435},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:3472}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"1、Speed up system calls 2、Print a page table 3、Detecting which pages have been accessed 实验结果",content:'# [MIT6.S081]Lab3: Page Tables\n\nLab: page tables (mit.edu)\n\n\n# 1、Speed up system calls\n\n这个 assignment 中我们要为 getpid 这个系操作加快速度，因为系统调用需要我们保存上下文，还要从用户态切换到内核态，因此会损耗很多时间。于是我们为每个进程新分配了一个页，其虚拟地址位于 USYSCALL，就在 TRAPFRAME 的下面，并且在这个页的开头用 struct usyscall 保存了进程的 pid。\n\n我们先要在 proc.h 中添加一个 struct usyscall 类型的变量\n\nstruct usyscall *usyscall;\n\n\n接着我们在 proc.c 中进行我们的操作，我们先要在进程初始化的时候，去分配一个新页，并将进程的 pid 赋值给 usyscall，在 allocproc 中加入\n\nif((p->usyscall = (struct usyscall *)kalloc()) == 0){\n  freeproc(p);\n  release(&p->lock);\n  return 0;\n}\np->usyscall->pid = p->pid;\n\n\n之后我们在 proc_pagetable 中添加映射\n\nif (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usyscall), PTE_R | PTE_U) < 0){\n  uvmunmap(pagetable, TRAMPOLINE, 1, 0); \n  uvmunmap(pagetable, TRAPFRAME, 1, 0);\n  uvmfree(pagetable, 0);\n  return 0;\n}\n\n\n可以直接模仿着 trapframe 的写法，需要注意的是如果映射失败的话在解除映射时要把 TRAMPLINE 和 TRAPFRAME 也解除了。\n\n接着在释放 page 的时候我们也要接触和 USYSCALL 的映射\n\nvoid proc_freepagetable(pagetable_t pagetable, uint64 sz) {\n  uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n  uvmunmap(pagetable, TRAPFRAME, 1, 0);\n  uvmunmap(pagetable, USYSCALL, 1, 0);\n  uvmfree(pagetable, sz);\n}\n\n\n还有释放进程的时候也要把分配的空间回收了，在 freeproc 中加入\n\nif (p->usyscall) {\n  kfree((void *)p->usyscall);\n}\np->usyscall = 0;\n\n\n最后还有要注意的一点，也是我找了半天的问题，就是在我们要在调用 proc_pagetable 来为进程创建用户页表之前分配 page 给 usyscall，不然没法正确的添加映射，毕竟 page 都没分配，怎么映射。\n\n\n# 2、Print a page table\n\n这个就比较简单了，要在 exec.c return argc 之前打印 pid = 1 的进程页表。\n\n我们先在 exec.c return 前添加函数\n\nif (p->pid == 1) {\n\tvmprint(p->pagetable);\n}\n\nreturn argc; // this ends up in a0, the first argument to main(argc, argv)\n\n\n将 vmprint 函数进行声明，在 defs.h 中\n\nvoid vmprint(pagetable_t);\n\n\n之后我们在 vm.c 中实现该函数，\n\n根据 hints，我们可以仿照函数 freewalk 来写，显然那我们需要用到递归。\n\n我们先打印不需要加入递归的第一行，之后调用另外实现的递归打印函数即可。\n\nvoid vmprint(pagetable_t pagetable) {\n  printf("page table %p\\n", pagetable);\n  recprint(pagetable, 1);\n}\n\n\nrecprint 函数传递了两个参数，一个是 pagetable_t，还有一个便是递归的层数，因为我们要通过打印 .. 来表示我们在树中的深度。\n\nvoid recprint(pagetable_t pagetable, int cnt) {\n  for (int i = 0; i < 512; i++) { // 遍历页表\n    pte_t pte = pagetable[i]; // 取出 PTE\n    if (pte & PTE_V) { // 如果是合法的，则需要打印，先打印 层数 - 1 个 ".. "，带有空格！而最后一个没有空格。\n      for (int j = 0; j < cnt - 1; j++) {\n        printf(".. ");\n      }\n      printf("..%d: pte %p pa %p\\n", i, pte, PTE2PA (pte)); // 打印最后的 .. 和相关的信息，调用了 riscv.h 中的 PTE2A 函数\n      if ((pte & (PTE_R|PTE_W|PTE_X)) == 0) { // 如果不是叶子，则需要继续递归打印下去，只有叶子才有这些标志位\n        recprint((pagetable_t)PTE2PA(pte), cnt + 1);\n      }\n    }\n  }\n}\n\n\n具体看代码注释就好了。\n\n\n# 3、Detecting which pages have been accessed\n\n这个 assignment 也比较简单，首先我们根据 riscv 的手册，可以知道 PTE_A 位于 1L << 6 处\n\n\n\n因此我们在 riscv.h 中添加定义\n\n#define PTE_A (1L << 6) // whether have been accessed\n\n\n之后我们直接在 sysproc.c 中实现即可\n\n#ifdef LAB_PGTBL\nint\nsys_pgaccess(void)\n{\n  // lab pgtbl: your code here.\n  uint64 va;\n  int len;\n  uint64 des_addr;\n  if (argaddr(0, &va) < 0)\n    return -1;\n  if (argint(1, &len) < 0)\n    return -1;\n  if (argaddr(2, &des_addr) < 0)\n    return -1;\n  \n  int res = 0;\n  for (int i = 0; i < len; i++) {\n    if (va >= MAXVA) {\n      return -1;\n    }\n    pte_t *pte = walk(myproc()->pagetable, va, 0);\n    if (*pte == 0) return -1;\n    if (*pte & (PTE_A)) {\n      res |= (1 << i);\n      *pte &= (~PTE_A);\n    } \n    va += PGSIZE;  \n  }\n\n  if (copyout(myproc()->pagetable, des_addr, (char *)&res, sizeof(res)) < 0) {\n    return -1;\n  };\n\n  return 0;\n}\n#endif\n\n\n首先要保证虚拟地址是合法的，也就是 va < MAXVA\n\n接着我们每次用 walk 取出 va 对应的 PTE，记得要用指针，因为后面要修改 PTE。\n\nres |= (1 << i); 用来表示保存答案，*pte &= (~PTE_A); 表示将 PTE_A 标志位置为 0。\n\n最后再用 copyout 将答案传到用户态即可。\n\n\n# 实验结果\n',normalizedContent:'# [mit6.s081]lab3: page tables\n\nlab: page tables (mit.edu)\n\n\n# 1、speed up system calls\n\n这个 assignment 中我们要为 getpid 这个系操作加快速度，因为系统调用需要我们保存上下文，还要从用户态切换到内核态，因此会损耗很多时间。于是我们为每个进程新分配了一个页，其虚拟地址位于 usyscall，就在 trapframe 的下面，并且在这个页的开头用 struct usyscall 保存了进程的 pid。\n\n我们先要在 proc.h 中添加一个 struct usyscall 类型的变量\n\nstruct usyscall *usyscall;\n\n\n接着我们在 proc.c 中进行我们的操作，我们先要在进程初始化的时候，去分配一个新页，并将进程的 pid 赋值给 usyscall，在 allocproc 中加入\n\nif((p->usyscall = (struct usyscall *)kalloc()) == 0){\n  freeproc(p);\n  release(&p->lock);\n  return 0;\n}\np->usyscall->pid = p->pid;\n\n\n之后我们在 proc_pagetable 中添加映射\n\nif (mappages(pagetable, usyscall, pgsize, (uint64)(p->usyscall), pte_r | pte_u) < 0){\n  uvmunmap(pagetable, trampoline, 1, 0); \n  uvmunmap(pagetable, trapframe, 1, 0);\n  uvmfree(pagetable, 0);\n  return 0;\n}\n\n\n可以直接模仿着 trapframe 的写法，需要注意的是如果映射失败的话在解除映射时要把 trampline 和 trapframe 也解除了。\n\n接着在释放 page 的时候我们也要接触和 usyscall 的映射\n\nvoid proc_freepagetable(pagetable_t pagetable, uint64 sz) {\n  uvmunmap(pagetable, trampoline, 1, 0);\n  uvmunmap(pagetable, trapframe, 1, 0);\n  uvmunmap(pagetable, usyscall, 1, 0);\n  uvmfree(pagetable, sz);\n}\n\n\n还有释放进程的时候也要把分配的空间回收了，在 freeproc 中加入\n\nif (p->usyscall) {\n  kfree((void *)p->usyscall);\n}\np->usyscall = 0;\n\n\n最后还有要注意的一点，也是我找了半天的问题，就是在我们要在调用 proc_pagetable 来为进程创建用户页表之前分配 page 给 usyscall，不然没法正确的添加映射，毕竟 page 都没分配，怎么映射。\n\n\n# 2、print a page table\n\n这个就比较简单了，要在 exec.c return argc 之前打印 pid = 1 的进程页表。\n\n我们先在 exec.c return 前添加函数\n\nif (p->pid == 1) {\n\tvmprint(p->pagetable);\n}\n\nreturn argc; // this ends up in a0, the first argument to main(argc, argv)\n\n\n将 vmprint 函数进行声明，在 defs.h 中\n\nvoid vmprint(pagetable_t);\n\n\n之后我们在 vm.c 中实现该函数，\n\n根据 hints，我们可以仿照函数 freewalk 来写，显然那我们需要用到递归。\n\n我们先打印不需要加入递归的第一行，之后调用另外实现的递归打印函数即可。\n\nvoid vmprint(pagetable_t pagetable) {\n  printf("page table %p\\n", pagetable);\n  recprint(pagetable, 1);\n}\n\n\nrecprint 函数传递了两个参数，一个是 pagetable_t，还有一个便是递归的层数，因为我们要通过打印 .. 来表示我们在树中的深度。\n\nvoid recprint(pagetable_t pagetable, int cnt) {\n  for (int i = 0; i < 512; i++) { // 遍历页表\n    pte_t pte = pagetable[i]; // 取出 pte\n    if (pte & pte_v) { // 如果是合法的，则需要打印，先打印 层数 - 1 个 ".. "，带有空格！而最后一个没有空格。\n      for (int j = 0; j < cnt - 1; j++) {\n        printf(".. ");\n      }\n      printf("..%d: pte %p pa %p\\n", i, pte, pte2pa (pte)); // 打印最后的 .. 和相关的信息，调用了 riscv.h 中的 pte2a 函数\n      if ((pte & (pte_r|pte_w|pte_x)) == 0) { // 如果不是叶子，则需要继续递归打印下去，只有叶子才有这些标志位\n        recprint((pagetable_t)pte2pa(pte), cnt + 1);\n      }\n    }\n  }\n}\n\n\n具体看代码注释就好了。\n\n\n# 3、detecting which pages have been accessed\n\n这个 assignment 也比较简单，首先我们根据 riscv 的手册，可以知道 pte_a 位于 1l << 6 处\n\n\n\n因此我们在 riscv.h 中添加定义\n\n#define pte_a (1l << 6) // whether have been accessed\n\n\n之后我们直接在 sysproc.c 中实现即可\n\n#ifdef lab_pgtbl\nint\nsys_pgaccess(void)\n{\n  // lab pgtbl: your code here.\n  uint64 va;\n  int len;\n  uint64 des_addr;\n  if (argaddr(0, &va) < 0)\n    return -1;\n  if (argint(1, &len) < 0)\n    return -1;\n  if (argaddr(2, &des_addr) < 0)\n    return -1;\n  \n  int res = 0;\n  for (int i = 0; i < len; i++) {\n    if (va >= maxva) {\n      return -1;\n    }\n    pte_t *pte = walk(myproc()->pagetable, va, 0);\n    if (*pte == 0) return -1;\n    if (*pte & (pte_a)) {\n      res |= (1 << i);\n      *pte &= (~pte_a);\n    } \n    va += pgsize;  \n  }\n\n  if (copyout(myproc()->pagetable, des_addr, (char *)&res, sizeof(res)) < 0) {\n    return -1;\n  };\n\n  return 0;\n}\n#endif\n\n\n首先要保证虚拟地址是合法的，也就是 va < maxva\n\n接着我们每次用 walk 取出 va 对应的 pte，记得要用指针，因为后面要修改 pte。\n\nres |= (1 << i); 用来表示保存答案，*pte &= (~pte_a); 表示将 pte_a 标志位置为 0。\n\n最后再用 copyout 将答案传到用户态即可。\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab5: Copy-on-Write Fork for xv6",frontmatter:{title:null,date:"2023-02-17T20:58:12.000Z",permalink:"/pages/810ff6/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/05.Lab5:%20Copy-on-Write%20Fork%20for%20xv6.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/05.Lab5: Copy-on-Write Fork for xv6.md",key:"v-3e1953e8",path:"/pages/810ff6/",headers:[{level:3,title:"1、Implement copy-on write",slug:"_1、implement-copy-on-write",normalizedTitle:"1、implement copy-on write",charIndex:93},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:4307},{level:3,title:"TODO",slug:"todo",normalizedTitle:"todo",charIndex:4317}],lastUpdated:"3/6/2023, 8:57:26 PM",lastUpdatedTimestamp:1678107446e3,headersStr:"1、Implement copy-on write 实验结果 TODO",content:'# [MIT6.S081]Lab5: Copy-on-Write Fork for xv6\n\nLab: Copy-on-Write Fork for xv6 (mit.edu)\n\n\n# 1、Implement copy-on write\n\n这个 lab 中我们要实现写时复制。\n\n我们知道当一个进程 fork 出一个子进程后，子进程会复制父进程的所有内容，那么此时如果子进程执行了 exec，则会将刚刚复制完的内容又全部重置。我们知道拷贝是非常耗时的，如果每次像这样复制必然会产生许多的浪费。\n\n于是便有了写时复制，在 fork 出一个子进程后，我们不进行拷贝，而是将父子进程的页表映射到同一块物理内存，并将 PTE_W 都置为 0，当父子进程需要写这个地址时，便会产生 page fault，在遇到这种情况后我们才进行实际的拷贝操作。\n\n接下来我们开始写代码 💻\n\n因为此时同一块物理可能被多个进程所共享，那么我们就不能随意释放内存，而是要引入一个新的变量，作为引用计数，类似于 C++ 里的智能指针，只要当一块内存的引用计数为 0 了，才会释放该内存。\n\n在 kalloc.c 中添加引用计数变量\n\nint ref_cnt[(PHYSTOP - KERNBASE) / PGSIZE];\n\n\n我们对应的在新分配一块内存时也要将引用计数初始化为 1\n\nvoid *kalloc(void) {\n  struct run *r;\n\n  acquire(&kmem.lock);\n  r = kmem.freelist;\n  if(r)\n    kmem.freelist = r->next;\n  release(&kmem.lock);\n\n  if(r) {\n    ref_cnt[pageid(r)] = 1; // 初始化引用计数为 1 \n    memset((char*)r, 5, PGSIZE); // fill with junk\n  }\n  return (void*)r;\n}\n\n\n\n在释放内存的时候，如果引用计数 > 1 时，就将其减 1，否则再释放\n\nvoid kfree(void *pa) {\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic("kfree");\n\n  if (ref_cnt[pageid(pa)] > 1) { // 引用计数减 1\n    ref_cnt[pageid(pa)]--;\n    return;\n  }\n\n  // Fill with junk to catch dangling refs.\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n\n  acquire(&kmem.lock);\n  r->next = kmem.freelist;\n  kmem.freelist = r;\n  release(&kmem.lock);\n}\n\n\n之后我们要对 uvmcopy 函数进行修改，当 fork 出一个子进程后，我们要让父子进程共享同一块物理内存，并将 PTE_W 设置为 0。同时为了标记一个页面是写时复制页面，我们要给 PTE 打一个新的标记 PTE_COW，这里可以用到 RSW 位。\n\n在 riscv.h 中添加\n\n#define PTE_COW (1L << 8)\n\n\n回到 uvmcopy，我们遍历父进程的页表，对每个 PTE 设置其标记位和获取对应的物理地址 pa，接着我们给新进程的页表的每一个同样位置的 PTE，与 pa 也进行映射，并且引用计数 + 1\n\nint uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) {\n  pte_t *pte;\n  uint64 pa, i;\n  uint flags;\n  for (i = 0; i < sz; i += PGSIZE) {\n    if((pte = walk(old, i, 0)) == 0)\n      panic("uvmcopy: pte should exist");\n    if((*pte & PTE_V) == 0)\n      panic("uvmcopy: page not present");\n    *pte &= ~PTE_W; // 将 PTE_W 位 置为 0\n    *pte |= PTE_COW; // 设置 PTE_COW 位\n    pa = PTE2PA(*pte);\n    flags = PTE_FLAGS(*pte);\n    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){\n      panic("uvmcopy: mappages");\n      goto err;\n    }\n    ref_cnt[pageid(pa)]++;\n  }\n\n  return 0;\n  err:\n  uvmunmap(new, 0, i / PGSIZE, 1);\n  return -1;\n}\n\n\n然后我们进入 trap.c 来对这种 page fault 进行处理。\n\n根据文档，我们知道此时对应的异常码是 15\n\n\n\n另外我们还要检查虚拟地址是否合法，指向的 PTE 是否是一个 cow 页面...，如果都符合我们就根据实验文档所说的 copy the old page to the new page, and install the new page in the PTE with PTE_W set.\n\nvoid usertrap(void) {\n//......\nelse if ((r_scause() == 15) && checkcow(r_stval())) { \n    if (cow_fault(r_stval()) != 0) {\n      panic("usertrap: cow_fault");\n      p->killed = 1;\n    }\n//......\n}\n\n\n下面是检查虚拟地址的代码 checkcow：「具体看注释」\n\nint checkcow(uint64 va) {\n  pte_t *pte;\n  struct proc *p = myproc();\n  if (va >= MAXVA) return 0; // 虚拟地址是否在合法范围内\n  if ((pte = walk(p->pagetable, va, 0)) == 0) return 0; // 是否能找到对应的 PTE\n  if (!(*pte & PTE_V) || !(*pte & PTE_COW)) return 0; // PTE_V 有效位是否被设置，PTE_COW 是否被设置\n  return 1;\n}\n\n\n下面是实际拷贝的代码 cow_fault： 「具体看注释」\n\nint cow_fault(uint64 va) {\n  va = PGROUNDDOWN(va); // 要 page-aligned\n  pte_t *pte;\n  struct proc *p = myproc();\n  if ((pte = walk(p->pagetable, va, 0)) == 0) { // 获取 PTE\n    panic("cow_fault: walk");\n  }\n  uint64 old = PTE2PA(*pte); // 获取 PTE 对应的物理地址\n  uint64 new;\n  uint64 flags = (PTE_FLAGS(*pte) | PTE_W) & ~PTE_COW; // 取消 PTE_COW 位，设置 PTE_W 位\n  if ((new = (uint64)kalloc()) == 0) { // 分配新的物理内存\n    panic("cow_fault: kalloc panic");\n  }\n  memmove((void *)new, (void *)old, PGSIZE); // 实际拷贝操作\n  uvmunmap(p->pagetable, va, 1, 1); // 取消 PTE 与原来的物理内存的映射\n  if (mappages(p->pagetable, va, PGSIZE, new, flags) != 0) { // 与 new 建立新的映射，并设置了新的标志位\n    panic("cow_fault: mappages");\n    kfree((void *)new);\n    return -1;\n  }\n  return 0;\n}\n\n\n这样一来，copy-on-write 就基本完成了，另外根据实验文档，我们还要在 copyout 函数中运用写时复制。\n\n先对虚拟地址 va0 进行检查，如果符合则进行写时复制。\n\nint copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {\n  uint64 n, va0, pa0;\n  while(len > 0){\n    va0 = PGROUNDDOWN(dstva);\n    if (checkcow(va0)) { // copy-on-write\n      if (cow_fault(va0) != 0) {\n        return -1;\n      }\n    }\n    pa0 = walkaddr(pagetable, va0);\n    if(pa0 == 0)\n      return -1;\n    n = PGSIZE - (dstva - va0);\n    if(n > len)\n      n = len;\n    memmove((void *)(pa0 + (dstva - va0)), src, n);\n    len -= n;\n    src += n;\n    dstva = va0 + PGSIZE;\n  }\n  return 0;\n}\n\n\n\n# 实验结果\n\n\n\n# TODO\n\n给页面上把读写锁，保证进程安全（不过好像测试用例没有这部分要求？）',normalizedContent:'# [mit6.s081]lab5: copy-on-write fork for xv6\n\nlab: copy-on-write fork for xv6 (mit.edu)\n\n\n# 1、implement copy-on write\n\n这个 lab 中我们要实现写时复制。\n\n我们知道当一个进程 fork 出一个子进程后，子进程会复制父进程的所有内容，那么此时如果子进程执行了 exec，则会将刚刚复制完的内容又全部重置。我们知道拷贝是非常耗时的，如果每次像这样复制必然会产生许多的浪费。\n\n于是便有了写时复制，在 fork 出一个子进程后，我们不进行拷贝，而是将父子进程的页表映射到同一块物理内存，并将 pte_w 都置为 0，当父子进程需要写这个地址时，便会产生 page fault，在遇到这种情况后我们才进行实际的拷贝操作。\n\n接下来我们开始写代码 💻\n\n因为此时同一块物理可能被多个进程所共享，那么我们就不能随意释放内存，而是要引入一个新的变量，作为引用计数，类似于 c++ 里的智能指针，只要当一块内存的引用计数为 0 了，才会释放该内存。\n\n在 kalloc.c 中添加引用计数变量\n\nint ref_cnt[(phystop - kernbase) / pgsize];\n\n\n我们对应的在新分配一块内存时也要将引用计数初始化为 1\n\nvoid *kalloc(void) {\n  struct run *r;\n\n  acquire(&kmem.lock);\n  r = kmem.freelist;\n  if(r)\n    kmem.freelist = r->next;\n  release(&kmem.lock);\n\n  if(r) {\n    ref_cnt[pageid(r)] = 1; // 初始化引用计数为 1 \n    memset((char*)r, 5, pgsize); // fill with junk\n  }\n  return (void*)r;\n}\n\n\n\n在释放内存的时候，如果引用计数 > 1 时，就将其减 1，否则再释放\n\nvoid kfree(void *pa) {\n  struct run *r;\n\n  if(((uint64)pa % pgsize) != 0 || (char*)pa < end || (uint64)pa >= phystop)\n    panic("kfree");\n\n  if (ref_cnt[pageid(pa)] > 1) { // 引用计数减 1\n    ref_cnt[pageid(pa)]--;\n    return;\n  }\n\n  // fill with junk to catch dangling refs.\n  memset(pa, 1, pgsize);\n\n  r = (struct run*)pa;\n\n  acquire(&kmem.lock);\n  r->next = kmem.freelist;\n  kmem.freelist = r;\n  release(&kmem.lock);\n}\n\n\n之后我们要对 uvmcopy 函数进行修改，当 fork 出一个子进程后，我们要让父子进程共享同一块物理内存，并将 pte_w 设置为 0。同时为了标记一个页面是写时复制页面，我们要给 pte 打一个新的标记 pte_cow，这里可以用到 rsw 位。\n\n在 riscv.h 中添加\n\n#define pte_cow (1l << 8)\n\n\n回到 uvmcopy，我们遍历父进程的页表，对每个 pte 设置其标记位和获取对应的物理地址 pa，接着我们给新进程的页表的每一个同样位置的 pte，与 pa 也进行映射，并且引用计数 + 1\n\nint uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) {\n  pte_t *pte;\n  uint64 pa, i;\n  uint flags;\n  for (i = 0; i < sz; i += pgsize) {\n    if((pte = walk(old, i, 0)) == 0)\n      panic("uvmcopy: pte should exist");\n    if((*pte & pte_v) == 0)\n      panic("uvmcopy: page not present");\n    *pte &= ~pte_w; // 将 pte_w 位 置为 0\n    *pte |= pte_cow; // 设置 pte_cow 位\n    pa = pte2pa(*pte);\n    flags = pte_flags(*pte);\n    if(mappages(new, i, pgsize, (uint64)pa, flags) != 0){\n      panic("uvmcopy: mappages");\n      goto err;\n    }\n    ref_cnt[pageid(pa)]++;\n  }\n\n  return 0;\n  err:\n  uvmunmap(new, 0, i / pgsize, 1);\n  return -1;\n}\n\n\n然后我们进入 trap.c 来对这种 page fault 进行处理。\n\n根据文档，我们知道此时对应的异常码是 15\n\n\n\n另外我们还要检查虚拟地址是否合法，指向的 pte 是否是一个 cow 页面...，如果都符合我们就根据实验文档所说的 copy the old page to the new page, and install the new page in the pte with pte_w set.\n\nvoid usertrap(void) {\n//......\nelse if ((r_scause() == 15) && checkcow(r_stval())) { \n    if (cow_fault(r_stval()) != 0) {\n      panic("usertrap: cow_fault");\n      p->killed = 1;\n    }\n//......\n}\n\n\n下面是检查虚拟地址的代码 checkcow：「具体看注释」\n\nint checkcow(uint64 va) {\n  pte_t *pte;\n  struct proc *p = myproc();\n  if (va >= maxva) return 0; // 虚拟地址是否在合法范围内\n  if ((pte = walk(p->pagetable, va, 0)) == 0) return 0; // 是否能找到对应的 pte\n  if (!(*pte & pte_v) || !(*pte & pte_cow)) return 0; // pte_v 有效位是否被设置，pte_cow 是否被设置\n  return 1;\n}\n\n\n下面是实际拷贝的代码 cow_fault： 「具体看注释」\n\nint cow_fault(uint64 va) {\n  va = pgrounddown(va); // 要 page-aligned\n  pte_t *pte;\n  struct proc *p = myproc();\n  if ((pte = walk(p->pagetable, va, 0)) == 0) { // 获取 pte\n    panic("cow_fault: walk");\n  }\n  uint64 old = pte2pa(*pte); // 获取 pte 对应的物理地址\n  uint64 new;\n  uint64 flags = (pte_flags(*pte) | pte_w) & ~pte_cow; // 取消 pte_cow 位，设置 pte_w 位\n  if ((new = (uint64)kalloc()) == 0) { // 分配新的物理内存\n    panic("cow_fault: kalloc panic");\n  }\n  memmove((void *)new, (void *)old, pgsize); // 实际拷贝操作\n  uvmunmap(p->pagetable, va, 1, 1); // 取消 pte 与原来的物理内存的映射\n  if (mappages(p->pagetable, va, pgsize, new, flags) != 0) { // 与 new 建立新的映射，并设置了新的标志位\n    panic("cow_fault: mappages");\n    kfree((void *)new);\n    return -1;\n  }\n  return 0;\n}\n\n\n这样一来，copy-on-write 就基本完成了，另外根据实验文档，我们还要在 copyout 函数中运用写时复制。\n\n先对虚拟地址 va0 进行检查，如果符合则进行写时复制。\n\nint copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {\n  uint64 n, va0, pa0;\n  while(len > 0){\n    va0 = pgrounddown(dstva);\n    if (checkcow(va0)) { // copy-on-write\n      if (cow_fault(va0) != 0) {\n        return -1;\n      }\n    }\n    pa0 = walkaddr(pagetable, va0);\n    if(pa0 == 0)\n      return -1;\n    n = pgsize - (dstva - va0);\n    if(n > len)\n      n = len;\n    memmove((void *)(pa0 + (dstva - va0)), src, n);\n    len -= n;\n    src += n;\n    dstva = va0 + pgsize;\n  }\n  return 0;\n}\n\n\n\n# 实验结果\n\n\n\n# todo\n\n给页面上把读写锁，保证进程安全（不过好像测试用例没有这部分要求？）',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab6: Multithreading",frontmatter:{title:null,date:"2023-02-20T14:27:08.000Z",permalink:"/pages/2bb440/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/06.Lab6:%20Multithreading.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/06.Lab6: Multithreading.md",key:"v-df166c36",path:"/pages/2bb440/",headers:[{level:3,title:"Uthread: switching between threads",slug:"uthread-switching-between-threads",normalizedTitle:"uthread: switching between threads",charIndex:69},{level:2,title:"Using threads",slug:"using-threads",normalizedTitle:"using threads",charIndex:2020},{level:3,title:"Barrier",slug:"barrier",normalizedTitle:"barrier",charIndex:2839},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:3670}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"Uthread: switching between threads Using threads Barrier 实验结果",content:"# [MIT6.S081]Lab6: Multithreading\n\nLab: Multithreading (mit.edu)\n\n\n# Uthread: switching between threads\n\n这个 assignment 比较简单，我们要实现线程之间的切换，如果读懂了进程切换的源码的话其实就很好做。\n\n对于 kernel/swtch.S 传入了两个参数 old 和 new，我们将当前 cpu 寄存器的上下文保存到 old 里面保存，然后将 new 放到 cpu 寄存器中，获取控制权。\n\n我们先给每个线程定义一个一模一样的 struct context\n\n// uthread.c\nstruct context {\n  uint64 ra;\n  uint64 sp;\n\n  // callee-saved\n  uint64 s0;\n  uint64 s1;\n  uint64 s2;\n  uint64 s3;\n  uint64 s4;\n  uint64 s5;\n  uint64 s6;\n  uint64 s7;\n  uint64 s8;\n  uint64 s9;\n  uint64 s10;\n  uint64 s11;\n};\n\nstruct thread {\n  char       stack[STACK_SIZE]; /* the thread's stack */\n  int        state;             /* FREE, RUNNING, RUNNABLE */\n  struct context context;\n};\n\n\n之后我们模仿 swtch.S，在 uthread_switch.S 添加实现的代码\n\n// uthread_switch.S\nthread_switch:\n\t/* YOUR CODE HERE */\n\tsd ra, 0(a0)\n\tsd sp, 8(a0)\n\tsd s0, 16(a0)\n\tsd s1, 24(a0)\n\tsd s2, 32(a0)\n\tsd s3, 40(a0)\n\tsd s4, 48(a0)\n\tsd s5, 56(a0)\n\tsd s6, 64(a0)\n\tsd s7, 72(a0)\n\tsd s8, 80(a0)\n\tsd s9, 88(a0)\n\tsd s10, 96(a0)\n\tsd s11, 104(a0)\n\n\tld ra, 0(a1) \n\tld sp, 8(a1)\n\tld s0, 16(a1)\n\tld s1, 24(a1)\n\tld s2, 32(a1)\n\tld s3, 40(a1)\n\tld s4, 48(a1)\n\tld s5, 56(a1)\n\tld s6, 64(a1)\n\tld s7, 72(a1)\n\tld s8, 80(a1)\n\tld s9, 88(a1)\n\tld s10, 96(a1)\n\tld s11, 104(a1)\n\t\n\tret    /* return to ra */\n\n\n\n我们在创建一个线程的时候，先要将线程的 ra 也就是返回地址，之后执行位置的开始设置为运行的函数起点也就是函数指针 func，栈指针也指向栈顶 t->stack + STACK_SIZE\n\nvoid thread_create(void (*func)()) {\n  // ......\n  // YOUR CODE HERE\n  t->context.ra = (uint64)func;\n  t->context.sp = (uint64)t->stack + STACK_SIZE;\n}\n\n\n最后我们在 thread_schedule 函数中调用之前实现好的 thread_switch 即可。\n\n需要注意的是，我们是要将线程从 t 切换到 next_thread\n\nvoid thread_schedule(void) {\n  // ......\n\n  if (current_thread != next_thread) {         /* switch threads?  */\n    next_thread->state = RUNNING;\n    t = current_thread;\n    current_thread = next_thread;\n    /* YOUR CODE HERE\n     * Invoke thread_switch to switch from t to next_thread:\n     * thread_switch(??, ??);\n     */\n    thread_switch((uint64)&t->context, (uint64)&current_thread->context);\n  } else\n    next_thread = 0;\n}\n\n\n\n# Using threads\n\n这个 assignment 更简单了。\n\n我们直接两个任务一起完成，只需要在 put 和 get 函数中进行赋值的地方上把锁就可以了。\n\n需要注意的是，我们只需要给 put 的复制和 insert 这部分代码上锁，这样一来我们相当于给每一个 table[i] 都上了把锁，尽可能降低了锁的粒度。\n\nstatic void put(int key, int value) {\n  int i = key % NBUCKET;\n\n  // is the key already present?\n  struct entry *e = 0;\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key)\n      break;\n  }\n  pthread_mutex_lock(&lock);\n  if(e){\n    // update the existing key.\n    e->value = value;\n  } else {\n    // the new is new.\n    insert(key, value, &table[i], table[i]);\n  }\n  pthread_mutex_unlock(&lock);\n}\n\nstatic struct entry* get(int key) {\n  int i = key % NBUCKET;\n\n  pthread_mutex_lock(&lock);\n  struct entry *e = 0;\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key) break;\n  }\n  pthread_mutex_unlock(&lock);\n  return e;\n}\n\n\n\n# Barrier\n\n这个 assignment 要实现屏障同步机制，\n\n我们维护了一个数据结构 bstate，bstate.round 表示当前是第几个 round，每个 round 里所有线程会同步，最后一起被唤醒，而 bstate.nthread 表示到达当前 round 的线程数量。\n\n我们每次一个线程进入 barrier 后，会先令 bstate.nthread++，如果此时其值等于 nthread，则表示所有线程都到达了，那么此时 barrier.round 要加一，另外 bstate.nthread 要清零，然后我们唤醒所有进程，结束这一轮 round。而如果还小于 nthread，那么我们就要令该线程进入等待状态。\n\n另外要注意由于 bstate，是所有进程共享的，所以要上锁防止数据竞争。\n\nstatic void barrier() {\n  // YOUR CODE HERE\n  //\n  // Block until all threads have called barrier() and\n  // then increment bstate.round.\n  //\n\n  pthread_mutex_lock(&bstate.barrier_mutex);\n  bstate.nthread++;\n  if (bstate.nthread < nthread) {\n    pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);\n  } else {\n    bstate.nthread = 0;\n    bstate.round++;\n    pthread_cond_broadcast(&bstate.barrier_cond);\n  }\n  pthread_mutex_unlock(&bstate.barrier_mutex);\n}\n\n\n\n# 实验结果\n\n",normalizedContent:"# [mit6.s081]lab6: multithreading\n\nlab: multithreading (mit.edu)\n\n\n# uthread: switching between threads\n\n这个 assignment 比较简单，我们要实现线程之间的切换，如果读懂了进程切换的源码的话其实就很好做。\n\n对于 kernel/swtch.s 传入了两个参数 old 和 new，我们将当前 cpu 寄存器的上下文保存到 old 里面保存，然后将 new 放到 cpu 寄存器中，获取控制权。\n\n我们先给每个线程定义一个一模一样的 struct context\n\n// uthread.c\nstruct context {\n  uint64 ra;\n  uint64 sp;\n\n  // callee-saved\n  uint64 s0;\n  uint64 s1;\n  uint64 s2;\n  uint64 s3;\n  uint64 s4;\n  uint64 s5;\n  uint64 s6;\n  uint64 s7;\n  uint64 s8;\n  uint64 s9;\n  uint64 s10;\n  uint64 s11;\n};\n\nstruct thread {\n  char       stack[stack_size]; /* the thread's stack */\n  int        state;             /* free, running, runnable */\n  struct context context;\n};\n\n\n之后我们模仿 swtch.s，在 uthread_switch.s 添加实现的代码\n\n// uthread_switch.s\nthread_switch:\n\t/* your code here */\n\tsd ra, 0(a0)\n\tsd sp, 8(a0)\n\tsd s0, 16(a0)\n\tsd s1, 24(a0)\n\tsd s2, 32(a0)\n\tsd s3, 40(a0)\n\tsd s4, 48(a0)\n\tsd s5, 56(a0)\n\tsd s6, 64(a0)\n\tsd s7, 72(a0)\n\tsd s8, 80(a0)\n\tsd s9, 88(a0)\n\tsd s10, 96(a0)\n\tsd s11, 104(a0)\n\n\tld ra, 0(a1) \n\tld sp, 8(a1)\n\tld s0, 16(a1)\n\tld s1, 24(a1)\n\tld s2, 32(a1)\n\tld s3, 40(a1)\n\tld s4, 48(a1)\n\tld s5, 56(a1)\n\tld s6, 64(a1)\n\tld s7, 72(a1)\n\tld s8, 80(a1)\n\tld s9, 88(a1)\n\tld s10, 96(a1)\n\tld s11, 104(a1)\n\t\n\tret    /* return to ra */\n\n\n\n我们在创建一个线程的时候，先要将线程的 ra 也就是返回地址，之后执行位置的开始设置为运行的函数起点也就是函数指针 func，栈指针也指向栈顶 t->stack + stack_size\n\nvoid thread_create(void (*func)()) {\n  // ......\n  // your code here\n  t->context.ra = (uint64)func;\n  t->context.sp = (uint64)t->stack + stack_size;\n}\n\n\n最后我们在 thread_schedule 函数中调用之前实现好的 thread_switch 即可。\n\n需要注意的是，我们是要将线程从 t 切换到 next_thread\n\nvoid thread_schedule(void) {\n  // ......\n\n  if (current_thread != next_thread) {         /* switch threads?  */\n    next_thread->state = running;\n    t = current_thread;\n    current_thread = next_thread;\n    /* your code here\n     * invoke thread_switch to switch from t to next_thread:\n     * thread_switch(??, ??);\n     */\n    thread_switch((uint64)&t->context, (uint64)&current_thread->context);\n  } else\n    next_thread = 0;\n}\n\n\n\n# using threads\n\n这个 assignment 更简单了。\n\n我们直接两个任务一起完成，只需要在 put 和 get 函数中进行赋值的地方上把锁就可以了。\n\n需要注意的是，我们只需要给 put 的复制和 insert 这部分代码上锁，这样一来我们相当于给每一个 table[i] 都上了把锁，尽可能降低了锁的粒度。\n\nstatic void put(int key, int value) {\n  int i = key % nbucket;\n\n  // is the key already present?\n  struct entry *e = 0;\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key)\n      break;\n  }\n  pthread_mutex_lock(&lock);\n  if(e){\n    // update the existing key.\n    e->value = value;\n  } else {\n    // the new is new.\n    insert(key, value, &table[i], table[i]);\n  }\n  pthread_mutex_unlock(&lock);\n}\n\nstatic struct entry* get(int key) {\n  int i = key % nbucket;\n\n  pthread_mutex_lock(&lock);\n  struct entry *e = 0;\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key) break;\n  }\n  pthread_mutex_unlock(&lock);\n  return e;\n}\n\n\n\n# barrier\n\n这个 assignment 要实现屏障同步机制，\n\n我们维护了一个数据结构 bstate，bstate.round 表示当前是第几个 round，每个 round 里所有线程会同步，最后一起被唤醒，而 bstate.nthread 表示到达当前 round 的线程数量。\n\n我们每次一个线程进入 barrier 后，会先令 bstate.nthread++，如果此时其值等于 nthread，则表示所有线程都到达了，那么此时 barrier.round 要加一，另外 bstate.nthread 要清零，然后我们唤醒所有进程，结束这一轮 round。而如果还小于 nthread，那么我们就要令该线程进入等待状态。\n\n另外要注意由于 bstate，是所有进程共享的，所以要上锁防止数据竞争。\n\nstatic void barrier() {\n  // your code here\n  //\n  // block until all threads have called barrier() and\n  // then increment bstate.round.\n  //\n\n  pthread_mutex_lock(&bstate.barrier_mutex);\n  bstate.nthread++;\n  if (bstate.nthread < nthread) {\n    pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);\n  } else {\n    bstate.nthread = 0;\n    bstate.round++;\n    pthread_cond_broadcast(&bstate.barrier_cond);\n  }\n  pthread_mutex_unlock(&bstate.barrier_mutex);\n}\n\n\n\n# 实验结果\n\n",charsets:{cjk:!0}},{title:"[MIT6.S081]Lab7: Networking",frontmatter:{title:null,date:"2023-02-21T20:16:29.000Z",permalink:"/pages/b8b8a2/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/07.Lab7:%20Networking.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/07.Lab7: Networking.md",key:"v-ea583cf6",path:"/pages/b8b8a2/",headers:[{level:3,title:"Your Job (net)",slug:"your-job-net",normalizedTitle:"your job (net)",charIndex:61},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:1692}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"Your Job (net) 实验结果",content:"# [MIT6.S081]Lab7: Networking\n\nLab: networking (mit.edu)\n\n\n# Your Job (net)\n\n这个 assignment 的实现部分非常简单，难点在于概念和流程的理解上面，感觉自己计网学的还不是很扎实）。在这里我们要为网卡的驱动程序编写代码，能实现对数据的发送和接受。\n\n这个 lab 的 hint 基本就是为代码了，跟着 hint 一步一步实现就可以了。\n\nint\ne1000_transmit(struct mbuf *m)\n{\n  //\n  // Your code here.\n  //\n  // the mbuf contains an ethernet frame; program it into\n  // the TX descriptor ring so that the e1000 sends it. Stash\n  // a pointer so that it can be freed after sending.\n  //\n  \n  acquire(&e1000_lock); // 获取锁，防止 race\n  uint32 tx_idx = regs[E1000_TDT]; // 获取下一个缓冲区下表\n  if ((tx_ring[tx_idx].status & E1000_TXD_STAT_DD) == 0) { // 如果该标志位没有设置，则说明 overflow 了，返回错误\n    release(&e1000_lock);\n    return -1;\n  }\n\n  if (tx_mbufs[tx_idx] != 0) { // 如果有未释放的mbuf就释放\n    mbuffree(tx_mbufs[tx_idx]);\n  }\n  \n  // 填充 descriptor\n  tx_ring[tx_idx].addr = (uint64)m->head;\n  tx_ring[tx_idx].length = m->len;\n  tx_ring[tx_idx].cmd = E1000_TXD_CMD_EOP  | E1000_TXD_CMD_RS;\n  tx_mbufs[tx_idx] = m;\n\n  // 位置加一\n  regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;\n\n  release(&e1000_lock);\n\n  return 0;\n}\n\nstatic void\ne1000_recv(void)\n{\n  //\n  // Your code here.\n  //\n  // Check for packets that have arrived from the e1000\n  // Create and deliver an mbuf for each packet (using net_rx()).\n  //\n  while (1) {\n    uint32 rx_idx = (regs[E1000_RDT] + 1 ) %  RX_RING_SIZE;\n\n    if ((rx_ring[rx_idx].status & E1000_RXD_STAT_DD) == 0) {\n      break;\n    }\n\n    rx_mbufs[rx_idx]->len = rx_ring[rx_idx].length;\n    net_rx(rx_mbufs[rx_idx]);\n    rx_mbufs[rx_idx] = mbufalloc(0);\n    \n    // 填充 descriptor\n    rx_ring[rx_idx].addr = (uint64)rx_mbufs[rx_idx]->head;\n    rx_ring[rx_idx].status = 0;\n\n    regs[E1000_RDT] = rx_idx;\n  }\n\n}\n\n\n\n# 实验结果\n",normalizedContent:"# [mit6.s081]lab7: networking\n\nlab: networking (mit.edu)\n\n\n# your job (net)\n\n这个 assignment 的实现部分非常简单，难点在于概念和流程的理解上面，感觉自己计网学的还不是很扎实）。在这里我们要为网卡的驱动程序编写代码，能实现对数据的发送和接受。\n\n这个 lab 的 hint 基本就是为代码了，跟着 hint 一步一步实现就可以了。\n\nint\ne1000_transmit(struct mbuf *m)\n{\n  //\n  // your code here.\n  //\n  // the mbuf contains an ethernet frame; program it into\n  // the tx descriptor ring so that the e1000 sends it. stash\n  // a pointer so that it can be freed after sending.\n  //\n  \n  acquire(&e1000_lock); // 获取锁，防止 race\n  uint32 tx_idx = regs[e1000_tdt]; // 获取下一个缓冲区下表\n  if ((tx_ring[tx_idx].status & e1000_txd_stat_dd) == 0) { // 如果该标志位没有设置，则说明 overflow 了，返回错误\n    release(&e1000_lock);\n    return -1;\n  }\n\n  if (tx_mbufs[tx_idx] != 0) { // 如果有未释放的mbuf就释放\n    mbuffree(tx_mbufs[tx_idx]);\n  }\n  \n  // 填充 descriptor\n  tx_ring[tx_idx].addr = (uint64)m->head;\n  tx_ring[tx_idx].length = m->len;\n  tx_ring[tx_idx].cmd = e1000_txd_cmd_eop  | e1000_txd_cmd_rs;\n  tx_mbufs[tx_idx] = m;\n\n  // 位置加一\n  regs[e1000_tdt] = (regs[e1000_tdt] + 1) % tx_ring_size;\n\n  release(&e1000_lock);\n\n  return 0;\n}\n\nstatic void\ne1000_recv(void)\n{\n  //\n  // your code here.\n  //\n  // check for packets that have arrived from the e1000\n  // create and deliver an mbuf for each packet (using net_rx()).\n  //\n  while (1) {\n    uint32 rx_idx = (regs[e1000_rdt] + 1 ) %  rx_ring_size;\n\n    if ((rx_ring[rx_idx].status & e1000_rxd_stat_dd) == 0) {\n      break;\n    }\n\n    rx_mbufs[rx_idx]->len = rx_ring[rx_idx].length;\n    net_rx(rx_mbufs[rx_idx]);\n    rx_mbufs[rx_idx] = mbufalloc(0);\n    \n    // 填充 descriptor\n    rx_ring[rx_idx].addr = (uint64)rx_mbufs[rx_idx]->head;\n    rx_ring[rx_idx].status = 0;\n\n    regs[e1000_rdt] = rx_idx;\n  }\n\n}\n\n\n\n# 实验结果\n",charsets:{cjk:!0}},{title:"[MIT6.S081]Lab8: Locks",frontmatter:{title:null,date:"2023-02-22T14:53:28.000Z",permalink:"/pages/19fce7/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/08.Lab8:%20Locks.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/08.Lab8: Locks.md",key:"v-2c3fadad",path:"/pages/19fce7/",headers:[{level:3,title:"Memory allocator",slug:"memory-allocator",normalizedTitle:"memory allocator",charIndex:51},{level:3,title:"Buffer cache",slug:"buffer-cache",normalizedTitle:"buffer cache",charIndex:1664},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:6512}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"Memory allocator Buffer cache 实验结果",content:'# [MIT6.S081]Lab8: Locks\n\nLab: locks (mit.edu)\n\n\n# Memory allocator\n\n这个 assignment 要我们改进内核的页面分配机制，本来是所有 cpu 共享一个空闲链表，然后对其上一把锁，现在我们改为给每一个 cpu 分配一个空闲链表，各自上一把锁，如果当前 cpu 的链表空间用完了再去借其他 cpu 的。\n\n下面操作都在文件 kernel/kalloc.c 中进行\n\n先将 kmem 变成数组类型\n\nstruct {\n  struct spinlock lock;\n  struct run *freelist;\n} kmem[NPROC];\n\n\n在 kinit() 中我们初始化每个 kmem 的锁\n\nvoid kinit() {\n  // initlock(&kmem.lock, "kmem");\n  for (int i = 0; i < NPROC; i++) {\n    initlock(&kmem[i].lock, "kmem");\n  }\n  freerange(end, (void*)PHYSTOP);\n}\n\n\n在释放的时候，也是先获取 cpuid 然后释放对应的空闲链表的空间\n\nvoid kfree(void *pa) {\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic("kfree");\n\n  // Fill with junk to catch dangling refs.\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n\n  push_off();\n  int c = cpuid();\n  pop_off();\n\n  acquire(&kmem[c].lock);\n  r->next = kmem[c].freelist;\n  kmem[c].freelist = r;\n  release(&kmem[c].lock);\n}\n\n\n需要注意的是 cpuid() 需要在中断关闭的时候使用，所以要先 push_off()，之后再用 pop_off() 打开。\n\n而在 kalloc() 中，如果当前 cpu 的空闲链表用完了，则需要遍历其他的 cpu 来借空间，全程要记得上锁释放锁！\n\nvoid * kalloc(void) {\n  struct run *r;\n\n  push_off();  \n  int c = cpuid();\n  pop_off();\n\n  acquire(&kmem[c].lock);\n  r = kmem[c].freelist;\n  if(r) {\n    kmem[c].freelist = r->next;\n  }\n  release(&kmem[c].lock);\n  if (!r) { // 借其他 cpu 的空闲链表\n    for (int i = 0; i < NCPU; i++) {\n      if (i != c) {\n        acquire(&kmem[i].lock);\n        r = kmem[i].freelist;\n        if (r) {\n          kmem[i].freelist = r->next;\n          release(&kmem[i].lock);\n          break;\n        }\n        release(&kmem[i].lock);\n      }\n    }\n  }\n\n  if(r)\n    memset((char*)r, 5, PGSIZE); // fill with junk\n  return (void*)r;\n}\n\n\n\n# Buffer cache\n\n在这个 assignment 中所有的 cpu 都共享着同一个 cache，为了避免单一的锁所带来的低性能，我们要修改这种 cache 的管理策略。\n\n我们先给每块 buffer 都加了把锁，然后我们通过将不同 buffer 映射到一个哈希表上的各个桶中，通过对桶的锁管理，来降低锁的粒度，提高运行效率。\n\n哈希表的长度 NBUCKET 选择素数 13，素数可以减小哈希冲突的可能，我们给每个桶分配了一段空闲的 buffer 链表，然后在查找 buffer 块的时候，根据 blockno 来将块映射到桶上。另外查找的过程中，如果它已经被 cache 了，那么我们直接可以 get 到。如果他没有被 cache，那么我们就要给它分配一个空闲块进行 cache，有分配那就有分配完的一天，也就会有替换操作，在我们选择被替换的 buffer 块时，我们要采用选择 LRU(Least Recently Used)策略。\n\n首先我们要在 struct buf 中加入时间戳变量\n\n// buf.h\nstruct buf {\n  int valid;   // has data been read from disk?\n  int disk;    // does disk "own" buf?\n  uint dev;\n  uint blockno;\n  struct sleeplock lock;\n  uint refcnt;\n  struct buf *prev; // LRU cache list\n  struct buf *next;\n  uchar data[BSIZE];\n\n  uint ticks; // 时间戳\n};\n\n\n接着我们回到 bio.c 中开始实现\n\n我们先宏定义一下哈希表的长度以及定义一下哈希表数组，并且声明一下 trap.c 中的 ticks，另外还要将单个锁都定义为数组形式\n\n#define NBUCKET 13\n\nextern uint ticks; // 声明外部变量 (trap.c 中的 ticks)\n\nstruct {\n  struct spinlock lock[NBUCKET]; // 桶锁\n  struct buf buf[NBUF];\n\n  // Linked list of all buffers, through prev/next.\n  // Sorted by how recently the buffer was used.\n  // head.next is most recent, head.prev is least.\n  struct buf head[NBUCKET];\n} bcache;\n\nint hash(int x) {\n  return x % NBUCKET;\n}\n\n\n对应的从单个锁变成了每个块和桶都有把锁，我们在 binit() 中也要全部初始化。\n\n另外为了方便，我们一开始将所有的空闲 buffer 全都连在了哈希表的首位后面。\n\nvoid binit(void) {\n  struct buf *b;\n\n  // 初始化哈希表的桶锁\n  for (int i = 0; i < NBUCKET; i++) {\n    initlock(&bcache.lock[i], "bcache");\n  } \n\n  // 初始化每块 buffer 的锁，并且双向链表变为单向链表，初始时全都接在 bcache.head[0] 后面\n  bcache.head[0].next = &bcache.buf[0];\n  for (int i = 0; i < NBUF - 1; i++) {\n    b = &bcache.buf[i];\n    b->next = b + 1;\n    initsleeplock(&b->lock, "buffer");\n  }\n}\n\n\n在实现获取 buffer 块 bget() 之前，我们先要实现函数 replace_cache 用来更新 cache 的值\n\nvoid replace_cache(struct buf *b, uint dev, uint blockno) {\n  b->dev = dev;\n  b->blockno = blockno;\n  b->refcnt = 1; // 引用计数设置为 1 \n  b->valid = 0;\n}\n\n\n接下来开始实现 bget()\n\n【在实现这个函数的时候 当块没有被 cache 的情况参考了MIT 6.s081 xv6-lab8-lock - 知乎 (zhihu.com)】\n\n首先我们先要获取 buffer 块对应的哈希值，以找到对应的桶，接着考虑如果这个 buffer 块已经被 cache 的情况\n\n  struct buf *b;\n\n  int hashid = hash(blockno); // 获取哈希值，看看映射到哪个桶\n  acquire(&bcache.lock[hashid]); // 获取这个桶的锁\n\n  // Is the block already cached? 该 block 已经被 cached 了的情况\n  for(b = bcache.head[hashid].next; b; b = b->next){ // 单向链表遍历\n    if(b->dev == dev && b->blockno == blockno){\n      b->refcnt++;\n      release(&bcache.lock[hashid]); // 返回前释放这个桶的锁\n      acquiresleep(&b->lock); // 获取这个 buffer 的锁\n      return b;\n    }\n  }\n\n\n接着考虑没有被 cache 的情况，先看看当前映射到的桶中是否有空闲块\n\n  // 如果该 block 没有被 cache\n  // 1. 查找当前桶中是否有空闲块\n  for (b = bcache.head[hashid].next; b; b = b->next) {\n    if (b->refcnt == 0) { // 是一个空闲块\n      replace_cache(b, dev, blockno);\n      release(&bcache.lock[hashid]);\n      acquiresleep(&b->lock);\n      return b;\n    }\n  }\n\n\n然后我们查找其他桶中是否有空闲块，\n\n// 2. 查找其他桶中是否有空闲块，并且选择 LRU\n  int bucket_id = -1; // 当前选中的空闲块所在的桶编号\n  struct buf *pre;\n  struct buf *take_buf = 0;\n  struct buf *last_take = 0;\n  uint time = __UINT32_MAX__;\n  for (int i = 0; i < NBUCKET; i++) { // 遍历所有桶\n    if (i == hashid) continue;\n    acquire(&bcache.lock[i]); // 获取当前桶的锁\n    for (b = bcache.head[i].next, pre = &bcache.head[i]; b; b = b->next, pre = pre->next) { // 遍历这个桶拥有的空闲块\n      if (b->refcnt == 0 && b->ticks < time) { // 如果是空闲块，并且上次使用的时间更早\n        time = b->ticks; // 更新时间戳\n        last_take = pre; // 记录一下当前位置前一个块的为主子\n        take_buf = b; // 目前选中的空闲块\n        if (bucket_id != -1 && bucket_id != i && holding(&bcache.lock[bucket_id])) { // 如果前一个选中的块不在当前的桶中，则释放前一个块锁持有的桶锁\n          release(&bcache.lock[bucket_id]);\n        }\n        bucket_id = i; // 更新桶编号\n      }\n    }\n    if (bucket_id != i) { // 如果没有用到这个桶，则释放桶锁\n      release(&bcache.lock[i]);\n    }\n  }\n  if (!take_buf) { // 没有找到空闲块\n    panic("bget: no buffers");\n  }\n\n\n在我们找到目标块之后，我们要将他移到当前映射到的桶中，具体的方法其实就是链表的增删，还是比较简单的。\n\n  replace_cache(take_buf, dev, blockno); // 写 cache\n  last_take->next = take_buf->next; // 链表中删除选中的空闲块\n  take_buf->next = 0;\n  release(&bcache.lock[bucket_id]);\n  release(&bcache.lock[hashid]);\n  for (b = &bcache.head[hashid]; b->next; b = b->next); // 获取映射到的桶的最后一项\n  b->next = take_buf; // 移到最后面\n  acquiresleep(&take_buf->lock);\n  return take_buf;\n\n\n最后我们还要修改一下 brelse()、bpin、bunpin() 中的锁，同时在释放块后，如果引用计数为 0 了，我们要更新他的时间戳。\n\n// Release a locked buffer.\n// Move to the head of the most-recently-used list.\nvoid brelse(struct buf *b)\n{\n  if(!holdingsleep(&b->lock))\n    panic("brelse");\n\n  releasesleep(&b->lock);\n\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt--;\n  if (b->refcnt == 0) {\n    b->ticks = ticks;\n  }\n  release(&bcache.lock[hashid]);\n}\n\nvoid bpin(struct buf *b) {\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt++;\n  release(&bcache.lock[hashid]);\n}\n\nvoid bunpin(struct buf *b) {\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt--;\n  release(&bcache.lock[hashid]);\n}\n\n\n\n# 实验结果\n',normalizedContent:'# [mit6.s081]lab8: locks\n\nlab: locks (mit.edu)\n\n\n# memory allocator\n\n这个 assignment 要我们改进内核的页面分配机制，本来是所有 cpu 共享一个空闲链表，然后对其上一把锁，现在我们改为给每一个 cpu 分配一个空闲链表，各自上一把锁，如果当前 cpu 的链表空间用完了再去借其他 cpu 的。\n\n下面操作都在文件 kernel/kalloc.c 中进行\n\n先将 kmem 变成数组类型\n\nstruct {\n  struct spinlock lock;\n  struct run *freelist;\n} kmem[nproc];\n\n\n在 kinit() 中我们初始化每个 kmem 的锁\n\nvoid kinit() {\n  // initlock(&kmem.lock, "kmem");\n  for (int i = 0; i < nproc; i++) {\n    initlock(&kmem[i].lock, "kmem");\n  }\n  freerange(end, (void*)phystop);\n}\n\n\n在释放的时候，也是先获取 cpuid 然后释放对应的空闲链表的空间\n\nvoid kfree(void *pa) {\n  struct run *r;\n\n  if(((uint64)pa % pgsize) != 0 || (char*)pa < end || (uint64)pa >= phystop)\n    panic("kfree");\n\n  // fill with junk to catch dangling refs.\n  memset(pa, 1, pgsize);\n\n  r = (struct run*)pa;\n\n  push_off();\n  int c = cpuid();\n  pop_off();\n\n  acquire(&kmem[c].lock);\n  r->next = kmem[c].freelist;\n  kmem[c].freelist = r;\n  release(&kmem[c].lock);\n}\n\n\n需要注意的是 cpuid() 需要在中断关闭的时候使用，所以要先 push_off()，之后再用 pop_off() 打开。\n\n而在 kalloc() 中，如果当前 cpu 的空闲链表用完了，则需要遍历其他的 cpu 来借空间，全程要记得上锁释放锁！\n\nvoid * kalloc(void) {\n  struct run *r;\n\n  push_off();  \n  int c = cpuid();\n  pop_off();\n\n  acquire(&kmem[c].lock);\n  r = kmem[c].freelist;\n  if(r) {\n    kmem[c].freelist = r->next;\n  }\n  release(&kmem[c].lock);\n  if (!r) { // 借其他 cpu 的空闲链表\n    for (int i = 0; i < ncpu; i++) {\n      if (i != c) {\n        acquire(&kmem[i].lock);\n        r = kmem[i].freelist;\n        if (r) {\n          kmem[i].freelist = r->next;\n          release(&kmem[i].lock);\n          break;\n        }\n        release(&kmem[i].lock);\n      }\n    }\n  }\n\n  if(r)\n    memset((char*)r, 5, pgsize); // fill with junk\n  return (void*)r;\n}\n\n\n\n# buffer cache\n\n在这个 assignment 中所有的 cpu 都共享着同一个 cache，为了避免单一的锁所带来的低性能，我们要修改这种 cache 的管理策略。\n\n我们先给每块 buffer 都加了把锁，然后我们通过将不同 buffer 映射到一个哈希表上的各个桶中，通过对桶的锁管理，来降低锁的粒度，提高运行效率。\n\n哈希表的长度 nbucket 选择素数 13，素数可以减小哈希冲突的可能，我们给每个桶分配了一段空闲的 buffer 链表，然后在查找 buffer 块的时候，根据 blockno 来将块映射到桶上。另外查找的过程中，如果它已经被 cache 了，那么我们直接可以 get 到。如果他没有被 cache，那么我们就要给它分配一个空闲块进行 cache，有分配那就有分配完的一天，也就会有替换操作，在我们选择被替换的 buffer 块时，我们要采用选择 lru(least recently used)策略。\n\n首先我们要在 struct buf 中加入时间戳变量\n\n// buf.h\nstruct buf {\n  int valid;   // has data been read from disk?\n  int disk;    // does disk "own" buf?\n  uint dev;\n  uint blockno;\n  struct sleeplock lock;\n  uint refcnt;\n  struct buf *prev; // lru cache list\n  struct buf *next;\n  uchar data[bsize];\n\n  uint ticks; // 时间戳\n};\n\n\n接着我们回到 bio.c 中开始实现\n\n我们先宏定义一下哈希表的长度以及定义一下哈希表数组，并且声明一下 trap.c 中的 ticks，另外还要将单个锁都定义为数组形式\n\n#define nbucket 13\n\nextern uint ticks; // 声明外部变量 (trap.c 中的 ticks)\n\nstruct {\n  struct spinlock lock[nbucket]; // 桶锁\n  struct buf buf[nbuf];\n\n  // linked list of all buffers, through prev/next.\n  // sorted by how recently the buffer was used.\n  // head.next is most recent, head.prev is least.\n  struct buf head[nbucket];\n} bcache;\n\nint hash(int x) {\n  return x % nbucket;\n}\n\n\n对应的从单个锁变成了每个块和桶都有把锁，我们在 binit() 中也要全部初始化。\n\n另外为了方便，我们一开始将所有的空闲 buffer 全都连在了哈希表的首位后面。\n\nvoid binit(void) {\n  struct buf *b;\n\n  // 初始化哈希表的桶锁\n  for (int i = 0; i < nbucket; i++) {\n    initlock(&bcache.lock[i], "bcache");\n  } \n\n  // 初始化每块 buffer 的锁，并且双向链表变为单向链表，初始时全都接在 bcache.head[0] 后面\n  bcache.head[0].next = &bcache.buf[0];\n  for (int i = 0; i < nbuf - 1; i++) {\n    b = &bcache.buf[i];\n    b->next = b + 1;\n    initsleeplock(&b->lock, "buffer");\n  }\n}\n\n\n在实现获取 buffer 块 bget() 之前，我们先要实现函数 replace_cache 用来更新 cache 的值\n\nvoid replace_cache(struct buf *b, uint dev, uint blockno) {\n  b->dev = dev;\n  b->blockno = blockno;\n  b->refcnt = 1; // 引用计数设置为 1 \n  b->valid = 0;\n}\n\n\n接下来开始实现 bget()\n\n【在实现这个函数的时候 当块没有被 cache 的情况参考了mit 6.s081 xv6-lab8-lock - 知乎 (zhihu.com)】\n\n首先我们先要获取 buffer 块对应的哈希值，以找到对应的桶，接着考虑如果这个 buffer 块已经被 cache 的情况\n\n  struct buf *b;\n\n  int hashid = hash(blockno); // 获取哈希值，看看映射到哪个桶\n  acquire(&bcache.lock[hashid]); // 获取这个桶的锁\n\n  // is the block already cached? 该 block 已经被 cached 了的情况\n  for(b = bcache.head[hashid].next; b; b = b->next){ // 单向链表遍历\n    if(b->dev == dev && b->blockno == blockno){\n      b->refcnt++;\n      release(&bcache.lock[hashid]); // 返回前释放这个桶的锁\n      acquiresleep(&b->lock); // 获取这个 buffer 的锁\n      return b;\n    }\n  }\n\n\n接着考虑没有被 cache 的情况，先看看当前映射到的桶中是否有空闲块\n\n  // 如果该 block 没有被 cache\n  // 1. 查找当前桶中是否有空闲块\n  for (b = bcache.head[hashid].next; b; b = b->next) {\n    if (b->refcnt == 0) { // 是一个空闲块\n      replace_cache(b, dev, blockno);\n      release(&bcache.lock[hashid]);\n      acquiresleep(&b->lock);\n      return b;\n    }\n  }\n\n\n然后我们查找其他桶中是否有空闲块，\n\n// 2. 查找其他桶中是否有空闲块，并且选择 lru\n  int bucket_id = -1; // 当前选中的空闲块所在的桶编号\n  struct buf *pre;\n  struct buf *take_buf = 0;\n  struct buf *last_take = 0;\n  uint time = __uint32_max__;\n  for (int i = 0; i < nbucket; i++) { // 遍历所有桶\n    if (i == hashid) continue;\n    acquire(&bcache.lock[i]); // 获取当前桶的锁\n    for (b = bcache.head[i].next, pre = &bcache.head[i]; b; b = b->next, pre = pre->next) { // 遍历这个桶拥有的空闲块\n      if (b->refcnt == 0 && b->ticks < time) { // 如果是空闲块，并且上次使用的时间更早\n        time = b->ticks; // 更新时间戳\n        last_take = pre; // 记录一下当前位置前一个块的为主子\n        take_buf = b; // 目前选中的空闲块\n        if (bucket_id != -1 && bucket_id != i && holding(&bcache.lock[bucket_id])) { // 如果前一个选中的块不在当前的桶中，则释放前一个块锁持有的桶锁\n          release(&bcache.lock[bucket_id]);\n        }\n        bucket_id = i; // 更新桶编号\n      }\n    }\n    if (bucket_id != i) { // 如果没有用到这个桶，则释放桶锁\n      release(&bcache.lock[i]);\n    }\n  }\n  if (!take_buf) { // 没有找到空闲块\n    panic("bget: no buffers");\n  }\n\n\n在我们找到目标块之后，我们要将他移到当前映射到的桶中，具体的方法其实就是链表的增删，还是比较简单的。\n\n  replace_cache(take_buf, dev, blockno); // 写 cache\n  last_take->next = take_buf->next; // 链表中删除选中的空闲块\n  take_buf->next = 0;\n  release(&bcache.lock[bucket_id]);\n  release(&bcache.lock[hashid]);\n  for (b = &bcache.head[hashid]; b->next; b = b->next); // 获取映射到的桶的最后一项\n  b->next = take_buf; // 移到最后面\n  acquiresleep(&take_buf->lock);\n  return take_buf;\n\n\n最后我们还要修改一下 brelse()、bpin、bunpin() 中的锁，同时在释放块后，如果引用计数为 0 了，我们要更新他的时间戳。\n\n// release a locked buffer.\n// move to the head of the most-recently-used list.\nvoid brelse(struct buf *b)\n{\n  if(!holdingsleep(&b->lock))\n    panic("brelse");\n\n  releasesleep(&b->lock);\n\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt--;\n  if (b->refcnt == 0) {\n    b->ticks = ticks;\n  }\n  release(&bcache.lock[hashid]);\n}\n\nvoid bpin(struct buf *b) {\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt++;\n  release(&bcache.lock[hashid]);\n}\n\nvoid bunpin(struct buf *b) {\n  int hashid = hash(b->blockno);\n  acquire(&bcache.lock[hashid]);\n  b->refcnt--;\n  release(&bcache.lock[hashid]);\n}\n\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"Lab0：Networking warmup",frontmatter:{title:null,date:"2023-03-10T22:47:05.000Z",permalink:"/pages/dda50b/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},regularPath:"/03.Learning%20Notes/02.Computer%20Networking/02.CS144%EF%BC%9AComputer%20Networking/01.Lab0%EF%BC%9ANetworking%20warmup.html",relativePath:"03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/01.Lab0：Networking warmup.md",key:"v-0b190e48",path:"/pages/dda50b/",headers:[{level:3,title:"2 Networking by hand",slug:"_2-networking-by-hand",normalizedTitle:"2 networking by hand",charIndex:57},{level:4,title:"2.1 Fetch a Web page",slug:"_2-1-fetch-a-web-page",normalizedTitle:"2.1 fetch a web page",charIndex:81},{level:4,title:"2.2 Send yourself an email",slug:"_2-2-send-yourself-an-email",normalizedTitle:"2.2 send yourself an email",charIndex:221},{level:4,title:"2.3 Listening and connecting",slug:"_2-3-listening-and-connecting",normalizedTitle:"2.3 listening and connecting",charIndex:540},{level:3,title:"3 Writing a network program using an OS stream socket",slug:"_3-writing-a-network-program-using-an-os-stream-socket",normalizedTitle:"3 writing a network program using an os stream socket",charIndex:583},{level:4,title:"3.1 - 3.3",slug:"_3-1-3-3",normalizedTitle:"3.1 - 3.3",charIndex:640},{level:4,title:"3.4 Writing webget",slug:"_3-4-writing-webget",normalizedTitle:"3.4 writing webget",charIndex:663},{level:3,title:"4 An in-memory reliable byte stream",slug:"_4-an-in-memory-reliable-byte-stream",normalizedTitle:"4 an in-memory reliable byte stream",charIndex:1792},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:4370}],lastUpdated:"4/1/2024, 7:57:33 AM",lastUpdatedTimestamp:1711929453e3,headersStr:"2 Networking by hand 2.1 Fetch a Web page 2.2 Send yourself an email 2.3 Listening and connecting 3 Writing a network program using an OS stream socket 3.1 - 3.3 3.4 Writing webget 4 An in-memory reliable byte stream 实验结果",content:'# Lab0：Networking warmup\n\nlab0.pdf (cs144.github.io)\n\n\n# 2 Networking by hand\n\n# 2.1 Fetch a Web page\n\n用 HTTP 协议获取一个网页页面\n\ntelnet cs144.keithw.org http\nGET /lab0/12345 HTTP/1.1\nHost: cs144.keithw.org\nConnection: close\n\n\n# 2.2 Send yourself an email\n\nSMTP 协议的使用，我们可以用 QQ 邮箱来代替\n\n参考：利用Telnet登录qq邮箱发送邮件——SMTP协议学习\n\ntelnet smtp.qq.com 25\nhelo qq.com \nauth login\nxxxxxxxxx // QQ 邮箱的 base64 编码\nxxxxxxxxx // 授权码的 base64 编码\nmail from:<xxxxxxxxxx@qq.com>\nrcpt to:<xxxxxxxxxx@qq.com>\ndata\nFrom:xxx\nTo:xxx\nSubject:xxx\n空一行\n<发送内容>\n. (输入点代表编辑结束)\n\n\nTest:\n\n# 2.3 Listening and connecting\n\n按文档操作即可。\n\n\n# 3 Writing a network program using an OS stream socket\n\n# 3.1 - 3.3\n\n按文档操作即可。\n\n# 3.4 Writing webget\n\n用已经提供的 API，来进行对网页的拉取。\n\n先用 TCP 建立连接，然后发送 HTTP 报文即可。\n\n注意读取响应报文的时候要读到 EOF 才能结束。\n\nvoid get_URL(const std::string &host, const std::string &path) {\n    // Your code here.\n\n    // You will need to connect to the "http" service on\n    // the computer whose name is in the "host" std::string,\n    // then request the URL path given in the "path" std::string.\n\n    // Then you\'ll need to print out everything the server sends back,\n    // (not just one call to read() -- everything) until you reach\n    // the "eof" (end of file).\n\n    const Address webserver(host, "http");\n    TCPSocket sock;\n    sock.connect(webserver); // 请求连接\n    std::string httpMessage = "GET " + path + " HTTP/1.1\\r\\n";\n    httpMessage += "Host: " + host + "\\r\\n";\n    httpMessage += "Connection: close\\r\\n\\r\\n";\n    sock.write(httpMessage); // 发送 HTTP 报文\n    while (!sock.eof()) { // 读取内容直到 EOF\n        auto recvd = sock.read();\n        std::cout << recvd;\n    }\n    // sock.close();\n    std::cerr << "Function called: get_URL(" << host << ", " << path << ").\\n";\n    std::cerr << "Warning: get_URL() has not been implemented yet.\\n";\n}\n\n\n\n# 4 An in-memory reliable byte stream\n\n先在 byte_stream.hh 中定义相关变量，具体含义可以看注释。\n\n这里我用的是 std::string 来作为缓冲区\n\n// byte_stream.hh\nprivate:\n    // Your code here -- add private members as necessary.\n\n    size_t cap; // 缓冲区容量\n    size_t have_written; // 已写字节数\n    size_t have_read; // 已读字节数\n    std::string buf; // 数据缓冲区\n    bool write_end; // 记录是否写结束\n\n\n具体看代码吧，不是很难。\n\n// byte_stream.cc\n\n#include "byte_stream.hh"\n\n// Dummy implementation of a flow-controlled in-memory byte stream.\n\n// For Lab 0, please replace with a real implementation that passes the\n// automated checks run by `make check_lab0`.\n\n// You will need to add private members to the class declaration in `byte_stream.hh`\n\ntemplate <typename... Targs>\nvoid DUMMY_CODE(Targs &&... /* unused */) {}\n\nusing namespace std;\n\nByteStream::ByteStream(const size_t capacity) : cap(capacity), have_written(0), have_read(0), buf{}, write_end(false) { }// 构造函数初始化\n\nsize_t ByteStream::write(const string &data) {\n    int cnt = 0; // 写入了多少字节\n    for (auto x : data) {\n        if (buf.size() >= cap) break; // 保证不超过 capacity\n        buf += x;\n        have_written += 1;\n        cnt += 1;\n    }\n    return cnt;\n}\n\n//! \\param[in] len bytes will be copied from the output side of the buffer\nstring ByteStream::peek_output(const size_t len) const {\n    return std::string(buf.begin(), buf.begin() + std::min(buf.size(), len));\n}\n\n//! \\param[in] len bytes will be removed from the output side of the buffer\nvoid ByteStream::pop_output(const size_t len) {\n    if (len > buf.size()) {\n        set_error(); // 设置 error\n        return;\n    }\n    buf.erase(0, len);\n    have_read += len;\n}\n\n//! Read (i.e., copy and then pop) the next "len" bytes of the stream\n//! \\param[in] len bytes will be popped and returned\n//! \\returns a string\nstd::string ByteStream::read(const size_t len) {\n    if (len > buf.size()) {\n        set_error(); // 设置 error\n        return "";\n    }\n    std::string res = std::string(buf.begin(), buf.begin() + len);\n    buf.erase(0, len);\n    have_read += len;\n    return res;\n}\n\nvoid ByteStream::end_input() {\n    write_end = true;\n}\n\nbool ByteStream::input_ended() const {\n    return write_end;\n}\n\nsize_t ByteStream::buffer_size() const {\n    return buf.size();\n}\n\nbool ByteStream::buffer_empty() const {\n    return buf.empty();   \n}\n\nbool ByteStream::eof() const {\n    return buf.empty() && write_end;\n}\n\nsize_t ByteStream::bytes_written() const {\n    return have_written;\n}\n\nsize_t ByteStream::bytes_read() const {\n    return have_read;\n}\n\nsize_t ByteStream::remaining_capacity() const {\n    return cap - buf.size();\n}\n\n\n\n# 实验结果\n',normalizedContent:'# lab0：networking warmup\n\nlab0.pdf (cs144.github.io)\n\n\n# 2 networking by hand\n\n# 2.1 fetch a web page\n\n用 http 协议获取一个网页页面\n\ntelnet cs144.keithw.org http\nget /lab0/12345 http/1.1\nhost: cs144.keithw.org\nconnection: close\n\n\n# 2.2 send yourself an email\n\nsmtp 协议的使用，我们可以用 qq 邮箱来代替\n\n参考：利用telnet登录qq邮箱发送邮件——smtp协议学习\n\ntelnet smtp.qq.com 25\nhelo qq.com \nauth login\nxxxxxxxxx // qq 邮箱的 base64 编码\nxxxxxxxxx // 授权码的 base64 编码\nmail from:<xxxxxxxxxx@qq.com>\nrcpt to:<xxxxxxxxxx@qq.com>\ndata\nfrom:xxx\nto:xxx\nsubject:xxx\n空一行\n<发送内容>\n. (输入点代表编辑结束)\n\n\ntest:\n\n# 2.3 listening and connecting\n\n按文档操作即可。\n\n\n# 3 writing a network program using an os stream socket\n\n# 3.1 - 3.3\n\n按文档操作即可。\n\n# 3.4 writing webget\n\n用已经提供的 api，来进行对网页的拉取。\n\n先用 tcp 建立连接，然后发送 http 报文即可。\n\n注意读取响应报文的时候要读到 eof 才能结束。\n\nvoid get_url(const std::string &host, const std::string &path) {\n    // your code here.\n\n    // you will need to connect to the "http" service on\n    // the computer whose name is in the "host" std::string,\n    // then request the url path given in the "path" std::string.\n\n    // then you\'ll need to print out everything the server sends back,\n    // (not just one call to read() -- everything) until you reach\n    // the "eof" (end of file).\n\n    const address webserver(host, "http");\n    tcpsocket sock;\n    sock.connect(webserver); // 请求连接\n    std::string httpmessage = "get " + path + " http/1.1\\r\\n";\n    httpmessage += "host: " + host + "\\r\\n";\n    httpmessage += "connection: close\\r\\n\\r\\n";\n    sock.write(httpmessage); // 发送 http 报文\n    while (!sock.eof()) { // 读取内容直到 eof\n        auto recvd = sock.read();\n        std::cout << recvd;\n    }\n    // sock.close();\n    std::cerr << "function called: get_url(" << host << ", " << path << ").\\n";\n    std::cerr << "warning: get_url() has not been implemented yet.\\n";\n}\n\n\n\n# 4 an in-memory reliable byte stream\n\n先在 byte_stream.hh 中定义相关变量，具体含义可以看注释。\n\n这里我用的是 std::string 来作为缓冲区\n\n// byte_stream.hh\nprivate:\n    // your code here -- add private members as necessary.\n\n    size_t cap; // 缓冲区容量\n    size_t have_written; // 已写字节数\n    size_t have_read; // 已读字节数\n    std::string buf; // 数据缓冲区\n    bool write_end; // 记录是否写结束\n\n\n具体看代码吧，不是很难。\n\n// byte_stream.cc\n\n#include "byte_stream.hh"\n\n// dummy implementation of a flow-controlled in-memory byte stream.\n\n// for lab 0, please replace with a real implementation that passes the\n// automated checks run by `make check_lab0`.\n\n// you will need to add private members to the class declaration in `byte_stream.hh`\n\ntemplate <typename... targs>\nvoid dummy_code(targs &&... /* unused */) {}\n\nusing namespace std;\n\nbytestream::bytestream(const size_t capacity) : cap(capacity), have_written(0), have_read(0), buf{}, write_end(false) { }// 构造函数初始化\n\nsize_t bytestream::write(const string &data) {\n    int cnt = 0; // 写入了多少字节\n    for (auto x : data) {\n        if (buf.size() >= cap) break; // 保证不超过 capacity\n        buf += x;\n        have_written += 1;\n        cnt += 1;\n    }\n    return cnt;\n}\n\n//! \\param[in] len bytes will be copied from the output side of the buffer\nstring bytestream::peek_output(const size_t len) const {\n    return std::string(buf.begin(), buf.begin() + std::min(buf.size(), len));\n}\n\n//! \\param[in] len bytes will be removed from the output side of the buffer\nvoid bytestream::pop_output(const size_t len) {\n    if (len > buf.size()) {\n        set_error(); // 设置 error\n        return;\n    }\n    buf.erase(0, len);\n    have_read += len;\n}\n\n//! read (i.e., copy and then pop) the next "len" bytes of the stream\n//! \\param[in] len bytes will be popped and returned\n//! \\returns a string\nstd::string bytestream::read(const size_t len) {\n    if (len > buf.size()) {\n        set_error(); // 设置 error\n        return "";\n    }\n    std::string res = std::string(buf.begin(), buf.begin() + len);\n    buf.erase(0, len);\n    have_read += len;\n    return res;\n}\n\nvoid bytestream::end_input() {\n    write_end = true;\n}\n\nbool bytestream::input_ended() const {\n    return write_end;\n}\n\nsize_t bytestream::buffer_size() const {\n    return buf.size();\n}\n\nbool bytestream::buffer_empty() const {\n    return buf.empty();   \n}\n\nbool bytestream::eof() const {\n    return buf.empty() && write_end;\n}\n\nsize_t bytestream::bytes_written() const {\n    return have_written;\n}\n\nsize_t bytestream::bytes_read() const {\n    return have_read;\n}\n\nsize_t bytestream::remaining_capacity() const {\n    return cap - buf.size();\n}\n\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"[MIT6.S081]Lab9: File System",frontmatter:{title:null,date:"2023-02-23T22:56:16.000Z",permalink:"/pages/865884/",tags:["Learning Notes","System","6.S081"]},regularPath:"/03.Learning%20Notes/01.System/01.MIT6.S081%20%7C%2021Fall/09.Lab9:%20File%20System.html",relativePath:"03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/09.Lab9: File System.md",key:"v-44124b74",path:"/pages/865884/",headers:[{level:3,title:"Large files",slug:"large-files",normalizedTitle:"large files",charIndex:63},{level:2,title:"Symbolic links",slug:"symbolic-links",normalizedTitle:"symbolic links",charIndex:2468},{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:4683}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"Large files Symbolic links 实验结果",content:"# [MIT6.S081]Lab9: File System\n\nLab: file system (mit.edu)\n\n\n# Large files\n\n在这个 assignment 中我们要扩充 xv6 文件的大小从 268 个块到 65803 个块，一开始我们的 inode 存储了 12 个 direct 的块号，以及一个 singly-indirect 块号 （类似于页表的多级映射，这里是单级）。每个 singly-indirect 块号代表了一个包含了 256 个块号的块。我们通过拿掉一个 direct 的块号，添加一个 doubly-indirect 块号(二级映射)，而一个 doubly-indirect 块号代表了一个包含 256 个 singly-indirect 块号的块。\n\n如此一来我们最后的块个数是 (12 - 1) * 1 + 256 + 256 * 256 = 65803\n\n首先我们修改一些宏定义和数组长度\n\n// fs.h\n#define NDIRECT 11\n\n// On-disk inode structure\nstruct dinode {\n// ......\n  uint addrs[NDIRECT+2];   // Data block addresses\n};\n\n// file.h\nstruct inode {\n// ......\n  uint addrs[NDIRECT+2];\n};\n\n\n接着我们先修改 bmap() 函数\n\n如果他不在一级索引的范围内，那么我们可以像前面一样给块号减去一个 NINDIRECT，有助于我们后面直接判断二级索引的范围是 < NINDIRECT * NINDIRECT。\n\n接下里的部分很前面类似，只是要映射两次，需要注意的是对于第一层的索引，我们的块号取得是 nb / NINDIRECT，而第二层的索引是 bn % NINDIRECT。\n\nif(bn < NINDIRECT) { // 一级索引的范围\n    // Load indirect block, allocating if necessary.\n    if((addr = ip->addrs[NDIRECT]) == 0)\n      ip->addrs[NDIRECT] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data; // 一级索引\n    if((addr = a[bn]) == 0) {\n      a[bn] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  bn -= NINDIRECT;\n\n  if(bn < NINDIRECT * NINDIRECT) { // 二级索引的范围\n    if((addr = ip->addrs[NDIRECT + 1]) == 0)\n      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint *)bp->data; // 二级索引的第一级\n    if ((addr = a[bn / NINDIRECT]) == 0) { // bn / NINDIRECT 是第一级的 index\n      a[bn / NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp); // 释放锁\n    bp = bread(ip->dev, addr);\n    a = (uint *)bp->data; // 二级索引的第二级\n    if ((addr = a[bn % NINDIRECT]) == 0) {\n      a[bn % NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp); // 释放锁\n\n    return addr;\n  }\n\n\n最后我们还要修改 itrunc() 函数，同样十分类似，只是多嵌套了一层映射，另外要注意 NDIRECT 和 NINDIRECT 不要用错。\n\n  if (ip->addrs[NDIRECT + 1]) {// 二级索引\n    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);\n    a = (uint *)bp->data; // 一级 index\n    for (int i = 0; i < NINDIRECT; i++) {\n      if (a[i]) {\n        bp2 = bread(ip->dev, a[i]); // 二级 index\n        uint *b = (uint *)bp2->data; \n        for (int j = 0; j < NINDIRECT; j++) {\n          if (b[j]) {\n            bfree(ip->dev, b[j]);\n          }\n        }\n        brelse(bp2);\n        bfree(ip->dev, a[i]);\n      }\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[NDIRECT + 1]);\n    ip->addrs[NDIRECT + 1] = 0;\n  }\n\n\n\n# Symbolic links\n\n在这个 assignment 中要为 xv6 添加软连接，实现 symlink 的系统调用。\n\n添加系统调用过程不再赘述，具体的实现部分参考其他函数和手册给出的 hints 一步步实现即可。\n\n// sysfile.c\nuint64 sys_symlink(void) {\n  struct inode *ip;\n  char target[MAXPATH];\n  char path[MAXPATH];\n\n  if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0) {\n    return -1;\n  }\n  begin_op();\n  \n  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) {\n    end_op();\n    return -1;\n  }\n\n  if (writei(ip, 0, (uint64)target, 0, MAXPATH) < 0) { // 存储路径\n    end_op();\n    return -1;\n  }\n  iunlockput(ip);\n  end_op();\n  return 0;\n}\n\nuint64\nsys_open(void)\n{\n  char path[MAXPATH];\n  int fd, omode;\n  struct file *f;\n  struct inode *ip;\n  int n;\n\n  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)\n    return -1;\n\n  begin_op();\n\n  if(omode & O_CREATE){\n    ip = create(path, T_FILE, 0, 0);\n    if(ip == 0){\n      end_op();\n      return -1;\n    }\n  } else {\n    if((ip = namei(path)) == 0){\n      end_op();\n      return -1;\n    }\n    ilock(ip);\n    if(ip->type == T_DIR && omode != O_RDONLY){\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n\n  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n  if ((ip->type == T_SYMLINK) && ((omode & O_NOFOLLOW) == 0)) {\n    int cnt = 0;\n    char target[MAXPATH];\n    while (1) {\n      if (++cnt > 10) {\n        iunlockput(ip);\n        end_op();\n        return -1;\n      }\n      if (ip->type != T_SYMLINK) { // 如果不是 symlink 了九条出去\n        break;\n      }\n      readi(ip, 0, (uint64)target, 0, MAXPATH); // 从 ip 中读取数据(路径名)\n      iunlockput(ip);\n      if ((ip = namei(target)) == 0) { // 找不到文件\n        end_op();\n        return -1;\n      }\n      ilock(ip);\n    }\n  }\n\n  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){\n    if(f)\n      fileclose(f);\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n\n  if(ip->type == T_DEVICE){\n    f->type = FD_DEVICE;\n    f->major = ip->major;\n  } else {\n    f->type = FD_INODE;\n    f->off = 0;\n  }\n  f->ip = ip;\n  f->readable = !(omode & O_WRONLY);\n  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);\n\n  if((omode & O_TRUNC) && ip->type == T_FILE){\n    itrunc(ip);\n  }\n\n  iunlock(ip);\n  end_op();\n\n  return fd;\n}\n\n\n\n# 实验结果\n\n",normalizedContent:"# [mit6.s081]lab9: file system\n\nlab: file system (mit.edu)\n\n\n# large files\n\n在这个 assignment 中我们要扩充 xv6 文件的大小从 268 个块到 65803 个块，一开始我们的 inode 存储了 12 个 direct 的块号，以及一个 singly-indirect 块号 （类似于页表的多级映射，这里是单级）。每个 singly-indirect 块号代表了一个包含了 256 个块号的块。我们通过拿掉一个 direct 的块号，添加一个 doubly-indirect 块号(二级映射)，而一个 doubly-indirect 块号代表了一个包含 256 个 singly-indirect 块号的块。\n\n如此一来我们最后的块个数是 (12 - 1) * 1 + 256 + 256 * 256 = 65803\n\n首先我们修改一些宏定义和数组长度\n\n// fs.h\n#define ndirect 11\n\n// on-disk inode structure\nstruct dinode {\n// ......\n  uint addrs[ndirect+2];   // data block addresses\n};\n\n// file.h\nstruct inode {\n// ......\n  uint addrs[ndirect+2];\n};\n\n\n接着我们先修改 bmap() 函数\n\n如果他不在一级索引的范围内，那么我们可以像前面一样给块号减去一个 nindirect，有助于我们后面直接判断二级索引的范围是 < nindirect * nindirect。\n\n接下里的部分很前面类似，只是要映射两次，需要注意的是对于第一层的索引，我们的块号取得是 nb / nindirect，而第二层的索引是 bn % nindirect。\n\nif(bn < nindirect) { // 一级索引的范围\n    // load indirect block, allocating if necessary.\n    if((addr = ip->addrs[ndirect]) == 0)\n      ip->addrs[ndirect] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data; // 一级索引\n    if((addr = a[bn]) == 0) {\n      a[bn] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  bn -= nindirect;\n\n  if(bn < nindirect * nindirect) { // 二级索引的范围\n    if((addr = ip->addrs[ndirect + 1]) == 0)\n      ip->addrs[ndirect + 1] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint *)bp->data; // 二级索引的第一级\n    if ((addr = a[bn / nindirect]) == 0) { // bn / nindirect 是第一级的 index\n      a[bn / nindirect] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp); // 释放锁\n    bp = bread(ip->dev, addr);\n    a = (uint *)bp->data; // 二级索引的第二级\n    if ((addr = a[bn % nindirect]) == 0) {\n      a[bn % nindirect] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp); // 释放锁\n\n    return addr;\n  }\n\n\n最后我们还要修改 itrunc() 函数，同样十分类似，只是多嵌套了一层映射，另外要注意 ndirect 和 nindirect 不要用错。\n\n  if (ip->addrs[ndirect + 1]) {// 二级索引\n    bp = bread(ip->dev, ip->addrs[ndirect + 1]);\n    a = (uint *)bp->data; // 一级 index\n    for (int i = 0; i < nindirect; i++) {\n      if (a[i]) {\n        bp2 = bread(ip->dev, a[i]); // 二级 index\n        uint *b = (uint *)bp2->data; \n        for (int j = 0; j < nindirect; j++) {\n          if (b[j]) {\n            bfree(ip->dev, b[j]);\n          }\n        }\n        brelse(bp2);\n        bfree(ip->dev, a[i]);\n      }\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[ndirect + 1]);\n    ip->addrs[ndirect + 1] = 0;\n  }\n\n\n\n# symbolic links\n\n在这个 assignment 中要为 xv6 添加软连接，实现 symlink 的系统调用。\n\n添加系统调用过程不再赘述，具体的实现部分参考其他函数和手册给出的 hints 一步步实现即可。\n\n// sysfile.c\nuint64 sys_symlink(void) {\n  struct inode *ip;\n  char target[maxpath];\n  char path[maxpath];\n\n  if (argstr(0, target, maxpath) < 0 || argstr(1, path, maxpath) < 0) {\n    return -1;\n  }\n  begin_op();\n  \n  if ((ip = create(path, t_symlink, 0, 0)) == 0) {\n    end_op();\n    return -1;\n  }\n\n  if (writei(ip, 0, (uint64)target, 0, maxpath) < 0) { // 存储路径\n    end_op();\n    return -1;\n  }\n  iunlockput(ip);\n  end_op();\n  return 0;\n}\n\nuint64\nsys_open(void)\n{\n  char path[maxpath];\n  int fd, omode;\n  struct file *f;\n  struct inode *ip;\n  int n;\n\n  if((n = argstr(0, path, maxpath)) < 0 || argint(1, &omode) < 0)\n    return -1;\n\n  begin_op();\n\n  if(omode & o_create){\n    ip = create(path, t_file, 0, 0);\n    if(ip == 0){\n      end_op();\n      return -1;\n    }\n  } else {\n    if((ip = namei(path)) == 0){\n      end_op();\n      return -1;\n    }\n    ilock(ip);\n    if(ip->type == t_dir && omode != o_rdonly){\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n\n  if(ip->type == t_device && (ip->major < 0 || ip->major >= ndev)){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n  if ((ip->type == t_symlink) && ((omode & o_nofollow) == 0)) {\n    int cnt = 0;\n    char target[maxpath];\n    while (1) {\n      if (++cnt > 10) {\n        iunlockput(ip);\n        end_op();\n        return -1;\n      }\n      if (ip->type != t_symlink) { // 如果不是 symlink 了九条出去\n        break;\n      }\n      readi(ip, 0, (uint64)target, 0, maxpath); // 从 ip 中读取数据(路径名)\n      iunlockput(ip);\n      if ((ip = namei(target)) == 0) { // 找不到文件\n        end_op();\n        return -1;\n      }\n      ilock(ip);\n    }\n  }\n\n  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){\n    if(f)\n      fileclose(f);\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n\n  if(ip->type == t_device){\n    f->type = fd_device;\n    f->major = ip->major;\n  } else {\n    f->type = fd_inode;\n    f->off = 0;\n  }\n  f->ip = ip;\n  f->readable = !(omode & o_wronly);\n  f->writable = (omode & o_wronly) || (omode & o_rdwr);\n\n  if((omode & o_trunc) && ip->type == t_file){\n    itrunc(ip);\n  }\n\n  iunlock(ip);\n  end_op();\n\n  return fd;\n}\n\n\n\n# 实验结果\n\n",charsets:{cjk:!0}},{title:"Lab1：Stitching substrings into a byte stream",frontmatter:{title:null,date:"2023-03-13T22:56:33.000Z",permalink:"/pages/dc39fe/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},regularPath:"/03.Learning%20Notes/02.Computer%20Networking/02.CS144%EF%BC%9AComputer%20Networking/02.Lab1%EF%BC%9Astitching%20substrings%20into%20a%20byte%20stream.html",relativePath:"03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/02.Lab1：stitching substrings into a byte stream.md",key:"v-5b207082",path:"/pages/dc39fe/",headers:[{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:3674}],lastUpdated:"3/15/2023, 9:05:12 AM",lastUpdatedTimestamp:1678842312e3,headersStr:"实验结果",content:"# Lab1：Stitching substrings into a byte stream\n\nlab1.pdf (cs144.github.io)\n\n在这个 lab 中，我们要实现一个 StreamReassembler。也就是说，在 lab0 实现的 ByteStream 基础上，由于发送的分组可能是失序的，因此我们要将分组重排，以达到 TCP 的按序传送特点。另外，需要注意的是，分组还可能会发生重复等情况。\n\n在 StreamReassembler 中有一个 ByteStream，其用来存放已经顺序的数据，由于 TCP 是累计确认的，因此我们要维护一个从 0 开始的变量 expected_num（与自顶向下书上相同）表示下一个要接受的数据。如果中间有数据失序，也就是 expected_num 的值代表的字节没有被接受到，那么我们就暂停存储数据到 ByteStream，转而将失序的数据缓存，直到前面暂未收到的数据补上了才进一步存储进 ByteStream。上面是大概的思路，接下来我们开始具体实现。\n\n首先，我们先需要明确手册中的 capacity 是什么(一开始理解错了导致写了好久错误代码...)\n\n这是一张官方给的图，可以发现我们的 capacity 分配了一部分空间给了 ByteStream，用来存储按序但还未被读取的数据。剩余部分给了 Reassembler 中的辅助数据结构。具体的，假设此时 Reassembler 可用的空间还有 bytes，则我们可以存储的数据范围就是 ，而超出这部分的字节都将被抛弃。\n\n接着，在 Reassembler 中，我们用 unordered_map，也就是哈希表来存储数据(感觉可以多耗费点空间，用双端队列等 DS 来存储，效率会更高)。\n\n最后，代码中还要求我们实现 EOF，也就是说当我们存储到了 EOF 表示的字节后就要调用 lab0 中实现的 end_input() 来关闭写入。我们用两个变量 end_flag、end_num 来实现这一功能。\n\n下面先给出需要定义的 private 成员，作用看注释即可。\n\n  private:\n    // Your code here -- add private members as necessary.\n\n    ByteStream _output;  //!< The reassembled in-order byte stream\n    size_t _capacity;    //!< The maximum number of bytes\n\n    // std::set<std::pair<int, std::string>> buf; \n    std::unordered_map<size_t, char> buf; // Reassembler 存储字节的数据结构\n    size_t expected_num; // 下一个期望得到的字节序号\n    bool end_flag; // 是否要求以 EOF 来结束\n    size_t end_num; // 最后一个数字 + 1 的位置\n\n\n\n来到代码实现部分，我们先实现两个比较简单的函数。\n\n未被重排的字节个数就是 buf 的大小，而是否为空直接判断 buf 即可。\n\nsize_t StreamReassembler::unassembled_bytes() const {\n    return buf.size();\n}\n\nbool StreamReassembler::empty() const {\n    return buf.empty();\n}\n\n\n最后是最主要的 push_substring 函数：\n\n开始的时候我们先计算可以在 Reassembler 中存储的最大字节序号 up，那么如过此时 end_flag 已被标记，那么我们的 up 还不能超过 end_num\n\nsize_t up = expected_num + _capacity - stream_out().buffer_size();\nif (end_flag) {\n    up = std::min(up, end_num);\n}\nif (index >= up) return; // 不符合直接 return\n\n\n接着我们从第一个有效的，即大于 expected_num 的下标开始存储数据\n\nfor (size_t i = expected_num > index ? expected_num - index : 0; i < data.size() && index + i < up; i++) {\n\t// if (index + i < expected_num) continue;\n\tbuf[index + i] = data[i];\n}   \n\n\n那么如果 index 是小于 expected_num 的，那么代表这是一个重复传输的字节，因此我们的起始位置直接从 expected_num - index 开始即可；index + i 表示当前字节的下标。\n\n每次存储完数据之后，我们要看看此时能从 expected_num 开始有序地读入多少个字节，每读完一个还要将其删去，将可读入的字节存放在 s 里，最后将 s 写入 ByteStream。\n\nstd::string s;\nfor (size_t i = expected_num; i < up; i++) {\n\tif (buf.count(i) == 0) break;\n    s += buf[i];\n    expected_num += 1;\n    buf.erase(i);\n}\nstream_out().write(s);\n\n\n最后，我们需要对 eof 为 1 的情况特殊处理，打上标记和更新 end_num。另外满足条件的话还要结束输入。\n\nif (eof) {\n\tend_flag = true;\n\tend_num = index + data.size();\n}\n\nif (end_flag && expected_num == end_num) {\n\tstream_out().end_input();\n}\n\n\n完整代码：\n\nvoid StreamReassembler::push_substring(const string &data, const size_t index, const bool eof) {\n    size_t up = expected_num + _capacity - stream_out().buffer_size(); // Reassembler 中能存储的最大字节序号 up\n    if (end_flag) {\n        up = std::min(up, end_num);\n    }\n    if (index >= up) return; // 不符合直接 return\n    \n    for (size_t i = expected_num > index ? expected_num - index : 0; i < data.size() && index + i < up; i++) {\n        // if (index + i < expected_num) continue;\n        buf[index + i] = data[i];\n    }   \n\n    std::string s;\n    for (size_t i = expected_num; i < up; i++) { \n        if (buf.count(i) == 0) break;\n        s += buf[i];\n        expected_num += 1;\n        buf.erase(i);\n    }\n\n    stream_out().write(s);\n\n    if (eof) {\n        end_flag = true;\n        end_num = index + data.size();\n    }\n\n    if (end_flag && expected_num == end_num) {\n        stream_out().end_input();\n    }\n}\n\nsize_t StreamReassembler::unassembled_bytes() const {\n    return buf.size();\n}\n\nbool StreamReassembler::empty() const {\n    return buf.empty();\n}\n\n\n\n# 实验结果\n\n\n效率一般般，感觉可以用别的数据结构优化一下，但是有点懒了就咕了。",normalizedContent:"# lab1：stitching substrings into a byte stream\n\nlab1.pdf (cs144.github.io)\n\n在这个 lab 中，我们要实现一个 streamreassembler。也就是说，在 lab0 实现的 bytestream 基础上，由于发送的分组可能是失序的，因此我们要将分组重排，以达到 tcp 的按序传送特点。另外，需要注意的是，分组还可能会发生重复等情况。\n\n在 streamreassembler 中有一个 bytestream，其用来存放已经顺序的数据，由于 tcp 是累计确认的，因此我们要维护一个从 0 开始的变量 expected_num（与自顶向下书上相同）表示下一个要接受的数据。如果中间有数据失序，也就是 expected_num 的值代表的字节没有被接受到，那么我们就暂停存储数据到 bytestream，转而将失序的数据缓存，直到前面暂未收到的数据补上了才进一步存储进 bytestream。上面是大概的思路，接下来我们开始具体实现。\n\n首先，我们先需要明确手册中的 capacity 是什么(一开始理解错了导致写了好久错误代码...)\n\n这是一张官方给的图，可以发现我们的 capacity 分配了一部分空间给了 bytestream，用来存储按序但还未被读取的数据。剩余部分给了 reassembler 中的辅助数据结构。具体的，假设此时 reassembler 可用的空间还有 bytes，则我们可以存储的数据范围就是 ，而超出这部分的字节都将被抛弃。\n\n接着，在 reassembler 中，我们用 unordered_map，也就是哈希表来存储数据(感觉可以多耗费点空间，用双端队列等 ds 来存储，效率会更高)。\n\n最后，代码中还要求我们实现 eof，也就是说当我们存储到了 eof 表示的字节后就要调用 lab0 中实现的 end_input() 来关闭写入。我们用两个变量 end_flag、end_num 来实现这一功能。\n\n下面先给出需要定义的 private 成员，作用看注释即可。\n\n  private:\n    // your code here -- add private members as necessary.\n\n    bytestream _output;  //!< the reassembled in-order byte stream\n    size_t _capacity;    //!< the maximum number of bytes\n\n    // std::set<std::pair<int, std::string>> buf; \n    std::unordered_map<size_t, char> buf; // reassembler 存储字节的数据结构\n    size_t expected_num; // 下一个期望得到的字节序号\n    bool end_flag; // 是否要求以 eof 来结束\n    size_t end_num; // 最后一个数字 + 1 的位置\n\n\n\n来到代码实现部分，我们先实现两个比较简单的函数。\n\n未被重排的字节个数就是 buf 的大小，而是否为空直接判断 buf 即可。\n\nsize_t streamreassembler::unassembled_bytes() const {\n    return buf.size();\n}\n\nbool streamreassembler::empty() const {\n    return buf.empty();\n}\n\n\n最后是最主要的 push_substring 函数：\n\n开始的时候我们先计算可以在 reassembler 中存储的最大字节序号 up，那么如过此时 end_flag 已被标记，那么我们的 up 还不能超过 end_num\n\nsize_t up = expected_num + _capacity - stream_out().buffer_size();\nif (end_flag) {\n    up = std::min(up, end_num);\n}\nif (index >= up) return; // 不符合直接 return\n\n\n接着我们从第一个有效的，即大于 expected_num 的下标开始存储数据\n\nfor (size_t i = expected_num > index ? expected_num - index : 0; i < data.size() && index + i < up; i++) {\n\t// if (index + i < expected_num) continue;\n\tbuf[index + i] = data[i];\n}   \n\n\n那么如果 index 是小于 expected_num 的，那么代表这是一个重复传输的字节，因此我们的起始位置直接从 expected_num - index 开始即可；index + i 表示当前字节的下标。\n\n每次存储完数据之后，我们要看看此时能从 expected_num 开始有序地读入多少个字节，每读完一个还要将其删去，将可读入的字节存放在 s 里，最后将 s 写入 bytestream。\n\nstd::string s;\nfor (size_t i = expected_num; i < up; i++) {\n\tif (buf.count(i) == 0) break;\n    s += buf[i];\n    expected_num += 1;\n    buf.erase(i);\n}\nstream_out().write(s);\n\n\n最后，我们需要对 eof 为 1 的情况特殊处理，打上标记和更新 end_num。另外满足条件的话还要结束输入。\n\nif (eof) {\n\tend_flag = true;\n\tend_num = index + data.size();\n}\n\nif (end_flag && expected_num == end_num) {\n\tstream_out().end_input();\n}\n\n\n完整代码：\n\nvoid streamreassembler::push_substring(const string &data, const size_t index, const bool eof) {\n    size_t up = expected_num + _capacity - stream_out().buffer_size(); // reassembler 中能存储的最大字节序号 up\n    if (end_flag) {\n        up = std::min(up, end_num);\n    }\n    if (index >= up) return; // 不符合直接 return\n    \n    for (size_t i = expected_num > index ? expected_num - index : 0; i < data.size() && index + i < up; i++) {\n        // if (index + i < expected_num) continue;\n        buf[index + i] = data[i];\n    }   \n\n    std::string s;\n    for (size_t i = expected_num; i < up; i++) { \n        if (buf.count(i) == 0) break;\n        s += buf[i];\n        expected_num += 1;\n        buf.erase(i);\n    }\n\n    stream_out().write(s);\n\n    if (eof) {\n        end_flag = true;\n        end_num = index + data.size();\n    }\n\n    if (end_flag && expected_num == end_num) {\n        stream_out().end_input();\n    }\n}\n\nsize_t streamreassembler::unassembled_bytes() const {\n    return buf.size();\n}\n\nbool streamreassembler::empty() const {\n    return buf.empty();\n}\n\n\n\n# 实验结果\n\n\n效率一般般，感觉可以用别的数据结构优化一下，但是有点懒了就咕了。",charsets:{cjk:!0}},{title:"Lab2：the TCP Receiver",frontmatter:{title:null,date:"2023-03-14T23:32:31.000Z",permalink:"/pages/875773/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},regularPath:"/03.Learning%20Notes/02.Computer%20Networking/02.CS144%EF%BC%9AComputer%20Networking/03.Lab2%EF%BC%9AThe%20TCP%20Receiver.html",relativePath:"03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/03.Lab2：The TCP Receiver.md",key:"v-fc061f2e",path:"/pages/875773/",headers:[{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:3812}],lastUpdated:"3/18/2023, 10:45:00 PM",lastUpdatedTimestamp:16791507e5,headersStr:"实验结果",content:"# Lab2：the TCP Receiver\n\nlab2.pdf (cs144.github.io)\n\n在这个 lab 中，我们要实现 TCP 的 Receiver。\n\n在之前 lab1 中，我们给每一个字节都标了一个序号，序号从 0 开始，是一个 uint64_t 类型的数据。而在 TCP 中则有所不同，数据是无穷无尽的，所以显然 uint64_t 的数据会有溢出行为，因此我们采用 wrapping 的方法，并用 uint32_t 来存储，也就是说，序号将以 1 << 32 为周期循环。\n\n在发送方第一次向接收方发送报文段时，会标记头部中的 SYN 字段，在最后一次发送时则会标记头部中的 FIN 字段。而在第一次发送时，也就是 SYN 被标记为 1 的报文段中头部的 seqno 就是 ISN，即要传输的这一组报文段的起始序号。ISN 是随机的，这是为了避免和上一轮 TCP 传输的报文段序号混淆。另外在接收方，我们将维护两个值 ackno 和 window_size。ackno 指的是接收方下一个希望接收到的序号，也就是 lab1 中的 expected_num（回想一下，TCP 是累积确认的），但区别在于 expected_num 并不统计标志位所占据的序号，而 ackno 会统计。 windows_size 是接收窗口的大小，起到了流量控制的作用，其值也就是 lab1 中的 capacity 再减去此时 ByteStream 中还未被进程读取的字节数，即 _capacity - stream_out().buffer_size()，那么很显然，我们接下来能接受的数据范围就是 [ackno，ackno + windows_size)。\n\n在具体实现 TCP Receiver 之前，我们先要完成序号的 translation，下面是一张文档里的图片，这个例子中的 ISN 为\n\n对于 wrap() 函数，我们要将 absolute seqno 转化为 seqno，还是比较简单的。\n\nWrappingInt32 wrap(uint64_t n, WrappingInt32 isn) {\n    return WrappingInt32{static_cast<uint32_t>(n) + isn.raw_value()};\n}\n\n\n而 unwrap() 就有点 tricky 了，我们要将 seqno 转化为 absolute seqno，并且要选择离 checkpoint 最近的那个。\n\n我们先令周期为 P = 1 << 32，我们先求出 checkpoint 所属的那个周期区间中的一个解，之后我们还要特殊判断一下下一个周期和上一个周期是否更优，具体看代码。\n\nuint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) {\n    uint64_t down = checkpoint & 0xFFFFFFFF00000000; // 所属周期的最小值\n    uint64_t offset = n.raw_value() - isn.raw_value(); // 偏移量\n    uint64_t m = down + offset; // checkpoint 所属周期中的一个解\n    uint64_t P = 1uL << 32; // 周期长度\n    uint64_t res = m; \n    uint64_t dif = (checkpoint >= res) ? checkpoint - res : res - checkpoint; // 当前解的差\n    // 下面是对下一个区间和上一个区间中的解进行判断是否更优，需要注意不要数据上溢和下溢\n    if (m + P > P && (m + P - checkpoint) < dif) {\n        dif = m + P - checkpoint;\n        res = m + P;\n    }\n    if (m >= P && checkpoint - (m - P) < dif) {\n        res = m - P;\n    }\n    return res;\n}\n\n\n接下来是正式进入了 TCP 的实现部分。\n\n【这部分有参考过 PKUFlyingPig】\n\n下面给出定义的 private 成员变量\n\n//! Our data structure for re-assembling bytes.\nStreamReassembler _reassembler;\n\n//! The maximum number of bytes we'll store.\nsize_t _capacity;\nbool syn; // 是否出现过 SYN\nbool fin; // 是否出现过 FIN\nWrappingInt32 isn; // the Initial Sequence Number \n\n\n我们先实现比较简单的求 ackno 和 windows_size\n\noptional<WrappingInt32> TCPReceiver::ackno() const {\n    if (syn) { // 接受过数据\n        return wrap(_reassembler.exp() + syn + (_reassembler.empty() && fin), WrappingInt32(isn)); // syn 和 fin 都会占据一个 sequence number\n    }\n    return std::nullopt;\n}\n\nsize_t TCPReceiver::window_size() const {\n    return _capacity - stream_out().buffer_size();\n}\n\n\n关于 window_size() 就不多赘述了。\n\n而在 ackno() 中，需要注意的是 SYN 和 FIN 也会占据一个 seqno；(_reassembler.empty() && fin) 如果成立的话表示当前所有数据存储完了，也就是 FIN 已经在 ackno 的统计范围内了。\n\n最后是重头戏 segment_received()\n\nvoid TCPReceiver::segment_received(const TCPSegment &seg) {\n\n    TCPHeader head = seg.header(); // 获取头部\n\n    std::string data = seg.payload().copy();\n\n    if (syn == false && head.syn == false) {\n        return;\n    }\n\n    bool eof = false;\n\n    if (syn == false && head.syn == true) { // 如果这是初始段\n        syn = true;\n        isn = head.seqno;\n        if (fin == false && head.fin == true) { // 这也是末尾段\n            eof = fin = true;\n        }\n        _reassembler.push_substring(data, 0, eof);\n        return;\n    }\n\n    if (head.fin == true) {\n        eof = fin = true;\n    }\n\n    _reassembler.push_substring(\n        data,\n        unwrap(head.seqno, isn, _reassembler.exp() + syn - 1) - syn, // syn 和 fin 都会占据一个 sequence number；checkpoint 是上一个 ackno - 1 的位置\n        eof\n    );\n}\n\n\n我们对 SYN 和 FIN 为 1 的报文段要特殊处理，最后将值写入 Reassembler 中。\n\n在 push_substring 的时候，关于下标序号我们要去掉对 SYN 和 FIN 的统计，并根据我们要将当前报文段的 seqno 和 ISN 计算出正确的序号值。\n\n需要注意的是，在这里 unwrap() 所使用的 checkpoint 是最后一个被 reassembler 的字节序号，也就是 ackno - 1，即 _reassembler.exp() + syn - 1（这里的序号是包含 syn 统计的）\n\n而关于为什么要额外定义变量 eof，而不能直接用 fin 来代替是因为，fin 只是用来标记是否出现过 FIN 标记位为 1 的情况，但由于可能失序，因此当前的报文段不代表就是最后的一组。\n\n\n# 实验结果\n",normalizedContent:"# lab2：the tcp receiver\n\nlab2.pdf (cs144.github.io)\n\n在这个 lab 中，我们要实现 tcp 的 receiver。\n\n在之前 lab1 中，我们给每一个字节都标了一个序号，序号从 0 开始，是一个 uint64_t 类型的数据。而在 tcp 中则有所不同，数据是无穷无尽的，所以显然 uint64_t 的数据会有溢出行为，因此我们采用 wrapping 的方法，并用 uint32_t 来存储，也就是说，序号将以 1 << 32 为周期循环。\n\n在发送方第一次向接收方发送报文段时，会标记头部中的 syn 字段，在最后一次发送时则会标记头部中的 fin 字段。而在第一次发送时，也就是 syn 被标记为 1 的报文段中头部的 seqno 就是 isn，即要传输的这一组报文段的起始序号。isn 是随机的，这是为了避免和上一轮 tcp 传输的报文段序号混淆。另外在接收方，我们将维护两个值 ackno 和 window_size。ackno 指的是接收方下一个希望接收到的序号，也就是 lab1 中的 expected_num（回想一下，tcp 是累积确认的），但区别在于 expected_num 并不统计标志位所占据的序号，而 ackno 会统计。 windows_size 是接收窗口的大小，起到了流量控制的作用，其值也就是 lab1 中的 capacity 再减去此时 bytestream 中还未被进程读取的字节数，即 _capacity - stream_out().buffer_size()，那么很显然，我们接下来能接受的数据范围就是 [ackno，ackno + windows_size)。\n\n在具体实现 tcp receiver 之前，我们先要完成序号的 translation，下面是一张文档里的图片，这个例子中的 isn 为\n\n对于 wrap() 函数，我们要将 absolute seqno 转化为 seqno，还是比较简单的。\n\nwrappingint32 wrap(uint64_t n, wrappingint32 isn) {\n    return wrappingint32{static_cast<uint32_t>(n) + isn.raw_value()};\n}\n\n\n而 unwrap() 就有点 tricky 了，我们要将 seqno 转化为 absolute seqno，并且要选择离 checkpoint 最近的那个。\n\n我们先令周期为 p = 1 << 32，我们先求出 checkpoint 所属的那个周期区间中的一个解，之后我们还要特殊判断一下下一个周期和上一个周期是否更优，具体看代码。\n\nuint64_t unwrap(wrappingint32 n, wrappingint32 isn, uint64_t checkpoint) {\n    uint64_t down = checkpoint & 0xffffffff00000000; // 所属周期的最小值\n    uint64_t offset = n.raw_value() - isn.raw_value(); // 偏移量\n    uint64_t m = down + offset; // checkpoint 所属周期中的一个解\n    uint64_t p = 1ul << 32; // 周期长度\n    uint64_t res = m; \n    uint64_t dif = (checkpoint >= res) ? checkpoint - res : res - checkpoint; // 当前解的差\n    // 下面是对下一个区间和上一个区间中的解进行判断是否更优，需要注意不要数据上溢和下溢\n    if (m + p > p && (m + p - checkpoint) < dif) {\n        dif = m + p - checkpoint;\n        res = m + p;\n    }\n    if (m >= p && checkpoint - (m - p) < dif) {\n        res = m - p;\n    }\n    return res;\n}\n\n\n接下来是正式进入了 tcp 的实现部分。\n\n【这部分有参考过 pkuflyingpig】\n\n下面给出定义的 private 成员变量\n\n//! our data structure for re-assembling bytes.\nstreamreassembler _reassembler;\n\n//! the maximum number of bytes we'll store.\nsize_t _capacity;\nbool syn; // 是否出现过 syn\nbool fin; // 是否出现过 fin\nwrappingint32 isn; // the initial sequence number \n\n\n我们先实现比较简单的求 ackno 和 windows_size\n\noptional<wrappingint32> tcpreceiver::ackno() const {\n    if (syn) { // 接受过数据\n        return wrap(_reassembler.exp() + syn + (_reassembler.empty() && fin), wrappingint32(isn)); // syn 和 fin 都会占据一个 sequence number\n    }\n    return std::nullopt;\n}\n\nsize_t tcpreceiver::window_size() const {\n    return _capacity - stream_out().buffer_size();\n}\n\n\n关于 window_size() 就不多赘述了。\n\n而在 ackno() 中，需要注意的是 syn 和 fin 也会占据一个 seqno；(_reassembler.empty() && fin) 如果成立的话表示当前所有数据存储完了，也就是 fin 已经在 ackno 的统计范围内了。\n\n最后是重头戏 segment_received()\n\nvoid tcpreceiver::segment_received(const tcpsegment &seg) {\n\n    tcpheader head = seg.header(); // 获取头部\n\n    std::string data = seg.payload().copy();\n\n    if (syn == false && head.syn == false) {\n        return;\n    }\n\n    bool eof = false;\n\n    if (syn == false && head.syn == true) { // 如果这是初始段\n        syn = true;\n        isn = head.seqno;\n        if (fin == false && head.fin == true) { // 这也是末尾段\n            eof = fin = true;\n        }\n        _reassembler.push_substring(data, 0, eof);\n        return;\n    }\n\n    if (head.fin == true) {\n        eof = fin = true;\n    }\n\n    _reassembler.push_substring(\n        data,\n        unwrap(head.seqno, isn, _reassembler.exp() + syn - 1) - syn, // syn 和 fin 都会占据一个 sequence number；checkpoint 是上一个 ackno - 1 的位置\n        eof\n    );\n}\n\n\n我们对 syn 和 fin 为 1 的报文段要特殊处理，最后将值写入 reassembler 中。\n\n在 push_substring 的时候，关于下标序号我们要去掉对 syn 和 fin 的统计，并根据我们要将当前报文段的 seqno 和 isn 计算出正确的序号值。\n\n需要注意的是，在这里 unwrap() 所使用的 checkpoint 是最后一个被 reassembler 的字节序号，也就是 ackno - 1，即 _reassembler.exp() + syn - 1（这里的序号是包含 syn 统计的）\n\n而关于为什么要额外定义变量 eof，而不能直接用 fin 来代替是因为，fin 只是用来标记是否出现过 fin 标记位为 1 的情况，但由于可能失序，因此当前的报文段不代表就是最后的一组。\n\n\n# 实验结果\n",charsets:{cjk:!0}},{title:"Lab4：The TCP Connection",frontmatter:{title:null,date:"2023-03-18T21:55:35.000Z",permalink:"/pages/e07ff0/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},regularPath:"/03.Learning%20Notes/02.Computer%20Networking/02.CS144%EF%BC%9AComputer%20Networking/05.Lab4%EF%BC%9AThe%20TCP%20Connection.html",relativePath:"03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/05.Lab4：The TCP Connection.md",key:"v-08c775ea",path:"/pages/e07ff0/",headers:[{level:4,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:11861}],lastUpdated:"3/18/2023, 11:39:18 PM",lastUpdatedTimestamp:1679153958e3,headersStr:"实验结果",content:'# Lab4：The TCP Connection\n\nlab4.pdf (cs144.github.io)\n\n在这个 lab 中，我们要站在全局的视角上，利用之前实现的 Sender 和 Receiver 来实现 TCP 的连接。\n\n过程中参考了一部分 Stanford-CS144-Sponge 笔记 - Lab 4: The TCP Connection | 吃着土豆坐地铁的博客\n\n首先在做这个 lab 之前，我们必须对 Sender、Receiver、Connection 的状态机十分熟悉，可以说这个 lab 就是对着他们的 FSM 图来进行实现的。\n\n做之前可以看一下下面几篇文章：\n\n * TCP状态机 - 简书 (jianshu.com)\n\n * 终于搞懂了 TCP 的 11 种状态 ，太不容易了… - 腾讯云开发者社区-腾讯云 (tencent.com)\n\n * TCP State Transitions\n\n下面是我自己画的一张 TCP 连接的状态机，一共 11 个状态（字有点丑）：\n\n\n每一个状态都将由 Sender、Receiver 和 Connection 三者的状态唯一定义，我们将在 segment_received() 对其实现。\n\n下面先来实现一下其他的一些函数。\n\n先是写入数据，也就是我方的 Sender 需要发送的数据。\n\nsize_t TCPConnection::write(const string &data) { // 返回写入长度\n    if (data.empty()) {\n        return 0;\n    }\n    size_t res = _sender.stream_in().write(data); // 往发送方的 bytestream 写入数据\n    _sender.fill_window(); // 根据接收窗口发送数据，数据放进 _segments_out\n    send_data(); // 发送数据到 receiver\n    return res;\n}\n\n\n而其中的 send_data() 执行了发送的操作，同时还更新了一下我方 Receiver 的操作。具体来说，我们会将 Sender 发送队列中的数据移到 Connection 的队列中；另外，至于后面的发送传输就不是传输层所关心的事了。\n\nvoid TCPConnection::send_data() {\n    // 发送 sender 的信息\n    while (!_sender.segments_out().empty()) { // 将 sender 发送队列中的数据放入 connection 的发送队列中\n        auto seg = _sender.segments_out().front();\n        _sender.segments_out().pop();\n        if (_receiver.ackno().has_value()) { // 将自己这里的 receiver 的数据写入首部\n            seg.header().ack = true;\n            seg.header().ackno = _receiver.ackno().value();\n            seg.header().win = _receiver.window_size() > std::numeric_limits<uint16_t>::max() ? std::numeric_limits<uint16_t>::max() : _receiver.window_size(); // 限定最大值\n            \n        }\n        segments_out().emplace(seg); // 放入 connection 的发送队列\n    }\n\n    // 如果对方的发送完毕了\n    if (_receiver.stream_out().input_ended()) {\n        if (_sender.stream_in().eof() == false) {// 我方的发送还未结束(被动连接)\n            _linger_after_streams_finish = false; // 不用进入 TIME_WAIT\n        } else if (_sender.stream_in().eof() == true && _sender.bytes_in_flight() == 0) { // 我方已经发送完了，且全送达了\n            // 如果我方不用进入 TIME_WAIT 或者 我方 TIME_WAIT 结束\n            if (_linger_after_streams_finish == false || _time_since_last_segment_received >= 10 * _cfg.rt_timeout)\n            _active = false; // 我方关闭连接 cleanly\n        }\n    }\n}\n\n\n接下来我们要实现计时的函数，其维护了一个变量，来记录距离上一次传输的报文被接受的时间间隔\n\nvoid TCPConnection::tick(const size_t ms_since_last_tick) {\n    if (_active == false) return;\n\n    _time_since_last_segment_received += ms_since_last_tick;\n    _sender.tick(ms_since_last_tick);\n\n    if (_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS) { // 重传次数超过上限\n        reset_connection(); // 设置 RST\n        return;\n    }\n    send_data();\n}\n\n\n还有设置 RST 位的函数，我们将在适当时候调用该函数，来设置并发送 RST 报文段和设置 error，以及关闭连接，例如重传次数超过上限、unclearly 地关闭连接\n\nvoid TCPConnection::reset_connection() {\n    // 发送 RST 段\n    TCPSegment seg;\n    seg.header().rst = true;\n    segments_out().emplace(seg);\n\n    // 标记错误 和 设置 _active\n    _sender.stream_in().set_error();\n    _receiver.stream_out().set_error();\n    _active = false; \n}\n\n\n下面是其他的一些比较简单的函数，就不多做解释了\n\nbool TCPConnection::active() const {\n    return _active; \n}\nsize_t TCPConnection::remaining_outbound_capacity() const {\n    return _sender.stream_in().remaining_capacity(); \n}\n\nsize_t TCPConnection::bytes_in_flight() const {\n    return _sender.bytes_in_flight();\n}\n\nsize_t TCPConnection::unassembled_bytes() const {\n    return _receiver.unassembled_bytes(); \n}\n\nsize_t TCPConnection::time_since_last_segment_received() const {\n    return _time_since_last_segment_received; \n}\n\n\n最后就是重头 segment_received() 函数。\n\n上文说过我们通过 sender、receiver、connection 状态来定义唯一的连接状态。\n\n其中 sender 和 receiver 的状态定义在之前的实验手册中已经有给出了，下面我们来简单谈一谈 connection 的状态以及八股重灾区 TCP 连接的 3 次握手和 4 次挥手。\n\n在端系统之间利用 TCP 进行通信之前，会先建立 TCP 的连接，其通过 3 次握手来实现，下面是一张来自自顶向下书上的图。\n\n客户主机先主动发起连接，他初始化了一个数据的起始序号 client_isn，并标记了 SYN，具体含义在之前的 lab 中已经有解释过了。服务器接收到这个建立请求的报文段后，如果可以建立，那么他就会为这段连接分配相应的资源，此时服务器是 Passive Open，而这第一个报文段的发送也就是第一次握手；\n\n之后服务器会对这个报文段进行确认，并发送对应的 ACK 确认报文段 client_isn + 1 。与此同时 TCP 是双向的连接，因此服务器也要向客户主机发起一个连接的请求，他会进行和客户主机第一次握手类似的行为，初始化了数据的起始序号 server_isn。然而，前面所说的这两件事可以合并在一起做，即服务器主机发起第二次握手，其用来确认客户主机的连接请求和发起由服务器向客户主机的连接，这个合并操作也被称为捎带；\n\n同理，客户主机也要对接受到的来自服务器的连接请求报文段发送 ACK 确认 server_isn + 1，同时还可以捎带客户要发送给服务器的数据，这被称为第三次握手。\n\n至此，C/S 双方便建立起了 TCP 连接，可以依此来传输数据了。\n\n而当数据传输结束，那么对应的也需要拆除连接，也就需要四次挥手了，下面也是一张来自自顶向下书上的图片：\n\n如图所示，客户主动先发送带有 FIN 的报文段来主动结束，此时服务器是 Passive Close，并回复对应的 ACK 报文段；而随后当服务器的数据页传输结束后，它也会向客户发送带有 FIN 的报文段，客户也会回复对应的 ACK 报文段，这一来一回一共四回，被称为四次挥手。\n\n上面的描述会让 TCP 关闭连接上看上去非常简单，但事实却不是如此，在客户等待由服务器发送回来的 ACK 时，还可能会接收到来此服务器的 FIN，抑或是同时接受到 ACK 和 FIN...而这些都会引起连接进入不同的状态。在这里我们先关注图中有一个特别的部分 “定时等待”，客户此时也就对应着状态机中的 TIME_WAIT 状态。\n\n为什么要设置定时等待呢？\n\n试想如果在接受到 FIN 报文段，并发送 ACK 报文段之后，客户直接关闭连接会有什么事情发生呢？很显然客户发送的 ACK 未必能保证到达目的服务器，那么服务器长时间未能接收到 ACK 的话，它就会不断的重复发送 FIN 报文段，当重复次数到达上限后就会设置 RST 以及 ERROR，并且 unclealy 地关闭连接。此时服务器的 FIN 其实已经被正确接受了，但最终却是以错误的方式关闭了连接，而这显然不是我们想要的结果。\n\n为了尽可能地避免这种现象，在主动关闭连接的一方会在此时进入定时等待状态，其就像个无情的回复机器，一旦接收到 FIN 就会回复对应的 ACK 确认报文段。\n\n需要注意的是，这种现象只能尽可能的避免，具体可以先了解一下两军问题，因为不能保证发出去的所有 ACK 都能被接受，只要连接关闭依赖于最后一次 ACK，那么就不能完美解决此问题。\n\n在上文中，端系统是否要进入定时等待，即 TIME_WAIT 状态，就用变量 _linger_after_streams_finish 来表示，其值初始默认为 true，而这也就是 connection 的状态部分。\n\n接下来我们对 TCP 连接过程中的 11 种状态以及出现错误的 1 种状态进行定义（可以直接参考 tcp_state.cc ）\n\nTCP 连接状态      RECEIVER 状态   SENDER 状态   CONNECTION 状态\nLISTEN        LISTEN        CLOSED      TRUE\nSYN_REVD      SYN_REVD      SYN_SENT    TRUE\nSYN_SENT      LISENT        SYN_SENT    TRUE\nESTABLISHED   SYN_REVD      SYN_ACKED   TRUE\nCLOSE_WAIT    FIN_REVD      SYN_ACKED   FALSE\nLAST_ACK      FIN_REVD      FIN_SENT    FALSE\nFIN_WAIT_1    SYN_REVD      FIN_SENT    TRUE\nFIN_WAIT_2    SYN_REVD      FIN_ACKED   TRUE\nCLOSING       FIN_REVD      FIN_SENT    TRUE\nTIME_WAIT     FIN_REVD      FIN_ACKED   TRUE\nCLOSED        FIN_REVD      FIN_ACKED   FALSE\nRESET         ERROR         ERROR       FALSE\n\n另外，在 CLOSED 和 RESET 状态中，连接的状态 active 为 false，其余状态都为 true。\n\n了解了上面的内容后就可以开始实现 segment_received() 啦，我们要关注在不同状态下的接收到报文段的各种行为。\n\n// sender、receiver、connection 确定唯一状态，对照 tcp_state.cc\nvoid TCPConnection::segment_received(const TCPSegment &seg) {\n    if (_active == false) return;\n\n    // 获取 sender 状态\n    auto get_sender_state = [&](const TCPSender &sender) {\n        if (sender.stream_in().error()) {\n            return "ERROR";\n        } else if (sender.next_seqno_absolute() == 0) {\n            return "CLOSED";\n        } else if (sender.next_seqno_absolute() == sender.bytes_in_flight()) {\n            return "SYN_SENT";\n        } else if (not sender.stream_in().eof()) {\n            return "SYN_ACKED";\n        } else if (sender.next_seqno_absolute() < sender.stream_in().bytes_written() + 2) {\n            return "SYN_ACKED";\n        } else if (sender.bytes_in_flight()) {\n            return "FIN_SENT";\n        } else {\n            return "FIN_ACKED";\n        }\n    };\n\n    // 获取 receiver 状态\n    auto get_receiver_state = [&](const TCPReceiver &receiver) {\n        if (receiver.stream_out().error()) {\n            return "ERROR";\n        } else if (not receiver.ackno().has_value()) {\n            return "LISTEN";\n        } else if (receiver.stream_out().input_ended()) {\n            return "FIN_RECV";\n        } else {\n            return "SYN_RECV";\n        }\n    };\n\n\n    std::string sen_st = get_sender_state(_sender);\n    std::string rev_st = get_receiver_state(_receiver);\n\n    _time_since_last_segment_received = 0; // 重置时间\n\n    // 收到 RST 段\n    if (seg.header().rst == true) { \n        _sender.stream_in().set_error();\n        _receiver.stream_out().set_error();\n        _active = false; \n    } \n    // LISTEN\n    else if (rev_st == "LISTEN" && sen_st == "CLOSED" && _linger_after_streams_finish == true) {\n        // 被动连接 Passive open（进入SYN_REVD）\n        if (seg.header().syn) {\n            _receiver.segment_received(seg);\n            connect(); // 会发送 ACK 和 SYN\n        }   \n    }\n    // SYN_REVD\n    else if (rev_st == "SYN_RECV" && sen_st == "SYN_SENT" && _linger_after_streams_finish == true) \n    {\n        // sender 接受 ACK（进入ESTABLISHED）\n        _receiver.segment_received(seg);\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n    }\n    // SYN_SENT\n    else if (rev_st == "LISTEN" && sen_st == "SYN_SENT" && _linger_after_streams_finish == true) \n    {\n        // client 收到 ACK 和 SYN，发送 ACK 后进入 ESTABLISHED\n        if (seg.header().ack == true && seg.header().syn == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment(); // 通过空包，来发送 ACK\n            send_data();\n        }       \n        // client 也作为 server，收到了 SYN，发送 SYN 和 ACK 后进入 SYN_REVD\n        else if (seg.header().syn == true && seg.header().ack == false) {\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n    }\n    // ESTABLISHED\n    else if (rev_st == "SYN_RECV" && sen_st == "SYN_ACKED" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        if (seg.length_in_sequence_space() > 0) {\n            _sender.send_empty_segment(); // 发送 ACK\n        }\n        _sender.fill_window();\n        send_data();\n    }\n    // FIN_WAIT_1（发送完毕，但接受未完毕）\n    else if (rev_st == "SYN_RECV" && sen_st == "FIN_SENT" && _linger_after_streams_finish == true) {\n        // 收到 FIN，进入 CLOSING\n        if (seg.header().fin == true && seg.header().ack == false) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n        } \n        // 收到 FIN、ACK，发送 ACK，进入 TIME_WAIT\n        else if (seg.header().fin == true && seg.header().ack == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n        // 收到 ACK，进入 FIN_WAIT_2\n        else if (seg.header().fin == false && seg.header().ack == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            send_data();\n        }\n    }\n    // FIN_WAIT_2，收到 FIN，发送 ACK，进入 TIME_WAIT\n    else if (rev_st == "SYN_RECV" && sen_st == "FIN_ACKED" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        _sender.send_empty_segment();\n        send_data();\n    }\n    // TIME_WAIT\n    else if (rev_st == "FIN_RECV" && sen_st == "FIN_ACKED" && _linger_after_streams_finish == true) {\n        // 收到 FIN 的话就发送 ACK（不断开连接）\n        if (seg.header().fin == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n    }\n    // CLOSE_WAIT\n    else if (rev_st == "FIN_RECV" && sen_st == "SYN_ACKED" && _linger_after_streams_finish == false) {\n        if (seg.header().fin) { // 此状态接收到 FIN 报文段说明需要重传\n            _sender.send_empty_segment();\n        }\n        // 继续发送数据\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        send_data();\n    }\n    // LAST_ACK\n    else if (rev_st == "FIN_RECV" && sen_st == "FIN_SENT" && _linger_after_streams_finish == false) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        if (_sender.bytes_in_flight() == 0) {\n            _active = false;\n        }\n    }\n    // CLOSING\n    else if (rev_st == "FIN_RECV" && sen_st == "FIN_SENT" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        send_data();\n    }\n}\n\n\n由于测试样例很多，会有很多的 corner case......\n\n有一个点我调了很久，也就是在进入 CLOSE_WAIT 状态后，此时如果接受到的报文段带有 FIN，那么我们要重传 ACK 确认报文段，其说明我们先前传过的 ACK 没能正确到达对方。\n\n# 实验结果\n\n\n（TEST 我是在 win 上用 WSL2 挂代理跑的，不然很有可能会 TIME_OUT）',normalizedContent:'# lab4：the tcp connection\n\nlab4.pdf (cs144.github.io)\n\n在这个 lab 中，我们要站在全局的视角上，利用之前实现的 sender 和 receiver 来实现 tcp 的连接。\n\n过程中参考了一部分 stanford-cs144-sponge 笔记 - lab 4: the tcp connection | 吃着土豆坐地铁的博客\n\n首先在做这个 lab 之前，我们必须对 sender、receiver、connection 的状态机十分熟悉，可以说这个 lab 就是对着他们的 fsm 图来进行实现的。\n\n做之前可以看一下下面几篇文章：\n\n * tcp状态机 - 简书 (jianshu.com)\n\n * 终于搞懂了 tcp 的 11 种状态 ，太不容易了… - 腾讯云开发者社区-腾讯云 (tencent.com)\n\n * tcp state transitions\n\n下面是我自己画的一张 tcp 连接的状态机，一共 11 个状态（字有点丑）：\n\n\n每一个状态都将由 sender、receiver 和 connection 三者的状态唯一定义，我们将在 segment_received() 对其实现。\n\n下面先来实现一下其他的一些函数。\n\n先是写入数据，也就是我方的 sender 需要发送的数据。\n\nsize_t tcpconnection::write(const string &data) { // 返回写入长度\n    if (data.empty()) {\n        return 0;\n    }\n    size_t res = _sender.stream_in().write(data); // 往发送方的 bytestream 写入数据\n    _sender.fill_window(); // 根据接收窗口发送数据，数据放进 _segments_out\n    send_data(); // 发送数据到 receiver\n    return res;\n}\n\n\n而其中的 send_data() 执行了发送的操作，同时还更新了一下我方 receiver 的操作。具体来说，我们会将 sender 发送队列中的数据移到 connection 的队列中；另外，至于后面的发送传输就不是传输层所关心的事了。\n\nvoid tcpconnection::send_data() {\n    // 发送 sender 的信息\n    while (!_sender.segments_out().empty()) { // 将 sender 发送队列中的数据放入 connection 的发送队列中\n        auto seg = _sender.segments_out().front();\n        _sender.segments_out().pop();\n        if (_receiver.ackno().has_value()) { // 将自己这里的 receiver 的数据写入首部\n            seg.header().ack = true;\n            seg.header().ackno = _receiver.ackno().value();\n            seg.header().win = _receiver.window_size() > std::numeric_limits<uint16_t>::max() ? std::numeric_limits<uint16_t>::max() : _receiver.window_size(); // 限定最大值\n            \n        }\n        segments_out().emplace(seg); // 放入 connection 的发送队列\n    }\n\n    // 如果对方的发送完毕了\n    if (_receiver.stream_out().input_ended()) {\n        if (_sender.stream_in().eof() == false) {// 我方的发送还未结束(被动连接)\n            _linger_after_streams_finish = false; // 不用进入 time_wait\n        } else if (_sender.stream_in().eof() == true && _sender.bytes_in_flight() == 0) { // 我方已经发送完了，且全送达了\n            // 如果我方不用进入 time_wait 或者 我方 time_wait 结束\n            if (_linger_after_streams_finish == false || _time_since_last_segment_received >= 10 * _cfg.rt_timeout)\n            _active = false; // 我方关闭连接 cleanly\n        }\n    }\n}\n\n\n接下来我们要实现计时的函数，其维护了一个变量，来记录距离上一次传输的报文被接受的时间间隔\n\nvoid tcpconnection::tick(const size_t ms_since_last_tick) {\n    if (_active == false) return;\n\n    _time_since_last_segment_received += ms_since_last_tick;\n    _sender.tick(ms_since_last_tick);\n\n    if (_sender.consecutive_retransmissions() > tcpconfig::max_retx_attempts) { // 重传次数超过上限\n        reset_connection(); // 设置 rst\n        return;\n    }\n    send_data();\n}\n\n\n还有设置 rst 位的函数，我们将在适当时候调用该函数，来设置并发送 rst 报文段和设置 error，以及关闭连接，例如重传次数超过上限、unclearly 地关闭连接\n\nvoid tcpconnection::reset_connection() {\n    // 发送 rst 段\n    tcpsegment seg;\n    seg.header().rst = true;\n    segments_out().emplace(seg);\n\n    // 标记错误 和 设置 _active\n    _sender.stream_in().set_error();\n    _receiver.stream_out().set_error();\n    _active = false; \n}\n\n\n下面是其他的一些比较简单的函数，就不多做解释了\n\nbool tcpconnection::active() const {\n    return _active; \n}\nsize_t tcpconnection::remaining_outbound_capacity() const {\n    return _sender.stream_in().remaining_capacity(); \n}\n\nsize_t tcpconnection::bytes_in_flight() const {\n    return _sender.bytes_in_flight();\n}\n\nsize_t tcpconnection::unassembled_bytes() const {\n    return _receiver.unassembled_bytes(); \n}\n\nsize_t tcpconnection::time_since_last_segment_received() const {\n    return _time_since_last_segment_received; \n}\n\n\n最后就是重头 segment_received() 函数。\n\n上文说过我们通过 sender、receiver、connection 状态来定义唯一的连接状态。\n\n其中 sender 和 receiver 的状态定义在之前的实验手册中已经有给出了，下面我们来简单谈一谈 connection 的状态以及八股重灾区 tcp 连接的 3 次握手和 4 次挥手。\n\n在端系统之间利用 tcp 进行通信之前，会先建立 tcp 的连接，其通过 3 次握手来实现，下面是一张来自自顶向下书上的图。\n\n客户主机先主动发起连接，他初始化了一个数据的起始序号 client_isn，并标记了 syn，具体含义在之前的 lab 中已经有解释过了。服务器接收到这个建立请求的报文段后，如果可以建立，那么他就会为这段连接分配相应的资源，此时服务器是 passive open，而这第一个报文段的发送也就是第一次握手；\n\n之后服务器会对这个报文段进行确认，并发送对应的 ack 确认报文段 client_isn + 1 。与此同时 tcp 是双向的连接，因此服务器也要向客户主机发起一个连接的请求，他会进行和客户主机第一次握手类似的行为，初始化了数据的起始序号 server_isn。然而，前面所说的这两件事可以合并在一起做，即服务器主机发起第二次握手，其用来确认客户主机的连接请求和发起由服务器向客户主机的连接，这个合并操作也被称为捎带；\n\n同理，客户主机也要对接受到的来自服务器的连接请求报文段发送 ack 确认 server_isn + 1，同时还可以捎带客户要发送给服务器的数据，这被称为第三次握手。\n\n至此，c/s 双方便建立起了 tcp 连接，可以依此来传输数据了。\n\n而当数据传输结束，那么对应的也需要拆除连接，也就需要四次挥手了，下面也是一张来自自顶向下书上的图片：\n\n如图所示，客户主动先发送带有 fin 的报文段来主动结束，此时服务器是 passive close，并回复对应的 ack 报文段；而随后当服务器的数据页传输结束后，它也会向客户发送带有 fin 的报文段，客户也会回复对应的 ack 报文段，这一来一回一共四回，被称为四次挥手。\n\n上面的描述会让 tcp 关闭连接上看上去非常简单，但事实却不是如此，在客户等待由服务器发送回来的 ack 时，还可能会接收到来此服务器的 fin，抑或是同时接受到 ack 和 fin...而这些都会引起连接进入不同的状态。在这里我们先关注图中有一个特别的部分 “定时等待”，客户此时也就对应着状态机中的 time_wait 状态。\n\n为什么要设置定时等待呢？\n\n试想如果在接受到 fin 报文段，并发送 ack 报文段之后，客户直接关闭连接会有什么事情发生呢？很显然客户发送的 ack 未必能保证到达目的服务器，那么服务器长时间未能接收到 ack 的话，它就会不断的重复发送 fin 报文段，当重复次数到达上限后就会设置 rst 以及 error，并且 unclealy 地关闭连接。此时服务器的 fin 其实已经被正确接受了，但最终却是以错误的方式关闭了连接，而这显然不是我们想要的结果。\n\n为了尽可能地避免这种现象，在主动关闭连接的一方会在此时进入定时等待状态，其就像个无情的回复机器，一旦接收到 fin 就会回复对应的 ack 确认报文段。\n\n需要注意的是，这种现象只能尽可能的避免，具体可以先了解一下两军问题，因为不能保证发出去的所有 ack 都能被接受，只要连接关闭依赖于最后一次 ack，那么就不能完美解决此问题。\n\n在上文中，端系统是否要进入定时等待，即 time_wait 状态，就用变量 _linger_after_streams_finish 来表示，其值初始默认为 true，而这也就是 connection 的状态部分。\n\n接下来我们对 tcp 连接过程中的 11 种状态以及出现错误的 1 种状态进行定义（可以直接参考 tcp_state.cc ）\n\ntcp 连接状态      receiver 状态   sender 状态   connection 状态\nlisten        listen        closed      true\nsyn_revd      syn_revd      syn_sent    true\nsyn_sent      lisent        syn_sent    true\nestablished   syn_revd      syn_acked   true\nclose_wait    fin_revd      syn_acked   false\nlast_ack      fin_revd      fin_sent    false\nfin_wait_1    syn_revd      fin_sent    true\nfin_wait_2    syn_revd      fin_acked   true\nclosing       fin_revd      fin_sent    true\ntime_wait     fin_revd      fin_acked   true\nclosed        fin_revd      fin_acked   false\nreset         error         error       false\n\n另外，在 closed 和 reset 状态中，连接的状态 active 为 false，其余状态都为 true。\n\n了解了上面的内容后就可以开始实现 segment_received() 啦，我们要关注在不同状态下的接收到报文段的各种行为。\n\n// sender、receiver、connection 确定唯一状态，对照 tcp_state.cc\nvoid tcpconnection::segment_received(const tcpsegment &seg) {\n    if (_active == false) return;\n\n    // 获取 sender 状态\n    auto get_sender_state = [&](const tcpsender &sender) {\n        if (sender.stream_in().error()) {\n            return "error";\n        } else if (sender.next_seqno_absolute() == 0) {\n            return "closed";\n        } else if (sender.next_seqno_absolute() == sender.bytes_in_flight()) {\n            return "syn_sent";\n        } else if (not sender.stream_in().eof()) {\n            return "syn_acked";\n        } else if (sender.next_seqno_absolute() < sender.stream_in().bytes_written() + 2) {\n            return "syn_acked";\n        } else if (sender.bytes_in_flight()) {\n            return "fin_sent";\n        } else {\n            return "fin_acked";\n        }\n    };\n\n    // 获取 receiver 状态\n    auto get_receiver_state = [&](const tcpreceiver &receiver) {\n        if (receiver.stream_out().error()) {\n            return "error";\n        } else if (not receiver.ackno().has_value()) {\n            return "listen";\n        } else if (receiver.stream_out().input_ended()) {\n            return "fin_recv";\n        } else {\n            return "syn_recv";\n        }\n    };\n\n\n    std::string sen_st = get_sender_state(_sender);\n    std::string rev_st = get_receiver_state(_receiver);\n\n    _time_since_last_segment_received = 0; // 重置时间\n\n    // 收到 rst 段\n    if (seg.header().rst == true) { \n        _sender.stream_in().set_error();\n        _receiver.stream_out().set_error();\n        _active = false; \n    } \n    // listen\n    else if (rev_st == "listen" && sen_st == "closed" && _linger_after_streams_finish == true) {\n        // 被动连接 passive open（进入syn_revd）\n        if (seg.header().syn) {\n            _receiver.segment_received(seg);\n            connect(); // 会发送 ack 和 syn\n        }   \n    }\n    // syn_revd\n    else if (rev_st == "syn_recv" && sen_st == "syn_sent" && _linger_after_streams_finish == true) \n    {\n        // sender 接受 ack（进入established）\n        _receiver.segment_received(seg);\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n    }\n    // syn_sent\n    else if (rev_st == "listen" && sen_st == "syn_sent" && _linger_after_streams_finish == true) \n    {\n        // client 收到 ack 和 syn，发送 ack 后进入 established\n        if (seg.header().ack == true && seg.header().syn == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment(); // 通过空包，来发送 ack\n            send_data();\n        }       \n        // client 也作为 server，收到了 syn，发送 syn 和 ack 后进入 syn_revd\n        else if (seg.header().syn == true && seg.header().ack == false) {\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n    }\n    // established\n    else if (rev_st == "syn_recv" && sen_st == "syn_acked" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        if (seg.length_in_sequence_space() > 0) {\n            _sender.send_empty_segment(); // 发送 ack\n        }\n        _sender.fill_window();\n        send_data();\n    }\n    // fin_wait_1（发送完毕，但接受未完毕）\n    else if (rev_st == "syn_recv" && sen_st == "fin_sent" && _linger_after_streams_finish == true) {\n        // 收到 fin，进入 closing\n        if (seg.header().fin == true && seg.header().ack == false) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n        } \n        // 收到 fin、ack，发送 ack，进入 time_wait\n        else if (seg.header().fin == true && seg.header().ack == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n        // 收到 ack，进入 fin_wait_2\n        else if (seg.header().fin == false && seg.header().ack == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            send_data();\n        }\n    }\n    // fin_wait_2，收到 fin，发送 ack，进入 time_wait\n    else if (rev_st == "syn_recv" && sen_st == "fin_acked" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        _sender.send_empty_segment();\n        send_data();\n    }\n    // time_wait\n    else if (rev_st == "fin_recv" && sen_st == "fin_acked" && _linger_after_streams_finish == true) {\n        // 收到 fin 的话就发送 ack（不断开连接）\n        if (seg.header().fin == true) {\n            _sender.ack_received(seg.header().ackno, seg.header().win);\n            _receiver.segment_received(seg);\n            _sender.send_empty_segment();\n            send_data();\n        }\n    }\n    // close_wait\n    else if (rev_st == "fin_recv" && sen_st == "syn_acked" && _linger_after_streams_finish == false) {\n        if (seg.header().fin) { // 此状态接收到 fin 报文段说明需要重传\n            _sender.send_empty_segment();\n        }\n        // 继续发送数据\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        send_data();\n    }\n    // last_ack\n    else if (rev_st == "fin_recv" && sen_st == "fin_sent" && _linger_after_streams_finish == false) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        if (_sender.bytes_in_flight() == 0) {\n            _active = false;\n        }\n    }\n    // closing\n    else if (rev_st == "fin_recv" && sen_st == "fin_sent" && _linger_after_streams_finish == true) {\n        _sender.ack_received(seg.header().ackno, seg.header().win);\n        _receiver.segment_received(seg);\n        send_data();\n    }\n}\n\n\n由于测试样例很多，会有很多的 corner case......\n\n有一个点我调了很久，也就是在进入 close_wait 状态后，此时如果接受到的报文段带有 fin，那么我们要重传 ack 确认报文段，其说明我们先前传过的 ack 没能正确到达对方。\n\n# 实验结果\n\n\n（test 我是在 win 上用 wsl2 挂代理跑的，不然很有可能会 time_out）',charsets:{cjk:!0}},{title:"Lab3：the TCP Sender",frontmatter:{title:null,date:"2023-03-18T17:30:17.000Z",permalink:"/pages/e12074/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},regularPath:"/03.Learning%20Notes/02.Computer%20Networking/02.CS144%EF%BC%9AComputer%20Networking/04.Lab3%EF%BC%9AThe%20TCP%20Sender.html",relativePath:"03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/04.Lab3：The TCP Sender.md",key:"v-08eaab1d",path:"/pages/e12074/",headers:[{level:3,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:6506}],lastUpdated:"3/18/2023, 10:45:00 PM",lastUpdatedTimestamp:16791507e5,headersStr:"实验结果",content:'# Lab3：the TCP Sender\n\nlab3.pdf (cs144.github.io)\n\n在这个 lab 中我们要实现 TCP 协议中的 Sender。\n\n过程中参考了Stanford-CS144-Sponge 笔记 - Lab 3: The TCP Sender | 吃着土豆坐地铁的博客 (epis2048.net)\n\n在发送端，我们通过维护接收窗口来实现 TCP 流量控制的机制，具体的可以看自顶向下书上的这张图。\n\n具体的，我们维护了三个变量，send_base、next_seqno 和 window_size，其中 window_size 的值是通过接受来自接收方的 ACK 报文段所捎带获得的。\n\nsend_base 维护了窗口的左端点，也就是第一个发送但还未被确认的值（outstanding)，next_seqno 是下一个将要发送的字节序号，显然我们此时的可发送数据范围是 [send_base, send_base + window_size)，而剩余的空闲可发送区间是 [next_seqno, send_base + window_size)。\n\n实验中我们要实现函数 fill_window()，我们每次调用该函数都会尽可能的发送数据，即把空闲区间尽量用完，我们将已发送且确认的数据和已发送未确认的数据分别用队列存储；需要注意的是，在 fill_window() 中如果此时窗口大小为 0 时，我们仍要发送一个字节的数据，防止 sender 停滞不进行。\n\n对于已发送的数据如果超时未能收到确认，则我们还要对其进行重传操作。超时部分的计时，我们通过函数 tick() 来实现，每次超时后，我们还要将这个阈值翻倍，这样可以减少发送可能无法送到的数据。具体实现部分可以参考代码\n\n而当数据发送出去后且收到确认时，sender 也会进行一系列的操作，它会更新 window_size，重置计时器，更新相关的序号记录变量等，这部分逻辑在 ack_received() 中实现。\n\n最后为了 TCP 连接的实现做准备，我们还要记录超时重传的次数以及实现一个发送空报文段的函数，前者在 TCP 连接中如果超过一定上限就会导致 RST 位被设置，并导致一些错误；后者则用来发送 ACK 确认。\n\n具体实现代码如下：\n\n  class TCPSender {\n  private:\n    //! our initial sequence number, the number for our SYN.\n    WrappingInt32 _isn;\n\n    //! outbound queue of segments that the TCPSender wants sent\n    std::queue<TCPSegment> _segments_out{};\n\n    //! retransmission timer for the connection\n    unsigned int _initial_retransmission_timeout;\n\n    //! outgoing stream of bytes that have not yet been sent\n    ByteStream _stream;\n\n    //! the (absolute) sequence number for the next byte to be sent\n    uint64_t _next_seqno{0};\n\n    std::queue<TCPSegment> _outstanding{}; // 用来存储发送了但还未被确认的报文段\n    bool _syn = false;\n    bool _fin = false;\n    size_t _window_size = 0; // 当前接收窗口大小\n    size_t _consecutive_retransmissions = 0; // 连续重传次数\n    unsigned int _timer = 0; // 计时器\n    unsigned int _rto = 0; // 当前的 RTO\n    bool _timer_running = false; // 计时器运行状态\n    size_t send_base = 0; // 第一个发送还未被确认的序号\n    size_t _bytes_in_flight = 0;\n\t// ..........\n}\n\n\n#include "tcp_sender.hh"\n\n#include "tcp_config.hh"\n\n#include <random>\n\n// Dummy implementation of a TCP sender\n\n// For Lab 3, please replace with a real implementation that passes the\n// automated checks run by `make check_lab3`.\n\ntemplate <typename... Targs>\nvoid DUMMY_CODE(Targs &&... /* unused */) {}\n\nusing namespace std;\n\n//! \\param[in] capacity the capacity of the outgoing byte stream\n//! \\param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment\n//! \\param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)\nTCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional<WrappingInt32> fixed_isn)\n    : _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))\n    , _initial_retransmission_timeout{retx_timeout}\n    , _stream(capacity)\n    , _rto(retx_timeout) {} // _rto 也一定要初始化\n\nuint64_t TCPSender::bytes_in_flight() const { return _bytes_in_flight; }\n\nvoid TCPSender::fill_window() {\n    if (_fin) { // 已经结束了\n        return;\n    };\n\n    if (_syn == false) { // 如果这是第一个报文段(不存数据)\n        TCPSegment seg;\n        seg.header().syn = true; // 设置 syn 比特位\n        _syn = true;\n        send_segment(seg);\n        return;\n    }\n\n    size_t win = _window_size;\n    if (win == 0) win = 1; // 如果为 0，那么要继续发送一个字节的比特\n\n    // 没有数据了，且此时有空间\n    if (stream_in().eof() && send_base + win > _next_seqno) {\n        TCPSegment seg;\n        seg.header().fin = true;\n        _fin = true;\n        send_segment(seg);\n        return;\n    }\n\n    // 还有数据的话，且此时有空间\n    size_t remain = 0; // 计算剩余空间，即 next_seqno 到右端点(send_base + win)的距离\n    while ((remain = win - (_next_seqno - send_base)) > 0 && !stream_in().buffer_empty() && _fin == false) { // 具体计算的示意图可以看自顶向下书上的图\n        TCPSegment seg;\n        size_t size = std::min(TCPConfig::MAX_PAYLOAD_SIZE, remain); // 不能超过上限值\n        seg.payload() = _stream.read(std::min(size, _stream.buffer_size()));\n\n        // 设置 FIN 位\n        if (stream_in().eof() && seg.length_in_sequence_space() + 1 <= remain) { // fin 位也会占据一个序号\n            _fin = true;\n            seg.header().fin = true;\n        }\n        send_segment(seg);\n    }\n}\n\n//! \\param ackno The remote receiver\'s ackno (acknowledgment number)\n//! \\param window_size The remote receiver\'s advertised window size\nvoid TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {\n    size_t abs_ackno = unwrap(ackno, _isn, send_base);\n    if (abs_ackno > _next_seqno) return; // 超出了可接受范围\n\n    _window_size = window_size;\n\n    if (abs_ackno <= send_base) return; // 已接收过的 ack\n    send_base = abs_ackno; \n\n    while (!_outstanding.empty()) {\n        auto &seg = _outstanding.front();\n        // size_t first_seqn = unwrap(seg.header().seqno, _isn, send_base);\n        size_t first_seqn = unwrap(seg.header().seqno, _isn, send_base);\n        if (first_seqn + seg.length_in_sequence_space() <= send_base) { // 已经收到 ack 了\n            _bytes_in_flight -= seg.length_in_sequence_space();\n            _outstanding.pop();\n        } else {\n            break;\n        }\n    }\n\n    _rto = _initial_retransmission_timeout; // 重置 RTO\n    _consecutive_retransmissions = 0; // 重置连续重传次数\n    fill_window(); // 尽可能发送\n    if (_outstanding.size()) { // 如果还有别的已发送未确认报文段就重启计时器\n        _timer_running = true;\n        _timer = 0;\n    }\n}\n\n//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method\nvoid TCPSender::tick(const size_t ms_since_last_tick) {\n    _timer += ms_since_last_tick;\n    if (_outstanding.empty()) {_timer_running = false;  // 关闭计时器\n        return;\n    }\n        \n    if (_timer >= _rto) { // 超时\n        _segments_out.emplace(_outstanding.front()); // 重传最早的那个段\n        _timer = 0; // 重置计时器\n        _timer_running = true; // 开启计时器\n        if (_window_size > 0 || _outstanding.front().header().syn) { // 需要满足接收窗口非零\n            _rto *= 2;\n            _consecutive_retransmissions += 1;\n        }\n    }\n}\n\nunsigned int TCPSender::consecutive_retransmissions() const { return _consecutive_retransmissions; }\n\nvoid TCPSender::send_empty_segment() { // 无 payload, SYN, or FIN\n    TCPSegment seg;\n    seg.header().seqno = wrap(_next_seqno, _isn);\n    _segments_out.emplace(seg);\n}\n\nvoid TCPSender::send_segment(TCPSegment &seg) {\n    seg.header().seqno = wrap(_next_seqno, _isn);\n    _bytes_in_flight += seg.length_in_sequence_space();\n    _next_seqno += seg.length_in_sequence_space();\n    _outstanding.emplace(seg);\n    _segments_out.emplace(seg);\n\n    if (_timer_running == false) { // 开启计时器\n        _timer_running = true;\n        _timer = 0;\n    }\n}\n\n\n\n# 实验结果\n',normalizedContent:'# lab3：the tcp sender\n\nlab3.pdf (cs144.github.io)\n\n在这个 lab 中我们要实现 tcp 协议中的 sender。\n\n过程中参考了stanford-cs144-sponge 笔记 - lab 3: the tcp sender | 吃着土豆坐地铁的博客 (epis2048.net)\n\n在发送端，我们通过维护接收窗口来实现 tcp 流量控制的机制，具体的可以看自顶向下书上的这张图。\n\n具体的，我们维护了三个变量，send_base、next_seqno 和 window_size，其中 window_size 的值是通过接受来自接收方的 ack 报文段所捎带获得的。\n\nsend_base 维护了窗口的左端点，也就是第一个发送但还未被确认的值（outstanding)，next_seqno 是下一个将要发送的字节序号，显然我们此时的可发送数据范围是 [send_base, send_base + window_size)，而剩余的空闲可发送区间是 [next_seqno, send_base + window_size)。\n\n实验中我们要实现函数 fill_window()，我们每次调用该函数都会尽可能的发送数据，即把空闲区间尽量用完，我们将已发送且确认的数据和已发送未确认的数据分别用队列存储；需要注意的是，在 fill_window() 中如果此时窗口大小为 0 时，我们仍要发送一个字节的数据，防止 sender 停滞不进行。\n\n对于已发送的数据如果超时未能收到确认，则我们还要对其进行重传操作。超时部分的计时，我们通过函数 tick() 来实现，每次超时后，我们还要将这个阈值翻倍，这样可以减少发送可能无法送到的数据。具体实现部分可以参考代码\n\n而当数据发送出去后且收到确认时，sender 也会进行一系列的操作，它会更新 window_size，重置计时器，更新相关的序号记录变量等，这部分逻辑在 ack_received() 中实现。\n\n最后为了 tcp 连接的实现做准备，我们还要记录超时重传的次数以及实现一个发送空报文段的函数，前者在 tcp 连接中如果超过一定上限就会导致 rst 位被设置，并导致一些错误；后者则用来发送 ack 确认。\n\n具体实现代码如下：\n\n  class tcpsender {\n  private:\n    //! our initial sequence number, the number for our syn.\n    wrappingint32 _isn;\n\n    //! outbound queue of segments that the tcpsender wants sent\n    std::queue<tcpsegment> _segments_out{};\n\n    //! retransmission timer for the connection\n    unsigned int _initial_retransmission_timeout;\n\n    //! outgoing stream of bytes that have not yet been sent\n    bytestream _stream;\n\n    //! the (absolute) sequence number for the next byte to be sent\n    uint64_t _next_seqno{0};\n\n    std::queue<tcpsegment> _outstanding{}; // 用来存储发送了但还未被确认的报文段\n    bool _syn = false;\n    bool _fin = false;\n    size_t _window_size = 0; // 当前接收窗口大小\n    size_t _consecutive_retransmissions = 0; // 连续重传次数\n    unsigned int _timer = 0; // 计时器\n    unsigned int _rto = 0; // 当前的 rto\n    bool _timer_running = false; // 计时器运行状态\n    size_t send_base = 0; // 第一个发送还未被确认的序号\n    size_t _bytes_in_flight = 0;\n\t// ..........\n}\n\n\n#include "tcp_sender.hh"\n\n#include "tcp_config.hh"\n\n#include <random>\n\n// dummy implementation of a tcp sender\n\n// for lab 3, please replace with a real implementation that passes the\n// automated checks run by `make check_lab3`.\n\ntemplate <typename... targs>\nvoid dummy_code(targs &&... /* unused */) {}\n\nusing namespace std;\n\n//! \\param[in] capacity the capacity of the outgoing byte stream\n//! \\param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment\n//! \\param[in] fixed_isn the initial sequence number to use, if set (otherwise uses a random isn)\ntcpsender::tcpsender(const size_t capacity, const uint16_t retx_timeout, const std::optional<wrappingint32> fixed_isn)\n    : _isn(fixed_isn.value_or(wrappingint32{random_device()()}))\n    , _initial_retransmission_timeout{retx_timeout}\n    , _stream(capacity)\n    , _rto(retx_timeout) {} // _rto 也一定要初始化\n\nuint64_t tcpsender::bytes_in_flight() const { return _bytes_in_flight; }\n\nvoid tcpsender::fill_window() {\n    if (_fin) { // 已经结束了\n        return;\n    };\n\n    if (_syn == false) { // 如果这是第一个报文段(不存数据)\n        tcpsegment seg;\n        seg.header().syn = true; // 设置 syn 比特位\n        _syn = true;\n        send_segment(seg);\n        return;\n    }\n\n    size_t win = _window_size;\n    if (win == 0) win = 1; // 如果为 0，那么要继续发送一个字节的比特\n\n    // 没有数据了，且此时有空间\n    if (stream_in().eof() && send_base + win > _next_seqno) {\n        tcpsegment seg;\n        seg.header().fin = true;\n        _fin = true;\n        send_segment(seg);\n        return;\n    }\n\n    // 还有数据的话，且此时有空间\n    size_t remain = 0; // 计算剩余空间，即 next_seqno 到右端点(send_base + win)的距离\n    while ((remain = win - (_next_seqno - send_base)) > 0 && !stream_in().buffer_empty() && _fin == false) { // 具体计算的示意图可以看自顶向下书上的图\n        tcpsegment seg;\n        size_t size = std::min(tcpconfig::max_payload_size, remain); // 不能超过上限值\n        seg.payload() = _stream.read(std::min(size, _stream.buffer_size()));\n\n        // 设置 fin 位\n        if (stream_in().eof() && seg.length_in_sequence_space() + 1 <= remain) { // fin 位也会占据一个序号\n            _fin = true;\n            seg.header().fin = true;\n        }\n        send_segment(seg);\n    }\n}\n\n//! \\param ackno the remote receiver\'s ackno (acknowledgment number)\n//! \\param window_size the remote receiver\'s advertised window size\nvoid tcpsender::ack_received(const wrappingint32 ackno, const uint16_t window_size) {\n    size_t abs_ackno = unwrap(ackno, _isn, send_base);\n    if (abs_ackno > _next_seqno) return; // 超出了可接受范围\n\n    _window_size = window_size;\n\n    if (abs_ackno <= send_base) return; // 已接收过的 ack\n    send_base = abs_ackno; \n\n    while (!_outstanding.empty()) {\n        auto &seg = _outstanding.front();\n        // size_t first_seqn = unwrap(seg.header().seqno, _isn, send_base);\n        size_t first_seqn = unwrap(seg.header().seqno, _isn, send_base);\n        if (first_seqn + seg.length_in_sequence_space() <= send_base) { // 已经收到 ack 了\n            _bytes_in_flight -= seg.length_in_sequence_space();\n            _outstanding.pop();\n        } else {\n            break;\n        }\n    }\n\n    _rto = _initial_retransmission_timeout; // 重置 rto\n    _consecutive_retransmissions = 0; // 重置连续重传次数\n    fill_window(); // 尽可能发送\n    if (_outstanding.size()) { // 如果还有别的已发送未确认报文段就重启计时器\n        _timer_running = true;\n        _timer = 0;\n    }\n}\n\n//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method\nvoid tcpsender::tick(const size_t ms_since_last_tick) {\n    _timer += ms_since_last_tick;\n    if (_outstanding.empty()) {_timer_running = false;  // 关闭计时器\n        return;\n    }\n        \n    if (_timer >= _rto) { // 超时\n        _segments_out.emplace(_outstanding.front()); // 重传最早的那个段\n        _timer = 0; // 重置计时器\n        _timer_running = true; // 开启计时器\n        if (_window_size > 0 || _outstanding.front().header().syn) { // 需要满足接收窗口非零\n            _rto *= 2;\n            _consecutive_retransmissions += 1;\n        }\n    }\n}\n\nunsigned int tcpsender::consecutive_retransmissions() const { return _consecutive_retransmissions; }\n\nvoid tcpsender::send_empty_segment() { // 无 payload, syn, or fin\n    tcpsegment seg;\n    seg.header().seqno = wrap(_next_seqno, _isn);\n    _segments_out.emplace(seg);\n}\n\nvoid tcpsender::send_segment(tcpsegment &seg) {\n    seg.header().seqno = wrap(_next_seqno, _isn);\n    _bytes_in_flight += seg.length_in_sequence_space();\n    _next_seqno += seg.length_in_sequence_space();\n    _outstanding.emplace(seg);\n    _segments_out.emplace(seg);\n\n    if (_timer_running == false) { // 开启计时器\n        _timer_running = true;\n        _timer = 0;\n    }\n}\n\n\n\n# 实验结果\n',charsets:{cjk:!0}},{title:"MySQL 问题整理",frontmatter:{title:"MySQL 问题整理",date:"2023-07-24T15:58:11.000Z",permalink:"/pages/498a73/",tags:["Learning Notes","DataBase","MySQL"]},regularPath:"/03.Learning%20Notes/03.DataBase/01.MySQL/01.MySQL%20%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html",relativePath:"03.Learning Notes/03.DataBase/01.MySQL/01.MySQL 问题整理.md",key:"v-acc71d30",path:"/pages/498a73/",headers:[{level:4,title:"1. “N叉树”的N值在MySQL中是可以被人工调整的么？",slug:"_1-n叉树-的n值在mysql中是可以被人工调整的么",normalizedTitle:"1. “n叉树”的n值在mysql中是可以被人工调整的么？",charIndex:16},{level:4,title:"2. MySQL 什么时候可能会选错索引，该怎么解决？",slug:"_2-mysql-什么时候可能会选错索引-该怎么解决",normalizedTitle:"2. mysql 什么时候可能会选错索引，该怎么解决？",charIndex:301},{level:4,title:"3. 重做日志 Redo Log 、Binlog 和 回滚日志 Undo Log",slug:"_3-重做日志-redo-log-、binlog-和-回滚日志-undo-log",normalizedTitle:"3. 重做日志 redo log 、binlog 和 回滚日志 undo log",charIndex:571},{level:4,title:"5. MySQL 的 crash safe 保证了什么？",slug:"_5-mysql-的-crash-safe-保证了什么",normalizedTitle:"5. mysql 的 crash safe 保证了什么？",charIndex:2055},{level:4,title:"6. 什么时候会出现死锁，怎么解决 MySQL 中的死锁问题",slug:"_6-什么时候会出现死锁-怎么解决-mysql-中的死锁问题",normalizedTitle:"6. 什么时候会出现死锁，怎么解决 mysql 中的死锁问题",charIndex:2202},{level:4,title:"7. 什么是 MVCC，实现原理是什么",slug:"_7-什么是-mvcc-实现原理是什么",normalizedTitle:"7. 什么是 mvcc，实现原理是什么",charIndex:2850},{level:4,title:"8. MySQL 为什么有时会“抖”一下，如何解决",slug:"_8-mysql-为什么有时会-抖-一下-如何解决",normalizedTitle:"8. mysql 为什么有时会“抖”一下，如何解决",charIndex:3705},{level:4,title:"9. 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？",slug:"_9-为什么-binlog-cache-是每个线程自己维护的-而-redo-log-buffer-是全局共用的",normalizedTitle:"9. 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？",charIndex:4271},{level:4,title:"10. 什么时候会出现当前读（current read）",slug:"_10-什么时候会出现当前读-current-read",normalizedTitle:"10. 什么时候会出现当前读（current read）",charIndex:4504},{level:4,title:"11. 什么是幻读；幻读有什么问题；该怎么解决",slug:"_11-什么是幻读-幻读有什么问题-该怎么解决",normalizedTitle:"11. 什么是幻读；幻读有什么问题；该怎么解决",charIndex:4651},{level:4,title:"12. RR 级别隔离下的加锁规则",slug:"_12-rr-级别隔离下的加锁规则",normalizedTitle:"12. rr 级别隔离下的加锁规则",charIndex:5303}],lastUpdated:"8/14/2023, 2:37:28 PM",lastUpdatedTimestamp:1691995048e3,headersStr:"1. “N叉树”的N值在MySQL中是可以被人工调整的么？ 2. MySQL 什么时候可能会选错索引，该怎么解决？ 3. 重做日志 Redo Log 、Binlog 和 回滚日志 Undo Log 5. MySQL 的 crash safe 保证了什么？ 6. 什么时候会出现死锁，怎么解决 MySQL 中的死锁问题 7. 什么是 MVCC，实现原理是什么 8. MySQL 为什么有时会“抖”一下，如何解决 9. 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？ 10. 什么时候会出现当前读（current read） 11. 什么是幻读；幻读有什么问题；该怎么解决 12. RR 级别隔离下的加锁规则",content:"# MySQL 问题整理\n\n# 1. “N叉树”的N值在MySQL中是可以被人工调整的么？\n\n * 修改 Key 的大小：MySQL 中的 B+ 树，对于叶子结点存储整行数据，而非叶子结点存储索引信息，索引包含了 key 和 指针，指针固定为 6 个字节，如果 key 为 10 个字节，那么一个索引就是 16 字节。再假设一个数据页为 16K，那么一个数据页就可以存储大约 1K 个索引，那么此时 N 也就等于 1024，因此我们如果修改了 key 的大小，也就可以间接修改 N 了。\n * 修改 Page 的大小：在 MySQL5.6 以后可以通过修改 page 的大小，以此来间接控制 N\n\n# 2. MySQL 什么时候可能会选错索引，该怎么解决？\n\n * 选择索引由优化器处理，选择索引的时候会有很多参考因素，例如是否排序，预估扫描行数（根据统计信息（基数）估算记录数，基数越大，索引区分度越好）等等，因此即使索引 a 扫描行数少，但因为需要排序，转而可能会选择另一个不需要排序的索引 b\n * 一般有三种处理方式\n   * 利用 force index 强制使用更优的索引\n   * 修改语句，引导 MySQL 使用我们期望的索引，例如修改 limit，order\n   * 新建一个合适的索引（往往很难），删掉误用的索引\n\n# 3. 重做日志 Redo Log 、Binlog 和 回滚日志 Undo Log\n\n * Redo Log\n   \n   * 记录了已经执行的事务对数据页进行的物理修改，实现了 crash-safe。当数据库崩溃后，可以通过重做日志恢复\n   \n   * 循环写入，write_pos 和 checkpoint\n   \n   * 默认当事务提交后会刷盘，有 write 和 fsync 两种操作，由参数 innodb_flush_log_at_trx_commit 控制。\n     \n     * 参数为 0：事务提交不刷盘，留在 redo log buffer 中\n     * 参数为 1：事务提交后就会 fsync（默认值）（prepare 阶段就会 fsync）\n     * 参数为 2：事务提交只将 redo log buffer 内容 write 写入 page cache\n   \n   * 有个后台线程，每隔 1s 会将 redo log buffer 内容 write 写入 page cache，并调用 fsync 刷盘\n   \n   * redo log buffer 占用空间即将到达 innodb_log_buffer_size 的一半，会调用 write，写入 page cache\n   \n   * 并行事务提交会顺带进行持久化，根据参数 innodb_flush_log_at_trx_commit 来进行\n   \n   * 保证了事务的持久性\n   \n   * 由于后台的轮询刷盘和崩溃恢复(prepare 后 Redo Log + 完整的 binlog 重启就能恢复)，innodb 在 Redo Log 提交后不会 fsync，只会 write\n\n * Binlog\n   \n   * 记录了数据库的逻辑修改操作，可简单理解为 SQL 语句。\n   * 追加写入，不会覆盖以前的日志\n   * 执行过程中先写入 binlog cache，参数 binlog_cache_size 控制单个线程的 binlog cache 大小；若超过就要暂存入磁盘\n   * 每个线程有独立的 binlog cache，但共用一份 binlog\n   * 操作与 Redo Log 类似，事务提交后的持久化操作由参数 sync_binlog 控制。\n     * 参数为 0：事务提交后只 write 写入 page cache\n     * 参数为 1：事务提交后就会 fsync\n     * 参数为 N(N>1)：事务提交后都 write，但累积 N 个事务提交后进行 fsync\n   * 主机（操作系统内核）重启后会丢失 page cache 的内容，但 MySQL 重启不会\n\n * 两阶段提交：Redo Log【prepare】 -> 写 binlog（写进 -> Redo Log【commit】\n\n * Undo Log\n   \n   * 记录了当前事务中对数据库进行过的修改操作，实现了事务回滚。Undo Log 加上隐藏字段（row_id、trx_id、roll_ptr...）、readview 等实现了 MVCC\n   * 事务中进行修改前会先记录 Undo Log，记录会先于数据持久化到磁盘上\n   * 回滚段中的对于一行数据每个事务有不同的 read view，对应到不同的历史版本\n   * 当回滚日志没有比他更早的 read view 后就被会删除（所以要避免长事务）\n   * 保证了事物的原子性\n\n# 5. MySQL 的 crash safe 保证了什么？\n\n * client 收到事务成功的消息，则事务一定持久化了\n * client 收到事务失败的消息，则事务一定失败了\n * client 收到执行异常的消息，应用需要重连来查询状态并进行后面的逻辑，保证了主备一直、数据日志一致\n\n# 6. 什么时候会出现死锁，怎么解决 MySQL 中的死锁问题\n\n * 当存在多个事务时，事务之间互相持有对方所依赖的锁。在 innodb 中，由于两阶段锁协议，事务持有的行锁只会在事务结束时才会释放，因此事务自己在等待对方释放锁，而对方也等待自己释放锁，进入了循环等待，也就造成了死锁。例如，事务 A 持有 X1 锁，申请 X2 锁，事务 B 持有 X2 锁，申请 X1 锁。\n * 解法 1：超时策略，可以通过 innodb_lock_wait_timeout 来设置\n   * 默认为 50 s\n   * 如果设置太久，影响性能；设置太小，容易误伤\n * 解法 2：死锁检测：对于每个新加进来的线程，如果要加锁访问的行上有锁，那么就会检测是否会因为自己的加入而导致死锁，由于要检测循环，那么显然时间复杂度是\n   * 高并发下显然性能有点低，1000 个线程，检测操作就大约是 100 万的量级\n     * 解决方案 1：对于一定不会出现死锁的业务，可以临时关闭死锁检测，通过设置 innodb_deadlock_detect（默认为 on）\n     * 解决方案 2：控制并发度\n       * 如果在客户端控制并发，则如果有大量客户端，那么并发数也很多\n       * 在数据库服务端控制并发，可以通过中间件，或者直接修改 MySQL 源码，在进入引擎前进行排队\n * 解法 3：根据业务逻辑进行详细设计，例如修改余额，可以分成 10 条记录。\n   * 会增加业务复杂度\n\n# 7. 什么是 MVCC，实现原理是什么\n\n * MVCC（Multi-Version Concurrency Control）全称是多版本并发控制，是一种实现数据库隔离的技术，InnoDB 的存储引擎就使用了 MVCC 实现了 RR 和 RC。它在每一行上保存了不同版本的数据，因此不同事务能看到不同版本的数据，其最大的优点在于读操作不会被写操作阻塞，可以并发进行。\n * 每个事务都有一个 ID，按申请顺序严格递增，事务更新数据时会把这个 ID 赋给这个数据版本的 row_trx_id。另外每一个事务在启动时会维护一个当前活跃的事务ID列表（执行了但未提交），其中最大的事务 ID 被称为高水位，最小称为低水位。\n   * 对于读操作来说，事务会先从改行的最新版本开始读取，并进行对 row_trx_id 进行判断，如果等于自己的事务 ID，则表示可见；如果小于低水位，说明已经提交，表示可见；如果大于高水位或者小于等高水位并且在活跃事务列表中，则不可见。\n   * 对于写操作来说，需要先读再写，读操作只能读取最新值，即“当前读”（current read)，因此会先去获取行的读锁（考虑两阶段锁协议）然后再进行写操作，也就会在最新版本上进行更新\n * 在 RR 下，只在事务开始时创建一致性视图；而 RC 下，每条语句执行前都会创建一个新的视图，对于 RC 来说只有那些提交了的事务是可见的。\n * PS：\n   1. 表结构不支持 RR，是因为表结构没有行数据和 row_trx_id，因此只能进行当前读\n   2. RR 下数据的更新可能会更新失败，也因此在更新后的查询可能会出现这样的“异象”——明明查出来的值还是旧值，符合更新条件，但就是不能更新。其实就是所谓的“乐观锁”，这种更新方式称为 CAS（Compare-and-swap）更新，有别的事务抢先更新了则在自己的事务中就会更新失败。解决方案是每次 CAS 更新成功就提交事务，如果更新失败就回滚该事物并另起一个事务进行查询更新。\n\n# 8. MySQL 为什么有时会“抖”一下，如何解决\n\n * 当 MySQL 在进行刷脏页的时候，可能会对性能造成一定影响。一般有这些场景会进行 flush 操作：数据库空闲、数据库正常关闭、系统内存不足、Redo Log 写满。对于前两个场景，显然不会有多大的性能影响\n * 刷脏页是常态，但如果出现了 Redo Log 写满 和 SQL语句执行需要淘汰的脏页过多 时，会对性能造成一定影响，也就会“抖”一下。我们可以通过 设置IO能力 和 调整脏页比例 来解决\n   1. 调整 IO 能力，也就是告诉 InnoDB 磁盘的 IO 能力，可以通过设置 innodb_io_capacity 参数来调整，一般设置为磁盘的 IOPS。但显然数据库不能一直用全力去刷脏页，因为还要响应服务请求，也就是有别的 IO 请求，因此我们还要计算用全力的多少百分比来刷脏页，记为 R% * innodb_io_capacity。数据库会根据 当前脏页比例 和 Redo Log写盘速度 来计算 R。\n   2. 可以通过设置参数 innodb_max_dirty_pages_pct 来修改脏页比例上限，默认值为 75%。显然，如果脏页比例过高，不仅会导致淘汰脏页的操作变多，还会让 Redo Log 的 checkpoint 无法推进。\n\n# 9. 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\n\n * binlog 是逻辑性的日志，不能被打断，必须连续写，因此要整个事务完成后，再一起写到文件里。\n * redo log 是物理性的日志，记录了数据页上的修改，分散写也不会有影响。中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。\n\n# 10. 什么时候会出现当前读（current read）\n\n * 当 SQL 语句中包含如下时，会出现当前读：\n   * update、delete、insert\n   * select ... lock in share mode\n   * select ... for update\n\n# 11. 什么是幻读；幻读有什么问题；该怎么解决\n\n * 幻读是指：一个事务在前后两次查询同一个范围的时候，后一次的查询看到了前一次查询没有出现的行。幻读是在 RR 级别下的，只在当前读出现。幻读专指新插入的行\n * 会破坏语句的语义性，破坏了语句原本的含义；由于不同事务 binlog 上传的顺序不一致，可能会导致实际数据和 binlog 中记录的语句执行完后的结果不一致，根本原因是即使把所有的记录都加上锁，也阻止不了新插入的记录。\n * innodb 引入了间隙锁（gap lock）\n   * 间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。\n   * 间隙锁只与 “ 往这个间隙中插入一个记录 ” 这个操作产生冲突；间隙锁与间隙锁之间不存在冲突关系\n   * 间隙锁可以解决幻读问题，但也会带来并发问题，因为间隙锁会锁住的范围更大，影响了并发度\n     * exg：两个事务都先执行进行了当前读，并都上了间隙锁，一个事务先执行 insert（由于间隙锁进入 blocked），另一个事务再执行 insert（由于间隙锁也进入 blocked)，最后两个事务进入了死锁等待状态\n   * 间隙锁是 RR 级别下的产物，所以为了解决幻读我们还可以采用 RC 隔离级别，此时为了解决数据和日志不一致的问题，我们可以将 binlog 格式设置为 row。（statement 格式是记录了这个 sql 语句，row 格式记录的是实际受影响的数据）\n\n# 12. RR 级别隔离下的加锁规则\n\n * 在 MySQL 8.0.33 下，经过自行的实验，得到了下面的结果\n   * 原则1：加锁基本单位是 next-key lock\n   * 原则2：查找过程中访问到的对象才会加锁\n   * 在给唯一索引上锁时，\n     * 无论等值查询还是范围查询，向右遍历到第一个不满足条件的值时，都会退化为间隙锁（范围查询下在新版本中也会进行该优化）\n     * 等值查询下，next-key lock 会退化为行锁\n   * 在给非唯一索引上锁时，\n     * 等值查询下，向右遍历到第一个不满足条件的值时，也会退化为间隙锁\n     * 但范围查询下，向右遍历到第一个不满足条件的值时，不会退化为间隙锁，仍然会保留行锁，形成一个 next-key lock\n   * 在新版本中，等值查询下，唯一索引访问到满足条件的值之后就会停止，不会进一步遍历到不满足条件的行。",normalizedContent:"# mysql 问题整理\n\n# 1. “n叉树”的n值在mysql中是可以被人工调整的么？\n\n * 修改 key 的大小：mysql 中的 b+ 树，对于叶子结点存储整行数据，而非叶子结点存储索引信息，索引包含了 key 和 指针，指针固定为 6 个字节，如果 key 为 10 个字节，那么一个索引就是 16 字节。再假设一个数据页为 16k，那么一个数据页就可以存储大约 1k 个索引，那么此时 n 也就等于 1024，因此我们如果修改了 key 的大小，也就可以间接修改 n 了。\n * 修改 page 的大小：在 mysql5.6 以后可以通过修改 page 的大小，以此来间接控制 n\n\n# 2. mysql 什么时候可能会选错索引，该怎么解决？\n\n * 选择索引由优化器处理，选择索引的时候会有很多参考因素，例如是否排序，预估扫描行数（根据统计信息（基数）估算记录数，基数越大，索引区分度越好）等等，因此即使索引 a 扫描行数少，但因为需要排序，转而可能会选择另一个不需要排序的索引 b\n * 一般有三种处理方式\n   * 利用 force index 强制使用更优的索引\n   * 修改语句，引导 mysql 使用我们期望的索引，例如修改 limit，order\n   * 新建一个合适的索引（往往很难），删掉误用的索引\n\n# 3. 重做日志 redo log 、binlog 和 回滚日志 undo log\n\n * redo log\n   \n   * 记录了已经执行的事务对数据页进行的物理修改，实现了 crash-safe。当数据库崩溃后，可以通过重做日志恢复\n   \n   * 循环写入，write_pos 和 checkpoint\n   \n   * 默认当事务提交后会刷盘，有 write 和 fsync 两种操作，由参数 innodb_flush_log_at_trx_commit 控制。\n     \n     * 参数为 0：事务提交不刷盘，留在 redo log buffer 中\n     * 参数为 1：事务提交后就会 fsync（默认值）（prepare 阶段就会 fsync）\n     * 参数为 2：事务提交只将 redo log buffer 内容 write 写入 page cache\n   \n   * 有个后台线程，每隔 1s 会将 redo log buffer 内容 write 写入 page cache，并调用 fsync 刷盘\n   \n   * redo log buffer 占用空间即将到达 innodb_log_buffer_size 的一半，会调用 write，写入 page cache\n   \n   * 并行事务提交会顺带进行持久化，根据参数 innodb_flush_log_at_trx_commit 来进行\n   \n   * 保证了事务的持久性\n   \n   * 由于后台的轮询刷盘和崩溃恢复(prepare 后 redo log + 完整的 binlog 重启就能恢复)，innodb 在 redo log 提交后不会 fsync，只会 write\n\n * binlog\n   \n   * 记录了数据库的逻辑修改操作，可简单理解为 sql 语句。\n   * 追加写入，不会覆盖以前的日志\n   * 执行过程中先写入 binlog cache，参数 binlog_cache_size 控制单个线程的 binlog cache 大小；若超过就要暂存入磁盘\n   * 每个线程有独立的 binlog cache，但共用一份 binlog\n   * 操作与 redo log 类似，事务提交后的持久化操作由参数 sync_binlog 控制。\n     * 参数为 0：事务提交后只 write 写入 page cache\n     * 参数为 1：事务提交后就会 fsync\n     * 参数为 n(n>1)：事务提交后都 write，但累积 n 个事务提交后进行 fsync\n   * 主机（操作系统内核）重启后会丢失 page cache 的内容，但 mysql 重启不会\n\n * 两阶段提交：redo log【prepare】 -> 写 binlog（写进 -> redo log【commit】\n\n * undo log\n   \n   * 记录了当前事务中对数据库进行过的修改操作，实现了事务回滚。undo log 加上隐藏字段（row_id、trx_id、roll_ptr...）、readview 等实现了 mvcc\n   * 事务中进行修改前会先记录 undo log，记录会先于数据持久化到磁盘上\n   * 回滚段中的对于一行数据每个事务有不同的 read view，对应到不同的历史版本\n   * 当回滚日志没有比他更早的 read view 后就被会删除（所以要避免长事务）\n   * 保证了事物的原子性\n\n# 5. mysql 的 crash safe 保证了什么？\n\n * client 收到事务成功的消息，则事务一定持久化了\n * client 收到事务失败的消息，则事务一定失败了\n * client 收到执行异常的消息，应用需要重连来查询状态并进行后面的逻辑，保证了主备一直、数据日志一致\n\n# 6. 什么时候会出现死锁，怎么解决 mysql 中的死锁问题\n\n * 当存在多个事务时，事务之间互相持有对方所依赖的锁。在 innodb 中，由于两阶段锁协议，事务持有的行锁只会在事务结束时才会释放，因此事务自己在等待对方释放锁，而对方也等待自己释放锁，进入了循环等待，也就造成了死锁。例如，事务 a 持有 x1 锁，申请 x2 锁，事务 b 持有 x2 锁，申请 x1 锁。\n * 解法 1：超时策略，可以通过 innodb_lock_wait_timeout 来设置\n   * 默认为 50 s\n   * 如果设置太久，影响性能；设置太小，容易误伤\n * 解法 2：死锁检测：对于每个新加进来的线程，如果要加锁访问的行上有锁，那么就会检测是否会因为自己的加入而导致死锁，由于要检测循环，那么显然时间复杂度是\n   * 高并发下显然性能有点低，1000 个线程，检测操作就大约是 100 万的量级\n     * 解决方案 1：对于一定不会出现死锁的业务，可以临时关闭死锁检测，通过设置 innodb_deadlock_detect（默认为 on）\n     * 解决方案 2：控制并发度\n       * 如果在客户端控制并发，则如果有大量客户端，那么并发数也很多\n       * 在数据库服务端控制并发，可以通过中间件，或者直接修改 mysql 源码，在进入引擎前进行排队\n * 解法 3：根据业务逻辑进行详细设计，例如修改余额，可以分成 10 条记录。\n   * 会增加业务复杂度\n\n# 7. 什么是 mvcc，实现原理是什么\n\n * mvcc（multi-version concurrency control）全称是多版本并发控制，是一种实现数据库隔离的技术，innodb 的存储引擎就使用了 mvcc 实现了 rr 和 rc。它在每一行上保存了不同版本的数据，因此不同事务能看到不同版本的数据，其最大的优点在于读操作不会被写操作阻塞，可以并发进行。\n * 每个事务都有一个 id，按申请顺序严格递增，事务更新数据时会把这个 id 赋给这个数据版本的 row_trx_id。另外每一个事务在启动时会维护一个当前活跃的事务id列表（执行了但未提交），其中最大的事务 id 被称为高水位，最小称为低水位。\n   * 对于读操作来说，事务会先从改行的最新版本开始读取，并进行对 row_trx_id 进行判断，如果等于自己的事务 id，则表示可见；如果小于低水位，说明已经提交，表示可见；如果大于高水位或者小于等高水位并且在活跃事务列表中，则不可见。\n   * 对于写操作来说，需要先读再写，读操作只能读取最新值，即“当前读”（current read)，因此会先去获取行的读锁（考虑两阶段锁协议）然后再进行写操作，也就会在最新版本上进行更新\n * 在 rr 下，只在事务开始时创建一致性视图；而 rc 下，每条语句执行前都会创建一个新的视图，对于 rc 来说只有那些提交了的事务是可见的。\n * ps：\n   1. 表结构不支持 rr，是因为表结构没有行数据和 row_trx_id，因此只能进行当前读\n   2. rr 下数据的更新可能会更新失败，也因此在更新后的查询可能会出现这样的“异象”——明明查出来的值还是旧值，符合更新条件，但就是不能更新。其实就是所谓的“乐观锁”，这种更新方式称为 cas（compare-and-swap）更新，有别的事务抢先更新了则在自己的事务中就会更新失败。解决方案是每次 cas 更新成功就提交事务，如果更新失败就回滚该事物并另起一个事务进行查询更新。\n\n# 8. mysql 为什么有时会“抖”一下，如何解决\n\n * 当 mysql 在进行刷脏页的时候，可能会对性能造成一定影响。一般有这些场景会进行 flush 操作：数据库空闲、数据库正常关闭、系统内存不足、redo log 写满。对于前两个场景，显然不会有多大的性能影响\n * 刷脏页是常态，但如果出现了 redo log 写满 和 sql语句执行需要淘汰的脏页过多 时，会对性能造成一定影响，也就会“抖”一下。我们可以通过 设置io能力 和 调整脏页比例 来解决\n   1. 调整 io 能力，也就是告诉 innodb 磁盘的 io 能力，可以通过设置 innodb_io_capacity 参数来调整，一般设置为磁盘的 iops。但显然数据库不能一直用全力去刷脏页，因为还要响应服务请求，也就是有别的 io 请求，因此我们还要计算用全力的多少百分比来刷脏页，记为 r% * innodb_io_capacity。数据库会根据 当前脏页比例 和 redo log写盘速度 来计算 r。\n   2. 可以通过设置参数 innodb_max_dirty_pages_pct 来修改脏页比例上限，默认值为 75%。显然，如果脏页比例过高，不仅会导致淘汰脏页的操作变多，还会让 redo log 的 checkpoint 无法推进。\n\n# 9. 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\n\n * binlog 是逻辑性的日志，不能被打断，必须连续写，因此要整个事务完成后，再一起写到文件里。\n * redo log 是物理性的日志，记录了数据页上的修改，分散写也不会有影响。中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。\n\n# 10. 什么时候会出现当前读（current read）\n\n * 当 sql 语句中包含如下时，会出现当前读：\n   * update、delete、insert\n   * select ... lock in share mode\n   * select ... for update\n\n# 11. 什么是幻读；幻读有什么问题；该怎么解决\n\n * 幻读是指：一个事务在前后两次查询同一个范围的时候，后一次的查询看到了前一次查询没有出现的行。幻读是在 rr 级别下的，只在当前读出现。幻读专指新插入的行\n * 会破坏语句的语义性，破坏了语句原本的含义；由于不同事务 binlog 上传的顺序不一致，可能会导致实际数据和 binlog 中记录的语句执行完后的结果不一致，根本原因是即使把所有的记录都加上锁，也阻止不了新插入的记录。\n * innodb 引入了间隙锁（gap lock）\n   * 间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。\n   * 间隙锁只与 “ 往这个间隙中插入一个记录 ” 这个操作产生冲突；间隙锁与间隙锁之间不存在冲突关系\n   * 间隙锁可以解决幻读问题，但也会带来并发问题，因为间隙锁会锁住的范围更大，影响了并发度\n     * exg：两个事务都先执行进行了当前读，并都上了间隙锁，一个事务先执行 insert（由于间隙锁进入 blocked），另一个事务再执行 insert（由于间隙锁也进入 blocked)，最后两个事务进入了死锁等待状态\n   * 间隙锁是 rr 级别下的产物，所以为了解决幻读我们还可以采用 rc 隔离级别，此时为了解决数据和日志不一致的问题，我们可以将 binlog 格式设置为 row。（statement 格式是记录了这个 sql 语句，row 格式记录的是实际受影响的数据）\n\n# 12. rr 级别隔离下的加锁规则\n\n * 在 mysql 8.0.33 下，经过自行的实验，得到了下面的结果\n   * 原则1：加锁基本单位是 next-key lock\n   * 原则2：查找过程中访问到的对象才会加锁\n   * 在给唯一索引上锁时，\n     * 无论等值查询还是范围查询，向右遍历到第一个不满足条件的值时，都会退化为间隙锁（范围查询下在新版本中也会进行该优化）\n     * 等值查询下，next-key lock 会退化为行锁\n   * 在给非唯一索引上锁时，\n     * 等值查询下，向右遍历到第一个不满足条件的值时，也会退化为间隙锁\n     * 但范围查询下，向右遍历到第一个不满足条件的值时，不会退化为间隙锁，仍然会保留行锁，形成一个 next-key lock\n   * 在新版本中，等值查询下，唯一索引访问到满足条件的值之后就会停止，不会进一步遍历到不满足条件的行。",charsets:{cjk:!0}},{title:"Redis 缓冲区溢出问题总结",frontmatter:{title:"Redis 缓冲区溢出问题总结",date:"2023-08-16T11:38:13.000Z",permalink:"/pages/c32e71/",tags:["Learning Notes","DataBase","Redis"]},regularPath:"/03.Learning%20Notes/03.DataBase/02.Redis/01.Redis%20%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%20copy.html",relativePath:"03.Learning Notes/03.DataBase/02.Redis/01.Redis 缓冲区溢出问题总结 copy.md",key:"v-81e0e884",path:"/pages/c32e71/",headers:[{level:4,title:"1. 缓冲区应用场景",slug:"_1-缓冲区应用场景",normalizedTitle:"1. 缓冲区应用场景",charIndex:21},{level:4,title:"2. 缓冲区溢出对 Redis 的影响",slug:"_2-缓冲区溢出对-redis-的影响",normalizedTitle:"2. 缓冲区溢出对 redis 的影响",charIndex:207},{level:4,title:"3. 缓冲区溢出的主要原因以及对应解决方案",slug:"_3-缓冲区溢出的主要原因以及对应解决方案",normalizedTitle:"3. 缓冲区溢出的主要原因以及对应解决方案",charIndex:394},{level:4,title:"4. 一些额外注意点",slug:"_4-一些额外注意点",normalizedTitle:"4. 一些额外注意点",charIndex:716}],lastUpdated:"9/2/2023, 2:52:50 PM",lastUpdatedTimestamp:169363757e4,headersStr:"1. 缓冲区应用场景 2. 缓冲区溢出对 Redis 的影响 3. 缓冲区溢出的主要原因以及对应解决方案 4. 一些额外注意点",content:"# Redis 缓冲区溢出问题总结\n\n# 1. 缓冲区应用场景\n\n * 客户端和服务端通信\n   \n   * 分为客户端的输入缓冲区和输出缓冲区\n   \n   * 普通客户端\n   \n   * 订阅客户端\n   \n   * 主从客户端\n\n * 主从数据同步\n   \n   * 全量复制下的复制缓冲区（本质上是一个和从节点连接的客户端）\n   * 增量复制下的复制积压缓冲区（用于网络闪断后的写命令同步恢复）\n\n# 2. 缓冲区溢出对 Redis 的影响\n\n * 引起网络连接关闭\n   * 导致客户端与服务端的连接关闭，造成业务停摆\n   * 导致主从之间的连接关闭，造成主从全量同步命令失败，需要重新执行\n * 引起命令数据丢失\n   * 主节点的复制积压缓冲区属于环形缓冲区，一旦溢出，新写入的命令就会覆盖旧的命令数据，造成命令数据的丢失，进而导致从节点需要重新执行全量复制。\n\n# 3. 缓冲区溢出的主要原因以及对应解决方案\n\n * 命令数据发送过快过大\n   \n   * 对于普通客户端来说，要避免 big key，避免在线上生产环境执行 MONITOR 命令（持续占用输出缓冲区）\n   * 对于复制缓冲区来说，要避免过大的 RDB 文件传输\n\n * 命令数据处理较慢\n   \n   * 要减少 Redis 主线程上的阻塞操作，例如可以使用异步的删除操作等方式，像 UNLINK 等\n\n * 缓冲区空间问题\n   \n   * 可以通过参数 client-output-buffer-limit 来设置合理的输出缓冲区，复制缓冲区和复制积压缓冲区大小。需要注意的是，输入缓冲区大小默认是固定的，只能通过源码来进行修改\n\n# 4. 一些额外注意点\n\n * 可以使用 CLIENT LIST 命令来查询每个客户端对输入缓冲区的使用情况\n\n * 参数 client-output-buffer-limit 的设置包括两方面\n   \n   * 设置输出缓冲区大小的上限阈值\n   * 设置输出缓冲区持续写入数据的数量上限阈值 和 持续写入数据的时间上限阈值\n\n * 给普通客户端设置输出缓冲区大小时，一般都默认为 0，因为普通客户端往往是阻塞式发送数据，一般只需要避免特别大的 bigkey 就行了；而订阅客户端是非阻塞式发送，需要合理设置参数\n\n * 为了加快 RDB 文件的传输 和 避免复制缓冲区积累过多命令，一般把主节点的数据量控制在 2 - 4 GB 左右\n\n * redis 实例会有一个 maxmemory 配置项，超过 maxmemory 后会导致淘汰数据。\n   \n   * 主库上的从库输出缓冲区不计算在 Redis 的使用内存中，只计入了普通客户端和订阅客户端的输出缓冲区\n\n * 主节点上复制缓冲区的内存开销是每个从节点客户端对应主节点上的输出缓冲区占用内存的总和，因此需要控制从节点的数量，以及设置合理的缓冲区大小\n\n * 除了服务端上有缓冲区，客户端中也有缓冲区，例如：Pipeline、操作系统的网络缓冲区。通过一次性批量地发送写入数据，可以减少网络 IO 次数，降低延迟，提高访问性能。",normalizedContent:"# redis 缓冲区溢出问题总结\n\n# 1. 缓冲区应用场景\n\n * 客户端和服务端通信\n   \n   * 分为客户端的输入缓冲区和输出缓冲区\n   \n   * 普通客户端\n   \n   * 订阅客户端\n   \n   * 主从客户端\n\n * 主从数据同步\n   \n   * 全量复制下的复制缓冲区（本质上是一个和从节点连接的客户端）\n   * 增量复制下的复制积压缓冲区（用于网络闪断后的写命令同步恢复）\n\n# 2. 缓冲区溢出对 redis 的影响\n\n * 引起网络连接关闭\n   * 导致客户端与服务端的连接关闭，造成业务停摆\n   * 导致主从之间的连接关闭，造成主从全量同步命令失败，需要重新执行\n * 引起命令数据丢失\n   * 主节点的复制积压缓冲区属于环形缓冲区，一旦溢出，新写入的命令就会覆盖旧的命令数据，造成命令数据的丢失，进而导致从节点需要重新执行全量复制。\n\n# 3. 缓冲区溢出的主要原因以及对应解决方案\n\n * 命令数据发送过快过大\n   \n   * 对于普通客户端来说，要避免 big key，避免在线上生产环境执行 monitor 命令（持续占用输出缓冲区）\n   * 对于复制缓冲区来说，要避免过大的 rdb 文件传输\n\n * 命令数据处理较慢\n   \n   * 要减少 redis 主线程上的阻塞操作，例如可以使用异步的删除操作等方式，像 unlink 等\n\n * 缓冲区空间问题\n   \n   * 可以通过参数 client-output-buffer-limit 来设置合理的输出缓冲区，复制缓冲区和复制积压缓冲区大小。需要注意的是，输入缓冲区大小默认是固定的，只能通过源码来进行修改\n\n# 4. 一些额外注意点\n\n * 可以使用 client list 命令来查询每个客户端对输入缓冲区的使用情况\n\n * 参数 client-output-buffer-limit 的设置包括两方面\n   \n   * 设置输出缓冲区大小的上限阈值\n   * 设置输出缓冲区持续写入数据的数量上限阈值 和 持续写入数据的时间上限阈值\n\n * 给普通客户端设置输出缓冲区大小时，一般都默认为 0，因为普通客户端往往是阻塞式发送数据，一般只需要避免特别大的 bigkey 就行了；而订阅客户端是非阻塞式发送，需要合理设置参数\n\n * 为了加快 rdb 文件的传输 和 避免复制缓冲区积累过多命令，一般把主节点的数据量控制在 2 - 4 gb 左右\n\n * redis 实例会有一个 maxmemory 配置项，超过 maxmemory 后会导致淘汰数据。\n   \n   * 主库上的从库输出缓冲区不计算在 redis 的使用内存中，只计入了普通客户端和订阅客户端的输出缓冲区\n\n * 主节点上复制缓冲区的内存开销是每个从节点客户端对应主节点上的输出缓冲区占用内存的总和，因此需要控制从节点的数量，以及设置合理的缓冲区大小\n\n * 除了服务端上有缓冲区，客户端中也有缓冲区，例如：pipeline、操作系统的网络缓冲区。通过一次性批量地发送写入数据，可以减少网络 io 次数，降低延迟，提高访问性能。",charsets:{cjk:!0}},{title:"「缓存和数据库一致性问题」阅读笔记",frontmatter:{title:"「缓存和数据库一致性问题」阅读笔记",date:"2023-08-16T11:38:13.000Z",permalink:"/pages/aac048/",tags:["Learning Notes","DataBase","Redis"]},regularPath:"/03.Learning%20Notes/03.DataBase/02.Redis/02.%E3%80%8C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E3%80%8D%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html",relativePath:"03.Learning Notes/03.DataBase/02.Redis/02.「缓存和数据库一致性问题」阅读笔记.md",key:"v-ed83a606",path:"/pages/aac048/",headers:[{level:4,title:"全量缓存（后台定时刷新）：",slug:"全量缓存-后台定时刷新",normalizedTitle:"全量缓存（后台定时刷新）：",charIndex:41},{level:4,title:"提高缓存利用率：",slug:"提高缓存利用率",normalizedTitle:"提高缓存利用率：",charIndex:115},{level:4,title:"数据一致性问题：",slug:"数据一致性问题",normalizedTitle:"数据一致性问题：",charIndex:186},{level:4,title:"删除缓存方案",slug:"删除缓存方案",normalizedTitle:"删除缓存方案",charIndex:840},{level:3,title:"读写分离 + 主从复制延迟",slug:"读写分离-主从复制延迟",normalizedTitle:"读写分离 + 主从复制延迟",charIndex:1817},{level:3,title:"如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题",slug:"如何解决-1-「先删除缓存-后更新数据库」-方案-和-2-「读写分离-主从复制延迟」-场景下并发导致的数据不一致问题",normalizedTitle:"如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题",charIndex:2037},{level:3,title:"总结与心得【转载原文内容】",slug:"总结与心得【转载原文内容】",normalizedTitle:"总结与心得【转载原文内容】",charIndex:2359},{level:5,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:624},{level:5,title:"四点心得",slug:"四点心得",normalizedTitle:"四点心得",charIndex:2812}],lastUpdated:"9/2/2023, 2:52:50 PM",lastUpdatedTimestamp:169363757e4,headersStr:"全量缓存（后台定时刷新）： 提高缓存利用率： 数据一致性问题： 删除缓存方案 读写分离 + 主从复制延迟 如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题 总结与心得【转载原文内容】 总结 四点心得",content:"> 本文是在阅读了 『缓存和数据库一致性问题，看这篇就够了』 后整理的笔记\n\n# 全量缓存（后台定时刷新）：\n\n * 优点： 所有读请求都可以直接命中缓存，性能高\n\n * 缺点： 缓存利用率低；数据不一致市场依赖于定时时间\n\n# 提高缓存利用率：\n\n * 写请求依然全交给数据库，读请求先访问缓存，不存在则访问数据库并更新缓存，缓存中的数据设置过期时间（只读缓存）\n\n# 数据一致性问题：\n\n * 「第二步」操作失败引发的数据不一致\n   \n   * 先更新缓存，再更新数据库：如果更新数据库失败，会导致缓存中是新值，数据库中是旧值；缓存失效后，都是旧值\n   \n   * 先更新数据库，再更新缓存：如果缓存更新失败，数据库中是新值，缓存中是旧值；缓存失效后重读，才变回一致正确\n\n * 并发引发的一致性问题\n   \n   * 假设先更新数据库，再更新缓存：\n   \n   * 1. 线程 A 更新数据库 X = 1\n     \n     2. 线程 B 更新数据库 X = 2\n     \n     3. 线程 B 更新缓存 X = 2\n     \n     4. 线程 A 更新缓存 X = 1\n   \n   * 数据库中为 X = 2，缓存中 X = 1 ===》 数据不一致\n   \n   * 「先更新缓存，更新数据库」的方案类似\n   \n   * 解决方案：加 「分布式锁」，但会导致性能下降\n\n * 「更新数据库 + 更新缓存」 的方案总结\n   \n   * 数据不一致问题（「操作失败」和「并发」引起）\n   \n   * 性能下降问题原因\n     \n     * 引入分布式锁\n     \n     * 每次更新可能都要根据数据库中的数据计算缓存中的值（例如计算个人收到的视频点赞数量，可能需要通过计算个人所有视频的点赞数量总和）\n   \n   * 缓存利用率低问题原因\n     \n     * 更新数据库后，无脑更新缓存，但缓存中的数据未必会被马上读取\n\n# 删除缓存方案\n\n * 『推荐』先更新数据库，后删除缓存\n   \n   * 在「第二步」操作失败场景下，数据库中是新值，缓存中是旧值，在缓存失效前会产生数据不一致的问题\n   \n   * 在并发场景下，发生数据不一致的概率非常低，「如下面的场景所示」\n     \n     * 线程 A 读，线程 B 写，缓存中 X 失效不存在\n     \n     * 1. 线程 A 读取数据库得到旧值\n       \n       2. 线程 B 更新数据库，并删除缓存\n       \n       3. 线程 A 将旧值写入缓存\n     \n     * 数据库中是新值，缓存中是旧值\n     \n     * 需要满足：1. 缓存失效 2. 两个线程并发读和写 3. 步骤「2」 比 步骤 「1」「3」 短\n     \n     * 写数据库往往要「加锁」，第三点发生概率很低\n   \n   * 为了解决「第二步」操作失败场景下的问题，可以采取方案：「重试」\n     \n     * 需要考虑的问题有：1. 重试依然可能失败 2. 重试多少次才合理 3. 重试会占用线程资源，无法服务其他客户端请求\n     \n     * 更好的方案：「异步重试」\n       \n       * 独立出一个消息队列服务，将重试消息发送给该服务，异步化的去更新缓存。\n       \n       * 好处：独立服务中的队列，直到消息被成功消费之前都不会丢失，且只有成功消费才会删除\n   \n   * 删除缓存的操作还可以通过「订阅数据库变更日志，再操作缓存」，例如阿里的 cannal\n\n * 先删除缓存，后更新数据库\n   \n   * 在「第二步」操作失败场景下，缓存中没有值，数据库没有更新成功，数据满足一致性\n   \n   * 在并发场景下，在下面的情况下会发生数据不一致\n     \n     * 线程 A 写，线程 B 读\n     \n     * 1. 线程 A 删除缓存\n       \n       2. 线程 B 读缓存，发生缺失读数据库，得到旧值\n       \n       3. 线程 A 更新数据库，数据库中是新值\n       \n       4. 线程 B 将旧值写回缓存\n     \n     * 数据库中是新值，缓存中是旧值\n\n\n# 读写分离 + 主从复制延迟\n\n * 并发场景下依然会数据不一致，即使采用「先更新数据库，后删除缓存」方案\n   \n   * 线程 A 写，线程 B 读\n   \n   * 1. 线程 A 删除缓存\n     \n     2. 线程 B 读取缓存，发生缺失查询从库，得到旧值\n     \n     3. 从库同步完成，主从库都是新值\n     \n     4. 线程 B 将旧值写回缓存中\n   \n   * 主从库中是新值，缓存是旧值\n\n\n# 如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题\n\n * 「缓存会被回种旧值」是问题的本质\n\n * 「缓存延迟双删策略」\n   \n   ① 在线程 A 删除缓存，更新数据库 的操作完成后再延迟进行一次缓存删除\n   \n   ② 线程 A 生成一条「延时消息」，写到消息队列中，消费者延时删除缓存\n\n * 延迟时间设置多久？\n   \n   * 1. 延迟时间要大于「主从复制」的延迟时间\n     \n     2. 延迟时间要大于线程 B 读取数据库 + 旧值写回缓存的时间\n   \n   * 在分布式高并发场景下，这个时间很难评估，无法保证极端场景下的数据一致性\n\n\n# 总结与心得【转载原文内容】\n\n# 总结\n\n1. 想要提高应用的性能，可以引入「缓存」来解决\n\n2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n\n3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况\n\n4. 采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估\n\n5. 采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致\n\n6. 采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n\n# 四点心得\n\n1. 性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案\n\n2. 掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题\n\n3. 失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案\n\n4. 订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致",normalizedContent:"> 本文是在阅读了 『缓存和数据库一致性问题，看这篇就够了』 后整理的笔记\n\n# 全量缓存（后台定时刷新）：\n\n * 优点： 所有读请求都可以直接命中缓存，性能高\n\n * 缺点： 缓存利用率低；数据不一致市场依赖于定时时间\n\n# 提高缓存利用率：\n\n * 写请求依然全交给数据库，读请求先访问缓存，不存在则访问数据库并更新缓存，缓存中的数据设置过期时间（只读缓存）\n\n# 数据一致性问题：\n\n * 「第二步」操作失败引发的数据不一致\n   \n   * 先更新缓存，再更新数据库：如果更新数据库失败，会导致缓存中是新值，数据库中是旧值；缓存失效后，都是旧值\n   \n   * 先更新数据库，再更新缓存：如果缓存更新失败，数据库中是新值，缓存中是旧值；缓存失效后重读，才变回一致正确\n\n * 并发引发的一致性问题\n   \n   * 假设先更新数据库，再更新缓存：\n   \n   * 1. 线程 a 更新数据库 x = 1\n     \n     2. 线程 b 更新数据库 x = 2\n     \n     3. 线程 b 更新缓存 x = 2\n     \n     4. 线程 a 更新缓存 x = 1\n   \n   * 数据库中为 x = 2，缓存中 x = 1 ===》 数据不一致\n   \n   * 「先更新缓存，更新数据库」的方案类似\n   \n   * 解决方案：加 「分布式锁」，但会导致性能下降\n\n * 「更新数据库 + 更新缓存」 的方案总结\n   \n   * 数据不一致问题（「操作失败」和「并发」引起）\n   \n   * 性能下降问题原因\n     \n     * 引入分布式锁\n     \n     * 每次更新可能都要根据数据库中的数据计算缓存中的值（例如计算个人收到的视频点赞数量，可能需要通过计算个人所有视频的点赞数量总和）\n   \n   * 缓存利用率低问题原因\n     \n     * 更新数据库后，无脑更新缓存，但缓存中的数据未必会被马上读取\n\n# 删除缓存方案\n\n * 『推荐』先更新数据库，后删除缓存\n   \n   * 在「第二步」操作失败场景下，数据库中是新值，缓存中是旧值，在缓存失效前会产生数据不一致的问题\n   \n   * 在并发场景下，发生数据不一致的概率非常低，「如下面的场景所示」\n     \n     * 线程 a 读，线程 b 写，缓存中 x 失效不存在\n     \n     * 1. 线程 a 读取数据库得到旧值\n       \n       2. 线程 b 更新数据库，并删除缓存\n       \n       3. 线程 a 将旧值写入缓存\n     \n     * 数据库中是新值，缓存中是旧值\n     \n     * 需要满足：1. 缓存失效 2. 两个线程并发读和写 3. 步骤「2」 比 步骤 「1」「3」 短\n     \n     * 写数据库往往要「加锁」，第三点发生概率很低\n   \n   * 为了解决「第二步」操作失败场景下的问题，可以采取方案：「重试」\n     \n     * 需要考虑的问题有：1. 重试依然可能失败 2. 重试多少次才合理 3. 重试会占用线程资源，无法服务其他客户端请求\n     \n     * 更好的方案：「异步重试」\n       \n       * 独立出一个消息队列服务，将重试消息发送给该服务，异步化的去更新缓存。\n       \n       * 好处：独立服务中的队列，直到消息被成功消费之前都不会丢失，且只有成功消费才会删除\n   \n   * 删除缓存的操作还可以通过「订阅数据库变更日志，再操作缓存」，例如阿里的 cannal\n\n * 先删除缓存，后更新数据库\n   \n   * 在「第二步」操作失败场景下，缓存中没有值，数据库没有更新成功，数据满足一致性\n   \n   * 在并发场景下，在下面的情况下会发生数据不一致\n     \n     * 线程 a 写，线程 b 读\n     \n     * 1. 线程 a 删除缓存\n       \n       2. 线程 b 读缓存，发生缺失读数据库，得到旧值\n       \n       3. 线程 a 更新数据库，数据库中是新值\n       \n       4. 线程 b 将旧值写回缓存\n     \n     * 数据库中是新值，缓存中是旧值\n\n\n# 读写分离 + 主从复制延迟\n\n * 并发场景下依然会数据不一致，即使采用「先更新数据库，后删除缓存」方案\n   \n   * 线程 a 写，线程 b 读\n   \n   * 1. 线程 a 删除缓存\n     \n     2. 线程 b 读取缓存，发生缺失查询从库，得到旧值\n     \n     3. 从库同步完成，主从库都是新值\n     \n     4. 线程 b 将旧值写回缓存中\n   \n   * 主从库中是新值，缓存是旧值\n\n\n# 如何解决 ① 「先删除缓存，后更新数据库」 方案 和 ② 「读写分离 + 主从复制延迟」 场景下并发导致的数据不一致问题\n\n * 「缓存会被回种旧值」是问题的本质\n\n * 「缓存延迟双删策略」\n   \n   ① 在线程 a 删除缓存，更新数据库 的操作完成后再延迟进行一次缓存删除\n   \n   ② 线程 a 生成一条「延时消息」，写到消息队列中，消费者延时删除缓存\n\n * 延迟时间设置多久？\n   \n   * 1. 延迟时间要大于「主从复制」的延迟时间\n     \n     2. 延迟时间要大于线程 b 读取数据库 + 旧值写回缓存的时间\n   \n   * 在分布式高并发场景下，这个时间很难评估，无法保证极端场景下的数据一致性\n\n\n# 总结与心得【转载原文内容】\n\n# 总结\n\n1. 想要提高应用的性能，可以引入「缓存」来解决\n\n2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n\n3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况\n\n4. 采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估\n\n5. 采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致\n\n6. 采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n\n# 四点心得\n\n1. 性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案\n\n2. 掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题\n\n3. 失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案\n\n4. 订阅变更日志的思想，本质是把权威数据源（例如 mysql）当做 leader 副本，让其它异质系统（例如 redis / elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致",charsets:{cjk:!0}},{title:"01 - 概述",frontmatter:{title:"01 - 概述",date:"2023-09-21T22:41:49.000Z",permalink:"/pages/15f315/",tags:["Learning Notes","Software Engineering"]},regularPath:"/03.Learning%20Notes/04.Software%20Engineering/01.THU%20Course%20Notes/01.%E8%BD%AF%E5%B7%A5%E7%AC%94%E8%AE%B001%EF%BC%9A%E6%A6%82%E8%BF%B0.html",relativePath:"03.Learning Notes/04.Software Engineering/01.THU Course Notes/01.软工笔记01：概述.md",key:"v-fc04b82a",path:"/pages/15f315/",headers:[{level:3,title:"何为软件工程？",slug:"何为软件工程",normalizedTitle:"何为软件工程？",charIndex:14},{level:3,title:"软件开发面临的问题",slug:"软件开发面临的问题",normalizedTitle:"软件开发面临的问题",charIndex:112},{level:3,title:"软件开发的过程",slug:"软件开发的过程",normalizedTitle:"软件开发的过程",charIndex:127},{level:3,title:"软件开发的基本策略",slug:"软件开发的基本策略",normalizedTitle:"软件开发的基本策略",charIndex:319}],lastUpdated:"9/21/2023, 11:03:09 PM",lastUpdatedTimestamp:1695308589e3,headersStr:"何为软件工程？ 软件开发面临的问题 软件开发的过程 软件开发的基本策略",content:"# 01 - 概述\n\n\n# 何为软件工程？\n\n * 软件工程涵盖了系统性、规范性、和严格性的方法来开发高质量的软件。\n\n * 软件工程关注的不仅是软件的开发，还包括软件的需求分析、设计、实现、测试以及维护等各个方面\n\n\n# 软件开发面临的问题\n\n\n\n# 软件开发的过程\n\n 1. 问题定义：现实中遇到问题，研究并定义问题\n\n 2. 需求开发：确定和分析用户的需求（提出具体的需求）\n\n 3. 软件设计：设计整个系统的总体结构\n    \n    * 接口、前端、后端架构、数据库、存储...\n\n 4. 软件构造：编程实现系统各个部分（具体写代码环节）\n\n 5. 软件测试：对各个部分集成起来进行测试（步骤 4 过程中也要进行测试）\n\n\n# 软件开发的基本策略\n\n 1. 软件复用：复用现成的构件，包括但不仅限于代码、类库、文档、设计模式、组件、框架等\n\n 2. 分而治之：将复杂问题分解成相对简单的小问题\n\n 3. 逐步演进：遵循客观规律，迭代式地增量开发\n\n 4. 优化折中：优化软件质量特性，协调各个特性达到整体最优\n    \n    * 具体得根据业务场景来分析，对于不同业务、服务、模块都有着各自倾向的优化策略，常常需要 trade-off",normalizedContent:"# 01 - 概述\n\n\n# 何为软件工程？\n\n * 软件工程涵盖了系统性、规范性、和严格性的方法来开发高质量的软件。\n\n * 软件工程关注的不仅是软件的开发，还包括软件的需求分析、设计、实现、测试以及维护等各个方面\n\n\n# 软件开发面临的问题\n\n\n\n# 软件开发的过程\n\n 1. 问题定义：现实中遇到问题，研究并定义问题\n\n 2. 需求开发：确定和分析用户的需求（提出具体的需求）\n\n 3. 软件设计：设计整个系统的总体结构\n    \n    * 接口、前端、后端架构、数据库、存储...\n\n 4. 软件构造：编程实现系统各个部分（具体写代码环节）\n\n 5. 软件测试：对各个部分集成起来进行测试（步骤 4 过程中也要进行测试）\n\n\n# 软件开发的基本策略\n\n 1. 软件复用：复用现成的构件，包括但不仅限于代码、类库、文档、设计模式、组件、框架等\n\n 2. 分而治之：将复杂问题分解成相对简单的小问题\n\n 3. 逐步演进：遵循客观规律，迭代式地增量开发\n\n 4. 优化折中：优化软件质量特性，协调各个特性达到整体最优\n    \n    * 具体得根据业务场景来分析，对于不同业务、服务、模块都有着各自倾向的优化策略，常常需要 trade-off",charsets:{cjk:!0}},{title:"02 - 软件过程",frontmatter:{title:"02 - 软件过程",date:"2023-09-24T19:48:45.000Z",permalink:"/pages/7b3c38/",tags:["Learning Notes","Software Engineering"]},regularPath:"/03.Learning%20Notes/04.Software%20Engineering/01.THU%20Course%20Notes/02.%E8%BD%AF%E5%B7%A5%E7%AC%94%E8%AE%B002%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.html",relativePath:"03.Learning Notes/04.Software Engineering/01.THU Course Notes/02.软工笔记02：软件过程.md",key:"v-37e5e89e",path:"/pages/7b3c38/",headers:[{level:3,title:"软件开发活动",slug:"软件开发活动",normalizedTitle:"软件开发活动",charIndex:34},{level:4,title:"需求开发",slug:"需求开发",normalizedTitle:"需求开发",charIndex:79},{level:4,title:"软件设计",slug:"软件设计",normalizedTitle:"软件设计",charIndex:131},{level:4,title:"软件构造",slug:"软件构造",normalizedTitle:"软件构造",charIndex:179},{level:4,title:"软件测试",slug:"软件测试",normalizedTitle:"软件测试",charIndex:229},{level:4,title:"软件维护",slug:"软件维护",normalizedTitle:"软件维护",charIndex:293},{level:3,title:"软件过程模型",slug:"软件过程模型",normalizedTitle:"软件过程模型",charIndex:327},{level:4,title:"瀑布模型",slug:"瀑布模型",normalizedTitle:"瀑布模型",charIndex:341},{level:4,title:"原型化模型",slug:"原型化模型",normalizedTitle:"原型化模型",charIndex:449},{level:4,title:"迭代式开发",slug:"迭代式开发",normalizedTitle:"迭代式开发",charIndex:507},{level:4,title:"可转换模型",slug:"可转换模型",normalizedTitle:"可转换模型",charIndex:619},{level:3,title:"案例分析",slug:"案例分析",normalizedTitle:"案例分析",charIndex:737}],lastUpdated:"10/6/2023, 10:59:33 PM",lastUpdatedTimestamp:1696604373e3,headersStr:"软件开发活动 需求开发 软件设计 软件构造 软件测试 软件维护 软件过程模型 瀑布模型 原型化模型 迭代式开发 可转换模型 案例分析",content:"# 【软件工程】Learning Notes（二）软件过程\n\n\n# 软件开发活动\n\n在得到用户需求后，就会经历软件过程，最终得到想要的产品。\n\n\n 1. # 需求开发\n\n在收集到需求后，对其进行分析和建模系统行为，并根据系统行为生成规格说明文档\n\n\n 2. # 软件设计\n\n根据规格说明文档，进一步设计软件（整体、接口、组件、数据库...）\n\n\n 3. # 软件构造\n\n根据设计好的模型进行软件的实际开发构造，涉及了编写、测试、优化、审查等\n\n\n 4. # 软件测试\n\n除了软件构造过程中要测试，发布产品前也要进行测试，包含了单元测试、子系统测试、集成测试、验收测试等\n\n\n 5. # 软件维护\n\n产品投入使用后也要进行迭代更新，需要运维、维护\n\n\n# 软件过程模型\n\n 1. # 瀑布模型\n\n线性流程，只有流程完成才能看到产品成果，开发过程中难以适应需求的变化。\n\n\n * 借鉴了制造业的开发模式，但并不是和创造性的软件开发，无法适应软件开发的迭代性（不断尝试，选择比较不同设计）\n\n 2. # 原型化模型\n\n更早的去构建软件原型，有助于客户更清楚地确定自己的需求，帮助开发人员更好评价分析产品\n\n\n 3. # 迭代式开发\n\n通过逐步构建发布，缩短开发周期，更早的获得用户反馈\n\n * 增量模型：每一个新的发布中逐步增加功能直到完善\n\n * 迭代模型：一开始提交一个完整系统，在后续发布中 补充完善各子系统功能\n   \n\n\n 4. # 可转换模型\n\n采用形式化的数学方法来描述系统，并利用自动化手段，通过一系列转换，将形式化的需求规格说明，变为可交付使用的系统。\n\n * 数学方法更严密准确，减少缺陷，提高安全性\n\n * 主要应用于有限状态的嵌入式系统中\n   \n\n\n# 案例分析\n\n",normalizedContent:"# 【软件工程】learning notes（二）软件过程\n\n\n# 软件开发活动\n\n在得到用户需求后，就会经历软件过程，最终得到想要的产品。\n\n\n 1. # 需求开发\n\n在收集到需求后，对其进行分析和建模系统行为，并根据系统行为生成规格说明文档\n\n\n 2. # 软件设计\n\n根据规格说明文档，进一步设计软件（整体、接口、组件、数据库...）\n\n\n 3. # 软件构造\n\n根据设计好的模型进行软件的实际开发构造，涉及了编写、测试、优化、审查等\n\n\n 4. # 软件测试\n\n除了软件构造过程中要测试，发布产品前也要进行测试，包含了单元测试、子系统测试、集成测试、验收测试等\n\n\n 5. # 软件维护\n\n产品投入使用后也要进行迭代更新，需要运维、维护\n\n\n# 软件过程模型\n\n 1. # 瀑布模型\n\n线性流程，只有流程完成才能看到产品成果，开发过程中难以适应需求的变化。\n\n\n * 借鉴了制造业的开发模式，但并不是和创造性的软件开发，无法适应软件开发的迭代性（不断尝试，选择比较不同设计）\n\n 2. # 原型化模型\n\n更早的去构建软件原型，有助于客户更清楚地确定自己的需求，帮助开发人员更好评价分析产品\n\n\n 3. # 迭代式开发\n\n通过逐步构建发布，缩短开发周期，更早的获得用户反馈\n\n * 增量模型：每一个新的发布中逐步增加功能直到完善\n\n * 迭代模型：一开始提交一个完整系统，在后续发布中 补充完善各子系统功能\n   \n\n\n 4. # 可转换模型\n\n采用形式化的数学方法来描述系统，并利用自动化手段，通过一系列转换，将形式化的需求规格说明，变为可交付使用的系统。\n\n * 数学方法更严密准确，减少缺陷，提高安全性\n\n * 主要应用于有限状态的嵌入式系统中\n   \n\n\n# 案例分析\n\n",charsets:{cjk:!0}},{title:"03 - 用例建模",frontmatter:{title:"03 - 用例建模",date:"2023-10-06T22:57:03.000Z",permalink:"/pages/d38254/",tags:["Learning Notes","Software Engineering"]},regularPath:"/03.Learning%20Notes/04.Software%20Engineering/01.THU%20Course%20Notes/03.%E8%BD%AF%E5%B7%A5%E7%AC%94%E8%AE%B003%EF%BC%9A%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1.html",relativePath:"03.Learning Notes/04.Software Engineering/01.THU Course Notes/03.软工笔记03：用例建模.md",key:"v-4db5ae13",path:"/pages/d38254/",headers:[{level:2,title:"用例建模概念",slug:"用例建模概念",normalizedTitle:"用例建模概念",charIndex:34},{level:3,title:"文本描述",slug:"文本描述",normalizedTitle:"文本描述",charIndex:49},{level:3,title:"用例图",slug:"用例图",normalizedTitle:"用例图",charIndex:67},{level:3,title:"什么是用例？",slug:"什么是用例",normalizedTitle:"什么是用例？",charIndex:84},{level:3,title:"参与者的定义",slug:"参与者的定义",normalizedTitle:"参与者的定义",charIndex:240},{level:3,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:190},{level:3,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:339},{level:2,title:"用例建模过程",slug:"用例建模过程",normalizedTitle:"用例建模过程",charIndex:351},{level:3,title:"构建用例模型的步骤",slug:"构建用例模型的步骤",normalizedTitle:"构建用例模型的步骤",charIndex:362},{level:3,title:"第一步：寻找参与者和用例",slug:"第一步-寻找参与者和用例",normalizedTitle:"第一步：寻找参与者和用例",charIndex:517},{level:4,title:"寻找参与者",slug:"寻找参与者",normalizedTitle:"寻找参与者",charIndex:521},{level:4,title:"寻找用例",slug:"寻找用例",normalizedTitle:"寻找用例",charIndex:553},{level:3,title:"第二步：编写用例",slug:"第二步-编写用例",normalizedTitle:"第二步：编写用例",charIndex:441},{level:2,title:"用例精讲",slug:"用例精讲",normalizedTitle:"用例精讲",charIndex:583},{level:3,title:"设定系统边界",slug:"设定系统边界",normalizedTitle:"设定系统边界",charIndex:596},{level:3,title:"何时使用包含关系？",slug:"何时使用包含关系",normalizedTitle:"何时使用包含关系？",charIndex:640},{level:3,title:"何时使用扩展关系？",slug:"何时使用扩展关系",normalizedTitle:"何时使用扩展关系？",charIndex:663},{level:3,title:"用例图中的主要图标",slug:"用例图中的主要图标",normalizedTitle:"用例图中的主要图标",charIndex:686}],lastUpdated:"10/6/2023, 10:59:33 PM",lastUpdatedTimestamp:1696604373e3,headersStr:"用例建模概念 文本描述 用例图 什么是用例？ 参与者的定义 交互 场景 用例建模过程 构建用例模型的步骤 第一步：寻找参与者和用例 寻找参与者 寻找用例 第二步：编写用例 用例精讲 设定系统边界 何时使用包含关系？ 何时使用扩展关系？ 用例图中的主要图标",content:"# 【软件工程】Learning Notes（三）用例建模\n\n\n# 用例建模概念\n\n\n 1. # 文本描述\n    \n\n\n 2. # 用例图\n    \n\n\n 3. # 什么是用例？\n\n一个用例可以定义系统的一系列行为，通过此可为参与者提供有价值且可观测的结果。\n\n * 定义一个参与者要用到的系统功能\n\n * 描述系统为实现参与者价值所开展的行为序列\n\n * 对参与者与系统之间的交互活动进行建模\n\n * 从特定的用户角度出发，是完整的，实现特定用户价值的事件流\n\n\n 4. # 参与者的定义\n\n * 与系统交互的人 或 与系统交互的硬件组件 或 其他的外部系统\n\n * 关注的重点是所承担的 “角色”\n\n * 命名明确且唯一\n\n\n 5. # 交互\n    \n\n\n\n 6. # 场景\n    \n\n\n# 用例建模过程\n\n\n# 构建用例模型的步骤\n\n * 第一步：找到所有的参与者和用例\n   \n   * 识别出参与者并做简单的描述\n   \n   * 识别出用例并做简单的介绍\n\n * 第二步：编写用例\n   \n   * 列出用例\n   \n   * 给用例事件流程划分重要等级\n   \n   * 按照重要程度排序详细描述事件流程\n\n\n# 第一步：寻找参与者和用例\n\n 1. # 寻找参与者\n\n\n\n\n 2. # 寻找用例\n\n\n\n\n\n# 第二步：编写用例\n\n\n\n\n\n\n\n# 用例精讲\n\n\n 1. # 设定系统边界\n    \n\n 2. 不要把用例定义成功能分解\n    \n\n\n\n 3. # 何时使用包含关系？\n    \n\n\n 4. # 何时使用扩展关系？\n    \n\n\n 5. # 用例图中的主要图标\n    ",normalizedContent:"# 【软件工程】learning notes（三）用例建模\n\n\n# 用例建模概念\n\n\n 1. # 文本描述\n    \n\n\n 2. # 用例图\n    \n\n\n 3. # 什么是用例？\n\n一个用例可以定义系统的一系列行为，通过此可为参与者提供有价值且可观测的结果。\n\n * 定义一个参与者要用到的系统功能\n\n * 描述系统为实现参与者价值所开展的行为序列\n\n * 对参与者与系统之间的交互活动进行建模\n\n * 从特定的用户角度出发，是完整的，实现特定用户价值的事件流\n\n\n 4. # 参与者的定义\n\n * 与系统交互的人 或 与系统交互的硬件组件 或 其他的外部系统\n\n * 关注的重点是所承担的 “角色”\n\n * 命名明确且唯一\n\n\n 5. # 交互\n    \n\n\n\n 6. # 场景\n    \n\n\n# 用例建模过程\n\n\n# 构建用例模型的步骤\n\n * 第一步：找到所有的参与者和用例\n   \n   * 识别出参与者并做简单的描述\n   \n   * 识别出用例并做简单的介绍\n\n * 第二步：编写用例\n   \n   * 列出用例\n   \n   * 给用例事件流程划分重要等级\n   \n   * 按照重要程度排序详细描述事件流程\n\n\n# 第一步：寻找参与者和用例\n\n 1. # 寻找参与者\n\n\n\n\n 2. # 寻找用例\n\n\n\n\n\n# 第二步：编写用例\n\n\n\n\n\n\n\n# 用例精讲\n\n\n 1. # 设定系统边界\n    \n\n 2. 不要把用例定义成功能分解\n    \n\n\n\n 3. # 何时使用包含关系？\n    \n\n\n 4. # 何时使用扩展关系？\n    \n\n\n 5. # 用例图中的主要图标\n    ",charsets:{cjk:!0}},{title:"通过 Bit-Manipulation 实现 abs 函数",frontmatter:{title:"通过 Bit-Manipulation 实现 abs 函数",date:"2022-09-10T21:46:17.000Z",permalink:"/pages/b04817/",tags:["Learning Notes","Others"]},regularPath:"/03.Learning%20Notes/05.Others/01.%E9%80%9A%E8%BF%87%20Bit-Manipulation%20%E5%AE%9E%E7%8E%B0%20abs%20%E5%87%BD%E6%95%B0.html",relativePath:"03.Learning Notes/05.Others/01.通过 Bit-Manipulation 实现 abs 函数.md",key:"v-dc8b9824",path:"/pages/b04817/",headers:[{level:3,title:"题意",slug:"题意",normalizedTitle:"题意",charIndex:2},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:47},{level:3,title:"分析",slug:"分析",normalizedTitle:"分析",charIndex:120}],lastUpdated:"9/21/2023, 10:59:25 PM",lastUpdatedTimestamp:1695308365e3,headersStr:"题意 代码 分析",content:"# 题意\n\n实现函数 int abs(int x)，当 时，返回 ，当 时，返回 。\n\n\n# 代码\n\n先说结论：\n\nint abs(int x) {\n    return (x >> 31 ^ x) - (x >> 31);\n}\n\n\n\n# 分析\n\n首先我们要知道如果通过位运算来得到一个数的相反数。我们可以通过 ~x + 1，即对一个数取反加一就能得到该数的相反数，这是因为 ~x + x = 0b11111...，而 0b11111...就是二进制补码下的 -1，我们再加 1，就能得到 0 了。因此 (~x + 1) + x = 0，即 ~x + 1 是 x 的相反数。\n\n我们对答案 (x >> 31 ^ x) - (x >> 31)进行分析：\n\n当 时，因为是 signed int，会进行算术右移，所以 x >> 31 会得到 0b11111...，即 -1, 很容易发现，此时 -1 ^ x 就相当于对每一个二进制位进行取反。而后面的 - (x >> 31) 很容易看出就是 + 1，整体就是 return ~x + 1;\n\n当 时，x >> 31 会得到 0b00000...，此时进行异或操作后得到的结果还是 x，而后面则是个 - 0，整体就是 return x - 0;\n\n综上，我们便可以通过位运算实现 abs 函数了。",normalizedContent:"# 题意\n\n实现函数 int abs(int x)，当 时，返回 ，当 时，返回 。\n\n\n# 代码\n\n先说结论：\n\nint abs(int x) {\n    return (x >> 31 ^ x) - (x >> 31);\n}\n\n\n\n# 分析\n\n首先我们要知道如果通过位运算来得到一个数的相反数。我们可以通过 ~x + 1，即对一个数取反加一就能得到该数的相反数，这是因为 ~x + x = 0b11111...，而 0b11111...就是二进制补码下的 -1，我们再加 1，就能得到 0 了。因此 (~x + 1) + x = 0，即 ~x + 1 是 x 的相反数。\n\n我们对答案 (x >> 31 ^ x) - (x >> 31)进行分析：\n\n当 时，因为是 signed int，会进行算术右移，所以 x >> 31 会得到 0b11111...，即 -1, 很容易发现，此时 -1 ^ x 就相当于对每一个二进制位进行取反。而后面的 - (x >> 31) 很容易看出就是 + 1，整体就是 return ~x + 1;\n\n当 时，x >> 31 会得到 0b00000...，此时进行异或操作后得到的结果还是 x，而后面则是个 - 0，整体就是 return x - 0;\n\n综上，我们便可以通过位运算实现 abs 函数了。",charsets:{cjk:!0}},{title:"408 计组笔记",frontmatter:{title:"408 计组笔记",date:"2024-07-19T16:27:05.000Z",permalink:"/pages/0e1ab0/",tags:[null]},regularPath:"/03.Learning%20Notes/05.Others/02.408%20%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0.html",relativePath:"03.Learning Notes/05.Others/02.408 计组笔记.md",key:"v-f4b56318",path:"/pages/0e1ab0/",lastUpdated:"7/29/2024, 12:27:36 AM",lastUpdatedTimestamp:1722184056e3,headersStr:null,content:"指令系统 基础知识 指令一般由 操作码op、寻址特征C、地址码A 组成 根据地址数的个数，一般分为 零、一、二、三地址指令\n\n * ISA 规定了：数据类型及格式、指令格式、寻址方式和可访问地址空间大小、I/O 空间的编址方式、中断 结构、机器的工作状态定义和切换、输入输出结构和数据传送方式、存储保护方式等\n   * ISA 指的是软件可以感知的部分，称为软件可见部分\n   * 而指令具体在硬件上如何执行的，称为微体系结构、微架构，这是软件不可感知的，例如如何实现加法器\n   * 综上，不同微架构的机器可以使用相同的 ISA\n   * \n\n定长操作码指令 操作码为固定位数 n 位，那么可以支持的指令个数只有\n\n\n\n变长操作码指令 指令字长一般固定，有以下几点需要注意：\n\n\n\n 1. 短op 不能是 长op 的前缀\n 2. op 不能重复\n 3. 一般频率较高的指令分配短 op，依次减少译码时间 做题策略：\n\n * 从短 op 开始讨论，短 op 尽可能分配，但要留出 n 种用来扩展\n * 如果是给了四地址，二地址，判断三地址的最多的个数：需要注意三地址码（短op）不能占据二地址码（长op）的，但是反过来可以，所以有可能出现指令操作码不完全分配干净情况。\n * 例1：在一个指令系统中，指令字长为32，一个地址码为6位，指令分为4地址指令、3 地址指令和2地址指令，已知4地址指令有 254条，2地址指令有 4097条，则3地址指令至多有多少条?\n * 法一：四地址留出了 10 和 11 用来扩展，这里2地址 op 有 20 位，高八位先用 1111 1111，后十二位全可以分配，共 4096 个，还有一个可以占据三地址的 10，所以再分配一个 1111 1110 | 1111 1111 1111，而三地址则高八位固定只能是 1111 1110，其还剩 6 位 op，只能是 000 000 ~ 111 110\n * 法二：首先四地址留出了两个来扩展，所以三地址一共只有\n   \n   \n   \n   种，但需要留出一部分给二地址；因为二地址要 4097 个，一共 20 位 op，其专属第三个字段部分可以有\n   \n   \n   \n   种，所以前十二位的部分还得占用至少\n   \n   \n   \n   向上取整为 65 种，故 128 - 65 = 63 个\n * 例2：在一个指令系统中，指令字长为 32，一个地址码为 6 位，指令分为 4 地址指令、3 地址指令和 2地址指令，已知 4地址指令有 254 条，2 地址指令有 4095 条，则 3 地址指令至多有多少条?\n * 法一：四地址留出了 10 和 11 用来扩展，这里2地址 op 有 20 位，高八位先用 1111 1111，后十二位全可以分配，共 4096 个，只需要 4095 个，多出来的一个三地址无法使用。而三地址则高八位固定是 1111 1110，其还剩 6 位 op 任意分配共\n   \n   \n   \n   个\n * 法二：首先四地址留出了两个来扩展，所以三地址一共只有\n   \n   \n   \n   种，但需要留出一部分给二地址；因为二地址要 4095 个，一共 20 位 op，其专属第三个字段部分可以有\n   \n   \n   \n   种，所以前十二位的部分还得占用至少\n   \n   \n   \n   向上取整为 64 种，故 128 - 64 = 64 个 寻址方式 立即寻址\n * 地址码为 立即数\n * 获取操作数访存次数：0 直接寻址\n * 地址码为 有效地址\n * 获取操作数访存次数：1 寄存器寻址\n * 地址码为 寄存器编号\n * 获取操作数访存次数：0，由寄存器给出 间接寻址\n * 地址码为 有效地址的地址（假设一次间接）\n * 获取操作数访存次数：2\n   * 将操作码指向的内存中的数据传到 MAR，再进行访存，得到操作数，一共两次 寄存器间接寻址\n * 地址码为 寄存器编号\n * 获取操作数访存次数：1\n   * 从寄存器中获取有效地址，再访存得到操作数，共 1 次 基址寻址\n * 地址码为 偏移量，为补码形式\n * 有效地址 = 偏移地址 + 基址寄存器的值\n * 面向 OS：基址寄存器只能由 OS（内核态）修改，可以实现动态重定位，有利于多道程序与程序浮动\n * 一般分为有基址寄存器和无基址寄存器，如无，则可以在指令中加上一个寄存器编号 变址寻址\n * 地址码为 基准地址，例如数组首地址，而偏移量由变址寄存器给出\n * 有效地址 = 基准地址 + 变址寄存器的值\n * 面向用户：这里的基准地址可以由用户（用户态）修改，便于实现线性表的遍历\n   * 变址寄存器可以由通用寄存器实现，也可以是专门的变址寄存器，存了偏移量（数组下标） [图片] 相对寻址\n * 地址码为 偏移量，可正可负为补码形式\n * 有效地址 = （PC) + 偏移量\n   * 注意这里的 PC 再取指后可能会加 “1”，具体看题目，且 PC 其指向了指令在内存中的首地址，且 + 1 的单位为一个指令字长\n     * 尤其是根据 jmp 计算相对寻址的偏移量，勿忘此时 PC 已经指向了下一条指令，所以偏移量得多个 2\n   * 例如：指令字长为 4B，1 字为 1 B，则向前跳 16 个指令下，新的地址 addr = PC + 1 * 4 - 16 * 4 = PC + (1 - 16) * 4\n * 常用于转移指令 jmp A\n * 便于实现相对转移以及程序的浮动 指令设计风格 RISC vs. CISC\n * 408 中：\n   * 出现：指令流水线、load / store，一定是 RISC\n   * 出现：采用微程序控制，一定是 CISC [图片] MIPS 指令 MIPS 为 RISC 风格的，采用 32 位定长指令字，32 位机器字长，故所有寄存器也为 32 位。操作码字段也是固定的长度，无专门的寻址方式字段。 访存指令只有 load 和 store 寄存器 MIPS 提供了 32 个寄存器，故一般寄存器编号占 5 bit [图片]\n * a0 - a3：存非浮点数的调用入口参数。A 先存入 a 中再调用 B，若参数 > 4 个，则其余存入栈中。若 A 在 B 返回后也要使用 a，则 A 自己保存。\n * v0 - v1：存从 B 返回的非浮点数的返回值。B 返回前先将返回值存入 v，再返回\n * ra：存返回地址；A 调用 B 时通过 jal 自动将返回地址 PC + 4 存入 ra 寄存器；B 返回 A 时通过 jr ra 将 ra 寄存器中的值存入 PC\n * s0 - s7：称为保存寄存器（被调用者保存），若里面 B 过程中需要使用 s，则在开始段中先将其存入栈，并在返回前恢复，其值回到 A 后仍能被继续使用\n * t0 - t9：称为临时寄存器（调用者保存），若 t 中的值在 B 返回后 A 仍需使用，则 A 自己保存。其值无需由被调用者 B 保存，自由使用即可 [图片]\n\n 1. R 型指令 [图片] R 型指令限定为寄存器之间操作的指令，rs、rt 为两个来源寄存器编号，rd 为目标寄存器编号；op 字段固定为 000 000，具体操作类型由 func 字段指明；shamt 为位移指令的位移字段\n\n * 由于 R 型指令 op 固定为 000 000，所以 I 型 J 型指令一共只有 63 种操作码\n\n 2. I 型指令 [图片] I 型指令是立即数指令，一般分为下面几种\n\n * 双目运算类：rs + 立即数 —> rt\n * load / store：寄存器在左边，内存在右边\n   * load：rt <— M[rs + 立即数]\n   * store：rt —> M[rs + 立即数]\n * 条件转移（相对寻址）：if (rs ? rt) PC <— (PC + imm)\n\n 3. J 型指令 [图片] 常用指令 [图片] [图片]\n\n * 赋值给寄存器：总是给最左边的\n * 和主存交互，左边的是寄存器部分，右边的是主存部分 MIPS 的过程调用 过层调用，又称 函数调用、子程序调用。\n * ra：存返回地址（在 jal 指令中会先 ra = PC + 4 再 jump）\n * fp：存当前函数栈的栈桢（栈底），其指向的存储单元一般保存了返回地址 MIPS 所有寄存器均为 32 位长度，存储单元大小也为 4B，其地址 A，表示的是字节为 (A, A+1, A+2, A+3) 的存储单元，例如：fp 中存了 48，则表示（48，49，50，51）这个存储单元 【过程调用流程】假设函数 A，调用函数 B\n * 寄存器：\n   * 保存寄存器 s0 - s7，如果从被调用过程返回后 A 还要用，被调用者 B 需要保存\n   * 临时寄存器 t0 - t9 ，其值在被调用过程返回后不需要被用。如果需要的话，由调用者 A 提前保存\n   * ra 寄存器，存了当前有用控制权的函数执行完后的返回地址\n   * fp 寄存器，存了当前函数的栈桢（一般保存了被调用者 B 执行完后的返回地址）\n\n 1. A 调用 B 之前，先将 B 需要的参数保存进指定地方（如：a0、a1 寄存器）\n 2. A 执行 jal，包括了保存 ra = PC + 4 以及 控制转移到 B 函数\n 3. 被调用者 B 开始段：\n\n * 计算并分配空间 sp - xxxx\n * 先保存 A 的现场（A 的 ra，A 的 fp 共 8 B）\n * 保存 保存寄存器 s0 - s7（有需要的话）\n * 以 main 函数调用 set_array 函数为例，需要按顺序执行：\n   * 先计算需要分配的空间，并减小 sp，腾出空间\n   * 保存 ra（main 函数中 jal set_array 的下一条指令位置）\n   * 保存 main 的 fp，并设置 fp 寄存器为 set_array 的栈桢（其指向了上面刚保存的 main 的 ra）\n   * 保存 s1，并将要用的局部变量 数组 address 的首地址存入 s1 [图片]\n\n 4. 执行过程 B\n 5. 被调用者 B 将返回结果放到指定位置，例如：寄存器 v0 - v1\n 6. 执行 exit 函数返回 A\n\n * 将栈底的 ra 存入 ra 寄存器\n * 将栈底的 fp 存入 fp\n * 将栈底的 s1 存入 s1\n * 释放分配的空间 sp + xxxx\n * 函数返回：PC <— (ra)",normalizedContent:"指令系统 基础知识 指令一般由 操作码op、寻址特征c、地址码a 组成 根据地址数的个数，一般分为 零、一、二、三地址指令\n\n * isa 规定了：数据类型及格式、指令格式、寻址方式和可访问地址空间大小、i/o 空间的编址方式、中断 结构、机器的工作状态定义和切换、输入输出结构和数据传送方式、存储保护方式等\n   * isa 指的是软件可以感知的部分，称为软件可见部分\n   * 而指令具体在硬件上如何执行的，称为微体系结构、微架构，这是软件不可感知的，例如如何实现加法器\n   * 综上，不同微架构的机器可以使用相同的 isa\n   * \n\n定长操作码指令 操作码为固定位数 n 位，那么可以支持的指令个数只有\n\n\n\n变长操作码指令 指令字长一般固定，有以下几点需要注意：\n\n\n\n 1. 短op 不能是 长op 的前缀\n 2. op 不能重复\n 3. 一般频率较高的指令分配短 op，依次减少译码时间 做题策略：\n\n * 从短 op 开始讨论，短 op 尽可能分配，但要留出 n 种用来扩展\n * 如果是给了四地址，二地址，判断三地址的最多的个数：需要注意三地址码（短op）不能占据二地址码（长op）的，但是反过来可以，所以有可能出现指令操作码不完全分配干净情况。\n * 例1：在一个指令系统中，指令字长为32，一个地址码为6位，指令分为4地址指令、3 地址指令和2地址指令，已知4地址指令有 254条，2地址指令有 4097条，则3地址指令至多有多少条?\n * 法一：四地址留出了 10 和 11 用来扩展，这里2地址 op 有 20 位，高八位先用 1111 1111，后十二位全可以分配，共 4096 个，还有一个可以占据三地址的 10，所以再分配一个 1111 1110 | 1111 1111 1111，而三地址则高八位固定只能是 1111 1110，其还剩 6 位 op，只能是 000 000 ~ 111 110\n * 法二：首先四地址留出了两个来扩展，所以三地址一共只有\n   \n   \n   \n   种，但需要留出一部分给二地址；因为二地址要 4097 个，一共 20 位 op，其专属第三个字段部分可以有\n   \n   \n   \n   种，所以前十二位的部分还得占用至少\n   \n   \n   \n   向上取整为 65 种，故 128 - 65 = 63 个\n * 例2：在一个指令系统中，指令字长为 32，一个地址码为 6 位，指令分为 4 地址指令、3 地址指令和 2地址指令，已知 4地址指令有 254 条，2 地址指令有 4095 条，则 3 地址指令至多有多少条?\n * 法一：四地址留出了 10 和 11 用来扩展，这里2地址 op 有 20 位，高八位先用 1111 1111，后十二位全可以分配，共 4096 个，只需要 4095 个，多出来的一个三地址无法使用。而三地址则高八位固定是 1111 1110，其还剩 6 位 op 任意分配共\n   \n   \n   \n   个\n * 法二：首先四地址留出了两个来扩展，所以三地址一共只有\n   \n   \n   \n   种，但需要留出一部分给二地址；因为二地址要 4095 个，一共 20 位 op，其专属第三个字段部分可以有\n   \n   \n   \n   种，所以前十二位的部分还得占用至少\n   \n   \n   \n   向上取整为 64 种，故 128 - 64 = 64 个 寻址方式 立即寻址\n * 地址码为 立即数\n * 获取操作数访存次数：0 直接寻址\n * 地址码为 有效地址\n * 获取操作数访存次数：1 寄存器寻址\n * 地址码为 寄存器编号\n * 获取操作数访存次数：0，由寄存器给出 间接寻址\n * 地址码为 有效地址的地址（假设一次间接）\n * 获取操作数访存次数：2\n   * 将操作码指向的内存中的数据传到 mar，再进行访存，得到操作数，一共两次 寄存器间接寻址\n * 地址码为 寄存器编号\n * 获取操作数访存次数：1\n   * 从寄存器中获取有效地址，再访存得到操作数，共 1 次 基址寻址\n * 地址码为 偏移量，为补码形式\n * 有效地址 = 偏移地址 + 基址寄存器的值\n * 面向 os：基址寄存器只能由 os（内核态）修改，可以实现动态重定位，有利于多道程序与程序浮动\n * 一般分为有基址寄存器和无基址寄存器，如无，则可以在指令中加上一个寄存器编号 变址寻址\n * 地址码为 基准地址，例如数组首地址，而偏移量由变址寄存器给出\n * 有效地址 = 基准地址 + 变址寄存器的值\n * 面向用户：这里的基准地址可以由用户（用户态）修改，便于实现线性表的遍历\n   * 变址寄存器可以由通用寄存器实现，也可以是专门的变址寄存器，存了偏移量（数组下标） [图片] 相对寻址\n * 地址码为 偏移量，可正可负为补码形式\n * 有效地址 = （pc) + 偏移量\n   * 注意这里的 pc 再取指后可能会加 “1”，具体看题目，且 pc 其指向了指令在内存中的首地址，且 + 1 的单位为一个指令字长\n     * 尤其是根据 jmp 计算相对寻址的偏移量，勿忘此时 pc 已经指向了下一条指令，所以偏移量得多个 2\n   * 例如：指令字长为 4b，1 字为 1 b，则向前跳 16 个指令下，新的地址 addr = pc + 1 * 4 - 16 * 4 = pc + (1 - 16) * 4\n * 常用于转移指令 jmp a\n * 便于实现相对转移以及程序的浮动 指令设计风格 risc vs. cisc\n * 408 中：\n   * 出现：指令流水线、load / store，一定是 risc\n   * 出现：采用微程序控制，一定是 cisc [图片] mips 指令 mips 为 risc 风格的，采用 32 位定长指令字，32 位机器字长，故所有寄存器也为 32 位。操作码字段也是固定的长度，无专门的寻址方式字段。 访存指令只有 load 和 store 寄存器 mips 提供了 32 个寄存器，故一般寄存器编号占 5 bit [图片]\n * a0 - a3：存非浮点数的调用入口参数。a 先存入 a 中再调用 b，若参数 > 4 个，则其余存入栈中。若 a 在 b 返回后也要使用 a，则 a 自己保存。\n * v0 - v1：存从 b 返回的非浮点数的返回值。b 返回前先将返回值存入 v，再返回\n * ra：存返回地址；a 调用 b 时通过 jal 自动将返回地址 pc + 4 存入 ra 寄存器；b 返回 a 时通过 jr ra 将 ra 寄存器中的值存入 pc\n * s0 - s7：称为保存寄存器（被调用者保存），若里面 b 过程中需要使用 s，则在开始段中先将其存入栈，并在返回前恢复，其值回到 a 后仍能被继续使用\n * t0 - t9：称为临时寄存器（调用者保存），若 t 中的值在 b 返回后 a 仍需使用，则 a 自己保存。其值无需由被调用者 b 保存，自由使用即可 [图片]\n\n 1. r 型指令 [图片] r 型指令限定为寄存器之间操作的指令，rs、rt 为两个来源寄存器编号，rd 为目标寄存器编号；op 字段固定为 000 000，具体操作类型由 func 字段指明；shamt 为位移指令的位移字段\n\n * 由于 r 型指令 op 固定为 000 000，所以 i 型 j 型指令一共只有 63 种操作码\n\n 2. i 型指令 [图片] i 型指令是立即数指令，一般分为下面几种\n\n * 双目运算类：rs + 立即数 —> rt\n * load / store：寄存器在左边，内存在右边\n   * load：rt <— m[rs + 立即数]\n   * store：rt —> m[rs + 立即数]\n * 条件转移（相对寻址）：if (rs ? rt) pc <— (pc + imm)\n\n 3. j 型指令 [图片] 常用指令 [图片] [图片]\n\n * 赋值给寄存器：总是给最左边的\n * 和主存交互，左边的是寄存器部分，右边的是主存部分 mips 的过程调用 过层调用，又称 函数调用、子程序调用。\n * ra：存返回地址（在 jal 指令中会先 ra = pc + 4 再 jump）\n * fp：存当前函数栈的栈桢（栈底），其指向的存储单元一般保存了返回地址 mips 所有寄存器均为 32 位长度，存储单元大小也为 4b，其地址 a，表示的是字节为 (a, a+1, a+2, a+3) 的存储单元，例如：fp 中存了 48，则表示（48，49，50，51）这个存储单元 【过程调用流程】假设函数 a，调用函数 b\n * 寄存器：\n   * 保存寄存器 s0 - s7，如果从被调用过程返回后 a 还要用，被调用者 b 需要保存\n   * 临时寄存器 t0 - t9 ，其值在被调用过程返回后不需要被用。如果需要的话，由调用者 a 提前保存\n   * ra 寄存器，存了当前有用控制权的函数执行完后的返回地址\n   * fp 寄存器，存了当前函数的栈桢（一般保存了被调用者 b 执行完后的返回地址）\n\n 1. a 调用 b 之前，先将 b 需要的参数保存进指定地方（如：a0、a1 寄存器）\n 2. a 执行 jal，包括了保存 ra = pc + 4 以及 控制转移到 b 函数\n 3. 被调用者 b 开始段：\n\n * 计算并分配空间 sp - xxxx\n * 先保存 a 的现场（a 的 ra，a 的 fp 共 8 b）\n * 保存 保存寄存器 s0 - s7（有需要的话）\n * 以 main 函数调用 set_array 函数为例，需要按顺序执行：\n   * 先计算需要分配的空间，并减小 sp，腾出空间\n   * 保存 ra（main 函数中 jal set_array 的下一条指令位置）\n   * 保存 main 的 fp，并设置 fp 寄存器为 set_array 的栈桢（其指向了上面刚保存的 main 的 ra）\n   * 保存 s1，并将要用的局部变量 数组 address 的首地址存入 s1 [图片]\n\n 4. 执行过程 b\n 5. 被调用者 b 将返回结果放到指定位置，例如：寄存器 v0 - v1\n 6. 执行 exit 函数返回 a\n\n * 将栈底的 ra 存入 ra 寄存器\n * 将栈底的 fp 存入 fp\n * 将栈底的 s1 存入 s1\n * 释放分配的空间 sp + xxxx\n * 函数返回：pc <— (ra)",charsets:{cjk:!0}},{title:"【OOP】访问控制与继承",frontmatter:{title:"【OOP】访问控制与继承",date:"2022-10-31T18:43:58.000Z",permalink:"/pages/96615a/",tags:["Programming Languages","CPP"]},regularPath:"/05.Programming%20Languages/01.CPP/01.%E3%80%90OOP%E3%80%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF.html",relativePath:"05.Programming Languages/01.CPP/01.【OOP】访问控制与继承.md",key:"v-8cc7ac4e",path:"/pages/96615a/",headers:[{level:2,title:"访问说明符",slug:"访问说明符",normalizedTitle:"访问说明符",charIndex:19},{level:2,title:"protected",slug:"protected",normalizedTitle:"protected",charIndex:87},{level:2,title:"派生列表的访问说明符",slug:"派生列表的访问说明符",normalizedTitle:"派生列表的访问说明符",charIndex:508},{level:4,title:"默认的继承保护级别",slug:"默认的继承保护级别",normalizedTitle:"默认的继承保护级别",charIndex:915},{level:2,title:"改变个别成员的可访问性",slug:"改变个别成员的可访问性",normalizedTitle:"改变个别成员的可访问性",charIndex:1150}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"访问说明符 protected 派生列表的访问说明符 默认的继承保护级别 改变个别成员的可访问性",content:"# 【OOP】访问控制与继承\n\n\n# 访问说明符\n\n每个类控制着其成员的访问权限，其通过访问说明符来实现。\n\n在 C++ 中，有三种访问说明符 public、private、protected。\n\npublic：在一个类中对于用 public 修饰的成员，该类的成员、用户（类的实例对象）、派生类及友元等都可访问。\n\nprivate：在一个类中对于用 private 修饰的成员，仅该类的成员或友元可以访问，\n\nprotected：在一个类中对于用 protected 修饰的成员，该类的成员、派生类及友元都可以访问\n\n简单来说，也就是 public 成员对谁都可以访问，而 private 成员只有类内部的成员和友元可以访问，而 protected 在 private 的基础上给派生类提供了访问权限。\n\n\n# protected\n\nprotected 类似于 public 和 private 的公有产物，被其修饰的成员有以下特点：\n\n * 对类的用户不可见\n * 可以被派生类以及友元访问\n\n但需要注意的是，派生类及其友元只能通过派生类对象来访问这些继承而来的受保护的成员，而不能通过基类对象来访问。\n\n\n# 派生列表的访问说明符\n\n派生类对其继承而来的成员访问权限会受两者影响：\n\n 1. 基类中的访问说明符\n 2. 派生列表的访问说明符。\n\n如果访问直接基类的成员时，派生列表的访问说明符并不会产生影响，此时只受到基类中的访问说明符限制。\n\n但对于继承自该派生类的新类来说则不同。\n\n通俗点来说，我们先令按权限大小对访问说明符排序，public > protected > private，对于 xx 继承（公共继承、受保护继承、私有继承三者之一），我们将继承而来的成员中，由权限大于 xx 的访问说明符修饰的成员变成 xx 访问说明符修饰的成员。\n\n例：\n\nclass Base {\npublic:\n\tint x = 0;\n};\n\nclass Der : protected Base {\n// ......\n};\n\n\n在类 Der 中，其继承自基类 Base 中的公有成员 x，会变成 Der 的受保护成员。\n\n# 默认的继承保护级别\n\n对于 class 和 struct 定义的类，除了其默认访问说明符有区别外，对于默认的继承保护级别也是有区别的。\n\n当我们没有显示的在派生列表中说明访问说明符时，class 默认为私有继承，而 struct 默认为公有继承。\n\nclass Base { };\nstruct D1 : Base { }; // 默认为公有继承\nclass D2 : Base { }; // 默认为私有继承\n\n\nPS：定义派生类时最好显示地表明其继承关系。\n\n\n# 改变个别成员的可访问性\n\n我们可以通过 using 声明语句来改变个别成员(该成员本身需要可以访问)的可访问性。\n\n例如派生类私有继承了某个基类，那么其继承而来的成员会变成该派生类的私有成员，但如果我们对某个继承而来的成员使用 using 声明语句，则该成员的可访问性取决于 using 声明语句之前的访问说明符。\n\n例：\n\nclass Base {\npublic:\n\tint x = 0;\n};\n\nclass Der : private Base {\npublic:\n    using Base::x; // 改变可访问性为 public\n};\n\n\n----------------------------------------\n\n参考书籍：《C++ Primer》",normalizedContent:"# 【oop】访问控制与继承\n\n\n# 访问说明符\n\n每个类控制着其成员的访问权限，其通过访问说明符来实现。\n\n在 c++ 中，有三种访问说明符 public、private、protected。\n\npublic：在一个类中对于用 public 修饰的成员，该类的成员、用户（类的实例对象）、派生类及友元等都可访问。\n\nprivate：在一个类中对于用 private 修饰的成员，仅该类的成员或友元可以访问，\n\nprotected：在一个类中对于用 protected 修饰的成员，该类的成员、派生类及友元都可以访问\n\n简单来说，也就是 public 成员对谁都可以访问，而 private 成员只有类内部的成员和友元可以访问，而 protected 在 private 的基础上给派生类提供了访问权限。\n\n\n# protected\n\nprotected 类似于 public 和 private 的公有产物，被其修饰的成员有以下特点：\n\n * 对类的用户不可见\n * 可以被派生类以及友元访问\n\n但需要注意的是，派生类及其友元只能通过派生类对象来访问这些继承而来的受保护的成员，而不能通过基类对象来访问。\n\n\n# 派生列表的访问说明符\n\n派生类对其继承而来的成员访问权限会受两者影响：\n\n 1. 基类中的访问说明符\n 2. 派生列表的访问说明符。\n\n如果访问直接基类的成员时，派生列表的访问说明符并不会产生影响，此时只受到基类中的访问说明符限制。\n\n但对于继承自该派生类的新类来说则不同。\n\n通俗点来说，我们先令按权限大小对访问说明符排序，public > protected > private，对于 xx 继承（公共继承、受保护继承、私有继承三者之一），我们将继承而来的成员中，由权限大于 xx 的访问说明符修饰的成员变成 xx 访问说明符修饰的成员。\n\n例：\n\nclass base {\npublic:\n\tint x = 0;\n};\n\nclass der : protected base {\n// ......\n};\n\n\n在类 der 中，其继承自基类 base 中的公有成员 x，会变成 der 的受保护成员。\n\n# 默认的继承保护级别\n\n对于 class 和 struct 定义的类，除了其默认访问说明符有区别外，对于默认的继承保护级别也是有区别的。\n\n当我们没有显示的在派生列表中说明访问说明符时，class 默认为私有继承，而 struct 默认为公有继承。\n\nclass base { };\nstruct d1 : base { }; // 默认为公有继承\nclass d2 : base { }; // 默认为私有继承\n\n\nps：定义派生类时最好显示地表明其继承关系。\n\n\n# 改变个别成员的可访问性\n\n我们可以通过 using 声明语句来改变个别成员(该成员本身需要可以访问)的可访问性。\n\n例如派生类私有继承了某个基类，那么其继承而来的成员会变成该派生类的私有成员，但如果我们对某个继承而来的成员使用 using 声明语句，则该成员的可访问性取决于 using 声明语句之前的访问说明符。\n\n例：\n\nclass base {\npublic:\n\tint x = 0;\n};\n\nclass der : private base {\npublic:\n    using base::x; // 改变可访问性为 public\n};\n\n\n----------------------------------------\n\n参考书籍：《c++ primer》",charsets:{cjk:!0}},{title:"右值引用与std::move()",frontmatter:{title:"右值引用与std::move()",date:"2022-11-03T15:09:58.000Z",permalink:"/pages/03d2a3/",tags:["Programming Languages","CPP"]},regularPath:"/05.Programming%20Languages/01.CPP/02.%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8Estd::move().html",relativePath:"05.Programming Languages/01.CPP/02.右值引用与std::move().md",key:"v-bedbdb3a",path:"/pages/03d2a3/",headers:[{level:2,title:"左值与右值",slug:"左值与右值",normalizedTitle:"左值与右值",charIndex:23},{level:2,title:"左值引用",slug:"左值引用",normalizedTitle:"左值引用",charIndex:245},{level:2,title:"右值引用",slug:"右值引用",normalizedTitle:"右值引用",charIndex:2},{level:2,title:"std::move()",slug:"std-move",normalizedTitle:"std::move()",charIndex:7},{level:2,title:"常引用",slug:"常引用",normalizedTitle:"常引用",charIndex:1205},{level:2,title:"右值引用与std::move()",slug:"右值引用与std-move-2",normalizedTitle:"右值引用与std::move()",charIndex:2}],lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:"左值与右值 左值引用 右值引用 std::move() 常引用 右值引用与std::move()",content:'# 右值引用与std::move()\n\n\n# 左值与右值\n\n * 左值可以理解为一个有名字的变量，他能出现在等号的左边，也能出现在等号的右边\n\nint x = 10; // x 是一个左值\nint a = x; // 可以出现在等号右边\n\n\n * 右值是一个没有名字的数值，他只能出现在等号的右边\n\nint x = 10; // 这里 x 是左值，而 10 是右值\n\n\n对于局部变量 x， 他会被保存在栈空间里面，而对于右值，它只会被临时保存，故而存储在寄存器内，很快就被丢弃了。\n\n\n# 左值引用\n\n左值引用是 CPP 里一个比较基础的概念。\n\n我们先定义一个变量 int a = 1;\n\n同时再定义该变量的一个左值引用int &x = a;\n\n那么在这里 x 就可以被理解为 a 的一个别名，当我们修改 x 时，对应的 a 也会发生改变，即 x 与 a 共享同一块地址空间。\n\n\n# 右值引用\n\n区别于左值引用，我们在定义右值引用时会用 &&\n\nint &&x = 10; // x 是一个右值引用\n\n\n右值引用延续了右值 10 的生命周期，我们用 x 将右值的状态保存了下来。\n\n注意\n\n右值引用 x 本身是一个左值，其引用了右值 10。\n\n与左值引用相同，本质上其实都是引用，因此无论是定义一个左值引用，还是一个右值引用，必须赋予其初值，同时还得注意左值引用只能用左值来初始化，右值引用只能用右值初始化。\n\nint &a; // 错误，左值引用需要初始化\nint &&b; // 错误，右值引用需要初始化\nint x = 10; // 定义一个变量 x\nint &c = x; // 正确\nint &d = 10; // 错误，左值引用不能用右值初始化\nint &&e = x; // 错误，右值引用不能用左值初始化\nint &&f = 10; // 正确\n\nint func() { ... } // 一个返回值类型为 int 的函数\nint &&g = func(); // 正确，没有声明名字的 func() 的返回值是一个右值\n\n\n\n# std::move()\n\n对于右值引用的初始化，我们也许会思考，一个右值引用能不能用一个左值来初始化呢？\n\n在这里我们就可以用到移动函数 std::move() 了，我们向其传递一个左值，而它会返回一个右值。\n\nint x = 10; // 定义一个变量\nint &&a = x; // 错误，右值引用不能用左值初始化\nint &&b = std::move(x); // 正确，std::move(x) 返回了一个值与左值 x 相同的右值\n\n\n注意\n\n在调用了 std::move() 后，我们的移后源变量，也就是我们传入的左值会变成未知的状态，我们不能直接使用它，即使再次使用，其值也是未知的，这十分危险。我们可以再对其重新赋值后，再次使用。\n\n\n# 常引用\n\n常引用的定义方式和左值引用很像，就是多了一个 const，但与左值引用不同，我们可以用左值或者右值来初始化常引用。\n\nint x = 10; // 定义一个变量\nconst int &a = x; // 正确\nconst int &b = 10; // 正确\n\n\n常引用的应用场景：\n\n常引用有一个非常有用的地方，我们经常会将常引用作为函数的形参类型，如此一来对于该函数，我们不仅能传递一个左值，同时还能传递一个右值。\n\nvoid print(const int &x) {\n\tstd::cout << x << "\\n";\n}\n// ...\nprint(10); // 正确\nint x = 1;\nprint(x); // 正确\n\n\n\n# 右值引用与std::move()\n\n接下来我们来讲几个具体的应用场景。\n\n1. 常引用与右值引用\n\n作为函数的形参时，常引用不能对值进行修改，但是右值引用可以。\n\nvoid print1(const int &x) {\n    x = 20; // 错误，常量不能修改\n    std::cout << x << "\\n";\n}\n\nvoid print2(int &&x) {\n    x = 20; // 正确\n    std::cout << x << "\\n";\n}\n\n\n以下几点注意事项需要给出：\n\n * 在上面的两个函数中，print2() 中可以修改 x 的值，但 print1() 中则不可以。\n\n * 对于两个同名的重载函数来说，右值引用作为形参的版本优先比常引用版本作为形参的版本更高。\n\n * 对于 print2()，其接受一个右值，如果我们想传递一个左值进去，可以通过 std::move()，即 print2(std::move(x));\n\n2. 移动语义\n\n首先我们要知道几个概念，何为 拷贝 和 移动。而对于进一步的类里的一些概念在这里并不进一步阐述，如拷贝构造函数、移动构造函数、拷贝赋值函数、移动赋值函数、析构函数...\n\n对于如下一个函数，以及其调用过程：\n\nint f(int x) {\n\treturn x;\n}\n...\nint a = 10;\nstd::cout << f(a) << "\\n";\n\n\n我们在给函数 f 传递参数 a 的时候实际上是进行了一次拷贝，我们将 a 的值拷贝给了一个临时的局部变量 x，再进行函数的一系列操作。\n\n那么函数的规模以及其调用次数更大的时候，拷贝所带来的性能上的降低是巨大的。\n\n而这在类里面，当我们定了一个对象，我们想用这个对象去构造一个新的对象，而抛弃这个对象。\n\n非常明显，对于拷贝操作来说，我们会先将旧对象的属性拷贝给新对象的属性，然后将旧对象的属性通过析构函数给销毁，显然这一步非常的冗余以及低效。\n\n于是，我们便有了移动这一思想，我们可以将旧对象的属性移动给新对象，这样就避免的中间拷贝、销毁等一系列操作，大大提高了程序的运行效率。\n\n而移动这一操作便是通过右值引用与std::move()来实现的\n\nclass A {\nprivate:\n    int a = 5;\npublic:\n    A(const A &); // 拷贝构造函数\n    A &operator=(const A &); //拷贝移动函数\n    A(A &&) noexcept; // 移动构造函数\n    A &operator=(A &&) noexcept; //移动赋值函数\n    ~A(); // 析构函数\n};\n\n\n在这里我们定义类A，并为其声明了五个相关函数。\n\n一般情况下，构造A类的对象，或者将一个对象赋值给另一个对象，如果用移动控制函数会大大提高效率。\n\n另外我们通过在移动控制函数的最后加上了 noexcept，这是为了告诉编译器，我们的移动控制函数不会产生异常，需要优先使用移动控制函数。因为移动控制函数会改变移动源元素，如果移动过程中产生了异常，那么新对象和旧对象我们都无法正确使用了，而拷贝控制函数则不会有这烦恼，故编译器一般为了安全考虑，会优先使用拷贝控制函数。',normalizedContent:'# 右值引用与std::move()\n\n\n# 左值与右值\n\n * 左值可以理解为一个有名字的变量，他能出现在等号的左边，也能出现在等号的右边\n\nint x = 10; // x 是一个左值\nint a = x; // 可以出现在等号右边\n\n\n * 右值是一个没有名字的数值，他只能出现在等号的右边\n\nint x = 10; // 这里 x 是左值，而 10 是右值\n\n\n对于局部变量 x， 他会被保存在栈空间里面，而对于右值，它只会被临时保存，故而存储在寄存器内，很快就被丢弃了。\n\n\n# 左值引用\n\n左值引用是 cpp 里一个比较基础的概念。\n\n我们先定义一个变量 int a = 1;\n\n同时再定义该变量的一个左值引用int &x = a;\n\n那么在这里 x 就可以被理解为 a 的一个别名，当我们修改 x 时，对应的 a 也会发生改变，即 x 与 a 共享同一块地址空间。\n\n\n# 右值引用\n\n区别于左值引用，我们在定义右值引用时会用 &&\n\nint &&x = 10; // x 是一个右值引用\n\n\n右值引用延续了右值 10 的生命周期，我们用 x 将右值的状态保存了下来。\n\n注意\n\n右值引用 x 本身是一个左值，其引用了右值 10。\n\n与左值引用相同，本质上其实都是引用，因此无论是定义一个左值引用，还是一个右值引用，必须赋予其初值，同时还得注意左值引用只能用左值来初始化，右值引用只能用右值初始化。\n\nint &a; // 错误，左值引用需要初始化\nint &&b; // 错误，右值引用需要初始化\nint x = 10; // 定义一个变量 x\nint &c = x; // 正确\nint &d = 10; // 错误，左值引用不能用右值初始化\nint &&e = x; // 错误，右值引用不能用左值初始化\nint &&f = 10; // 正确\n\nint func() { ... } // 一个返回值类型为 int 的函数\nint &&g = func(); // 正确，没有声明名字的 func() 的返回值是一个右值\n\n\n\n# std::move()\n\n对于右值引用的初始化，我们也许会思考，一个右值引用能不能用一个左值来初始化呢？\n\n在这里我们就可以用到移动函数 std::move() 了，我们向其传递一个左值，而它会返回一个右值。\n\nint x = 10; // 定义一个变量\nint &&a = x; // 错误，右值引用不能用左值初始化\nint &&b = std::move(x); // 正确，std::move(x) 返回了一个值与左值 x 相同的右值\n\n\n注意\n\n在调用了 std::move() 后，我们的移后源变量，也就是我们传入的左值会变成未知的状态，我们不能直接使用它，即使再次使用，其值也是未知的，这十分危险。我们可以再对其重新赋值后，再次使用。\n\n\n# 常引用\n\n常引用的定义方式和左值引用很像，就是多了一个 const，但与左值引用不同，我们可以用左值或者右值来初始化常引用。\n\nint x = 10; // 定义一个变量\nconst int &a = x; // 正确\nconst int &b = 10; // 正确\n\n\n常引用的应用场景：\n\n常引用有一个非常有用的地方，我们经常会将常引用作为函数的形参类型，如此一来对于该函数，我们不仅能传递一个左值，同时还能传递一个右值。\n\nvoid print(const int &x) {\n\tstd::cout << x << "\\n";\n}\n// ...\nprint(10); // 正确\nint x = 1;\nprint(x); // 正确\n\n\n\n# 右值引用与std::move()\n\n接下来我们来讲几个具体的应用场景。\n\n1. 常引用与右值引用\n\n作为函数的形参时，常引用不能对值进行修改，但是右值引用可以。\n\nvoid print1(const int &x) {\n    x = 20; // 错误，常量不能修改\n    std::cout << x << "\\n";\n}\n\nvoid print2(int &&x) {\n    x = 20; // 正确\n    std::cout << x << "\\n";\n}\n\n\n以下几点注意事项需要给出：\n\n * 在上面的两个函数中，print2() 中可以修改 x 的值，但 print1() 中则不可以。\n\n * 对于两个同名的重载函数来说，右值引用作为形参的版本优先比常引用版本作为形参的版本更高。\n\n * 对于 print2()，其接受一个右值，如果我们想传递一个左值进去，可以通过 std::move()，即 print2(std::move(x));\n\n2. 移动语义\n\n首先我们要知道几个概念，何为 拷贝 和 移动。而对于进一步的类里的一些概念在这里并不进一步阐述，如拷贝构造函数、移动构造函数、拷贝赋值函数、移动赋值函数、析构函数...\n\n对于如下一个函数，以及其调用过程：\n\nint f(int x) {\n\treturn x;\n}\n...\nint a = 10;\nstd::cout << f(a) << "\\n";\n\n\n我们在给函数 f 传递参数 a 的时候实际上是进行了一次拷贝，我们将 a 的值拷贝给了一个临时的局部变量 x，再进行函数的一系列操作。\n\n那么函数的规模以及其调用次数更大的时候，拷贝所带来的性能上的降低是巨大的。\n\n而这在类里面，当我们定了一个对象，我们想用这个对象去构造一个新的对象，而抛弃这个对象。\n\n非常明显，对于拷贝操作来说，我们会先将旧对象的属性拷贝给新对象的属性，然后将旧对象的属性通过析构函数给销毁，显然这一步非常的冗余以及低效。\n\n于是，我们便有了移动这一思想，我们可以将旧对象的属性移动给新对象，这样就避免的中间拷贝、销毁等一系列操作，大大提高了程序的运行效率。\n\n而移动这一操作便是通过右值引用与std::move()来实现的\n\nclass a {\nprivate:\n    int a = 5;\npublic:\n    a(const a &); // 拷贝构造函数\n    a &operator=(const a &); //拷贝移动函数\n    a(a &&) noexcept; // 移动构造函数\n    a &operator=(a &&) noexcept; //移动赋值函数\n    ~a(); // 析构函数\n};\n\n\n在这里我们定义类a，并为其声明了五个相关函数。\n\n一般情况下，构造a类的对象，或者将一个对象赋值给另一个对象，如果用移动控制函数会大大提高效率。\n\n另外我们通过在移动控制函数的最后加上了 noexcept，这是为了告诉编译器，我们的移动控制函数不会产生异常，需要优先使用移动控制函数。因为移动控制函数会改变移动源元素，如果移动过程中产生了异常，那么新对象和旧对象我们都无法正确使用了，而拷贝控制函数则不会有这烦恼，故编译器一般为了安全考虑，会优先使用拷贝控制函数。',charsets:{cjk:!0}},{title:"Go 语言中的 GC 问题整理",frontmatter:{title:"Go 语言中的 GC 问题整理",date:"2023-09-06T15:32:50.000Z",permalink:"/pages/f2991f/",tags:["Programming Languages","Golang"]},regularPath:"/05.Programming%20Languages/02.Golang/01.%20Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20GC%20%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html",relativePath:"05.Programming Languages/02.Golang/01. Go 语言中的 GC 问题整理.md",key:"v-5a61da48",path:"/pages/f2991f/",headers:[{level:3,title:"GC",slug:"gc",normalizedTitle:"gc",charIndex:2},{level:3,title:"Go 语言的 GC 的简单描述",slug:"go-语言的-gc-的简单描述",normalizedTitle:"go 语言的 gc 的简单描述",charIndex:1639}],lastUpdated:"9/6/2023, 3:40:10 PM",lastUpdatedTimestamp:169398601e4,headersStr:"GC Go 语言的 GC 的简单描述",content:"# GC\n\n * GC 清理堆数据，分为手动垃圾回收 和 自动垃圾回收\n\n * 理论基础：可达性 等价于 存活性\n\n * 追踪式垃圾回收\n   \n   * 三色标记–清扫算法 -> 内存碎片化 -> 三色标记-整理算法(标记完后移动非垃圾数据，使内存更紧凑)\n   \n   * 复制式回收算法：将堆内存分为 To 区域和 From 区域，GC 时扫描 From，把有效数据复制到 To 中，最后交换 From 区域和 To 区域\n     \n     * 堆内存里利用率低，一般搭配其他垃圾回收算法使用\n   \n   * 分代回收：基于弱分代假说：大部分对象都在年轻时死亡\n     \n     * 将经受住特定次数的对象成为老年代对象，其余为新生代对象，新生代对象成为垃圾的概率高于老年代对象\n     \n     * 可以降低对老年代对象进行垃圾回收的概率，或者对不同对象采取不同垃圾回收算法，例如 复制时回收算法\n\n * 引用计数垃圾回收\n   \n   * 为每个对象维护一个引用计数，当引用计数为 0 时回收该数据，类似 C++ 中的智能指针\n     \n     * 高频率更新计数会带来不小的开销\n     \n     * 循环引用问题，C++ weak_ptr 解决（其不控制对象生命周期，不增加引用计数）\n\n * 用户进程暂停去专注进行垃圾回收，称为 STW（Stop The World）\n   \n   * 用户进程与 GC 交替执行，称为增量式垃圾回收；但交替执行中用进程可能会修改某些对象，导致 gc 的误判\n\n * 三色抽象中，黑色对象表示已经处理完，灰色对象还会被继续处理，当全是黑色数据后剩余的白色对象就是垃圾。\n   \n   * 对于误判垃圾的情况：黑色对象到白色对象有引用，但没有灰色对象到白色对象的引用，白色对象会被误判为垃圾\n     \n     * 强三色不变式：没有从黑色对象直接到白色对象的引用。确保了一旦对象变为黑色，则一定可达，且其引用的所有对象也可达\n     \n     * 弱三色不变式：允许黑色对象直接到白色对象的引用，但要保证可以通过灰色对象到达白色对象\n   \n   * 通过建立 “读 / 写屏障” 实现 强弱三色不变式\n     \n     * 写屏障会在写操作中插入指令，目的是把数据对象的修改通知到垃圾回收器，所以通常会有个记录集\n       \n       * 强三色不变式中称为插入写屏障：当一个黑色对象被修改引用到一个白色对象，则将白色对象修改为灰色，或者把黑色对象退为灰色\n       \n       * 弱三色不变式中称为删除写屏障：当删除灰色对象到白色对象的引用时，将白色对象修改为灰色\n     \n     * 读屏障，非移动式垃圾回收器天然不需要读屏障；类似复制式回收器的移动式垃圾回收期则需要读屏障来保证安全\n       \n       * 确保用户程序不会访问到已经存在副本的陈旧对象\n         \n         * eg.在复制式回收器中，第一段 STW 中，A 从 From 被拷贝到了 To；接着交替执行的用户程序中，B 引用了 A；第二段 STW 中，B 被拷贝到了 To，此时 To 中的 B 还持有着 From 中 A 的陈旧对象。当 From 被清楚后，再通过 B 访问 A 就会出现错误。\n\n * 多核场景下，分为并行垃圾回收（只有垃圾回收程序执行）和 并发垃圾回收（垃圾回收程序会和用户程序并发执行）\n   \n   * 并行垃圾回收会有分工不均引发的负载均衡问题、同步问题、重复处理数据问题（From 到 To 的重复复制）\n   \n   * 并发垃圾回收会有锁竞争的问题，比如用户程序和垃圾回收程序会竞争写屏障的记录集。同时因为有多个线程，为了避免同步开启写屏障的延迟，所以一般采用主体并发垃圾回收，在此基础上支持增量式，便是主体并发增量式回收。\n\n\n# Go 语言的 GC 的简单描述\n\n * Go 语言的 GC 采用 标记-清扫算法，支持主体并发增量式回收，使用插入和删除两种写屏障结合的混合写屏障\n\n * 标记准备阶段（Mark Setup）\n   \n   1. STW 暂停程序执行\n   \n   2. 启动标记工作协程\n   \n   3. 启动写屏障\n   \n   4. 找到 roots 放到标记队列中\n   \n   5. 取消程序暂停\n\n * 标记阶段（Marking) 和用户进程并发执行\n   \n   1. 从标记队列中取出对象，标记为黑色\n   \n   2. 追踪对象，将后面的对象放进标记队列中，标记为灰色\n   \n   3. 重复 1、2，知道队列为空\n   \n   4. 扫描过程中，如果用户进程创建或者修改了对象会触发写屏障，将对象放入单独的 marking 队列，标记为灰色\n\n * 标记终止阶段（Mark Termination）\n   \n   1. STW 暂停程序执行\n   \n   2. rescan：将 Marking 阶段中触发写屏障产生的队列中对象取出，标记为黑色，并检测是否有指向另一个对象；若有则放入标记队列\n   \n   3. 关闭写屏障\n   \n   4. 取消程序暂停\n\n * 清理阶段（Sweeping）\n   \n   1. 清除所有被标记为白色的对象，内存管理结构中有个 bitmap 区域可以进行标记是否为黑色\n\n * GC 触发时机\n   \n   1. 主动触发：调用 runtime.GC() 方法\n   \n   2. 被动触发：\n      \n      * 定时触发：由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过 2 分钟没有 gc，则触发 gc\n      \n      * 根据内存分配阈值触发：由环境变量 GOGC 控制，默认为 100。如果当前堆内存是上次 GC 结束后占用内存的 2 倍时，则触发 gc",normalizedContent:"# gc\n\n * gc 清理堆数据，分为手动垃圾回收 和 自动垃圾回收\n\n * 理论基础：可达性 等价于 存活性\n\n * 追踪式垃圾回收\n   \n   * 三色标记–清扫算法 -> 内存碎片化 -> 三色标记-整理算法(标记完后移动非垃圾数据，使内存更紧凑)\n   \n   * 复制式回收算法：将堆内存分为 to 区域和 from 区域，gc 时扫描 from，把有效数据复制到 to 中，最后交换 from 区域和 to 区域\n     \n     * 堆内存里利用率低，一般搭配其他垃圾回收算法使用\n   \n   * 分代回收：基于弱分代假说：大部分对象都在年轻时死亡\n     \n     * 将经受住特定次数的对象成为老年代对象，其余为新生代对象，新生代对象成为垃圾的概率高于老年代对象\n     \n     * 可以降低对老年代对象进行垃圾回收的概率，或者对不同对象采取不同垃圾回收算法，例如 复制时回收算法\n\n * 引用计数垃圾回收\n   \n   * 为每个对象维护一个引用计数，当引用计数为 0 时回收该数据，类似 c++ 中的智能指针\n     \n     * 高频率更新计数会带来不小的开销\n     \n     * 循环引用问题，c++ weak_ptr 解决（其不控制对象生命周期，不增加引用计数）\n\n * 用户进程暂停去专注进行垃圾回收，称为 stw（stop the world）\n   \n   * 用户进程与 gc 交替执行，称为增量式垃圾回收；但交替执行中用进程可能会修改某些对象，导致 gc 的误判\n\n * 三色抽象中，黑色对象表示已经处理完，灰色对象还会被继续处理，当全是黑色数据后剩余的白色对象就是垃圾。\n   \n   * 对于误判垃圾的情况：黑色对象到白色对象有引用，但没有灰色对象到白色对象的引用，白色对象会被误判为垃圾\n     \n     * 强三色不变式：没有从黑色对象直接到白色对象的引用。确保了一旦对象变为黑色，则一定可达，且其引用的所有对象也可达\n     \n     * 弱三色不变式：允许黑色对象直接到白色对象的引用，但要保证可以通过灰色对象到达白色对象\n   \n   * 通过建立 “读 / 写屏障” 实现 强弱三色不变式\n     \n     * 写屏障会在写操作中插入指令，目的是把数据对象的修改通知到垃圾回收器，所以通常会有个记录集\n       \n       * 强三色不变式中称为插入写屏障：当一个黑色对象被修改引用到一个白色对象，则将白色对象修改为灰色，或者把黑色对象退为灰色\n       \n       * 弱三色不变式中称为删除写屏障：当删除灰色对象到白色对象的引用时，将白色对象修改为灰色\n     \n     * 读屏障，非移动式垃圾回收器天然不需要读屏障；类似复制式回收器的移动式垃圾回收期则需要读屏障来保证安全\n       \n       * 确保用户程序不会访问到已经存在副本的陈旧对象\n         \n         * eg.在复制式回收器中，第一段 stw 中，a 从 from 被拷贝到了 to；接着交替执行的用户程序中，b 引用了 a；第二段 stw 中，b 被拷贝到了 to，此时 to 中的 b 还持有着 from 中 a 的陈旧对象。当 from 被清楚后，再通过 b 访问 a 就会出现错误。\n\n * 多核场景下，分为并行垃圾回收（只有垃圾回收程序执行）和 并发垃圾回收（垃圾回收程序会和用户程序并发执行）\n   \n   * 并行垃圾回收会有分工不均引发的负载均衡问题、同步问题、重复处理数据问题（from 到 to 的重复复制）\n   \n   * 并发垃圾回收会有锁竞争的问题，比如用户程序和垃圾回收程序会竞争写屏障的记录集。同时因为有多个线程，为了避免同步开启写屏障的延迟，所以一般采用主体并发垃圾回收，在此基础上支持增量式，便是主体并发增量式回收。\n\n\n# go 语言的 gc 的简单描述\n\n * go 语言的 gc 采用 标记-清扫算法，支持主体并发增量式回收，使用插入和删除两种写屏障结合的混合写屏障\n\n * 标记准备阶段（mark setup）\n   \n   1. stw 暂停程序执行\n   \n   2. 启动标记工作协程\n   \n   3. 启动写屏障\n   \n   4. 找到 roots 放到标记队列中\n   \n   5. 取消程序暂停\n\n * 标记阶段（marking) 和用户进程并发执行\n   \n   1. 从标记队列中取出对象，标记为黑色\n   \n   2. 追踪对象，将后面的对象放进标记队列中，标记为灰色\n   \n   3. 重复 1、2，知道队列为空\n   \n   4. 扫描过程中，如果用户进程创建或者修改了对象会触发写屏障，将对象放入单独的 marking 队列，标记为灰色\n\n * 标记终止阶段（mark termination）\n   \n   1. stw 暂停程序执行\n   \n   2. rescan：将 marking 阶段中触发写屏障产生的队列中对象取出，标记为黑色，并检测是否有指向另一个对象；若有则放入标记队列\n   \n   3. 关闭写屏障\n   \n   4. 取消程序暂停\n\n * 清理阶段（sweeping）\n   \n   1. 清除所有被标记为白色的对象，内存管理结构中有个 bitmap 区域可以进行标记是否为黑色\n\n * gc 触发时机\n   \n   1. 主动触发：调用 runtime.gc() 方法\n   \n   2. 被动触发：\n      \n      * 定时触发：由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过 2 分钟没有 gc，则触发 gc\n      \n      * 根据内存分配阈值触发：由环境变量 gogc 控制，默认为 100。如果当前堆内存是上次 gc 结束后占用内存的 2 倍时，则触发 gc",charsets:{cjk:!0}},{title:"Go 语言中的 Channel 相关问题整理",frontmatter:{title:"Go 语言中的 Channel 相关问题整理",date:"2023-09-06T16:41:48.000Z",permalink:"/pages/843296/",tags:["Programming Languages","Golang"]},regularPath:"/05.Programming%20Languages/02.Golang/02.%20Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20channel%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html",relativePath:"05.Programming Languages/02.Golang/02. Go 语言中的 channel 相关问题整理.md",key:"v-20c29ae8",path:"/pages/843296/",headers:[{level:3,title:"Channel",slug:"channel",normalizedTitle:"channel",charIndex:2}],lastUpdated:"9/6/2023, 4:49:24 PM",lastUpdatedTimestamp:1693990164e3,headersStr:"Channel",content:"# Channel\n\n * Go 语言中，不通过共享内存实现通信，而通过通信来实现共享内存\n\n * Go 语言的 CSP（通信顺序进程）并发模型，是通过 goroutine 和 channel 实现的\n\n * channel 遵守 FIFO 原则，分为有缓冲区和无缓冲区\n\n * 假设 ch 是函数栈上的一个指针，其指向堆中的 hchan 数据结构\n   \n   * hchan 支持多个协程的并发访问，所以包含一把互斥锁\n   * 包含缓冲区指针（缓冲区是一个数组）\n   * 包含已经存储了多少数据\n   * 包含最多能存储多少数据\n   * 包含每个元素占多大空间\n   * 因为内存复制、gc 等机制依赖于数据类型，所以包含一个指针指向元素类型的类型元数据\n   * 包含发送、接受队列和发送、接收下标\n   * 包含关闭状态\n   \n   type hchan struct {\n       qcount   uint           // 已经存储的元素数量\n       dataqsiz uint           // 最多存储的元素数量\n       buf      unsafe.Pointer // 缓冲区（循环数组）指针\n       elemsize uint16         // 每个元素的大小\n   \n       closed   uint32  \t    // 关闭标志\n       elemtype *_type         // 元素类型的类型元数据指针\n   \n       sendx    uint           // 下一次发送数据的下标\n       recvx    uint           // 下一次读取数据的下标\n   \n       recvq    waitq  \t\t// 接受队列\n       sendq    waitq  \t\t// 发送队列\n   \n       lock mutex \t\t\t\t// 互斥锁，支持多协程访问\n   }\n   \n\n * 缓冲区是一个环形缓冲区 Ring Buffer\n\n * 发送数据时，\n   \n   * 不发生阻塞的情况：缓冲区非空且有空闲区域、缓冲区为空且有协程等待接收数据\n   * 会发生阻塞的情况：channel 为 nil、缓冲区为空且没有协程等待接收数据、缓冲区满了且没有协程等待接收数据\n   * 可以使用 select + default 的非阻塞式写法\n   \n   select {\n   case ch<- 10:\n   // ...\n   default:\n   // ...\n   }\n   \n\n * 接收数据时，\n   \n   * 不发生阻塞的情况：缓冲区非空有数据、缓冲区为空且有协程等待发送数据\n   * 会发生阻塞的情况：channel 为 nil、缓冲区为空且没有协程等待发送数据、有缓冲区但没有数据且没有协程等待发送数据\n   * 也可以使用 select + default 的非阻塞写法\n\n * 多路 select 中，每个 case 可以是一个 channel 的发送 或 接受操作，其中 default 可选\n\nselect {\ncase a = <-ch1:\n// ...\ncase ch2 <- b\n}\n\n\n * 用 channel 共享内存可以解耦生产者和消费者，但容易引发阻塞甚至死锁",normalizedContent:"# channel\n\n * go 语言中，不通过共享内存实现通信，而通过通信来实现共享内存\n\n * go 语言的 csp（通信顺序进程）并发模型，是通过 goroutine 和 channel 实现的\n\n * channel 遵守 fifo 原则，分为有缓冲区和无缓冲区\n\n * 假设 ch 是函数栈上的一个指针，其指向堆中的 hchan 数据结构\n   \n   * hchan 支持多个协程的并发访问，所以包含一把互斥锁\n   * 包含缓冲区指针（缓冲区是一个数组）\n   * 包含已经存储了多少数据\n   * 包含最多能存储多少数据\n   * 包含每个元素占多大空间\n   * 因为内存复制、gc 等机制依赖于数据类型，所以包含一个指针指向元素类型的类型元数据\n   * 包含发送、接受队列和发送、接收下标\n   * 包含关闭状态\n   \n   type hchan struct {\n       qcount   uint           // 已经存储的元素数量\n       dataqsiz uint           // 最多存储的元素数量\n       buf      unsafe.pointer // 缓冲区（循环数组）指针\n       elemsize uint16         // 每个元素的大小\n   \n       closed   uint32  \t    // 关闭标志\n       elemtype *_type         // 元素类型的类型元数据指针\n   \n       sendx    uint           // 下一次发送数据的下标\n       recvx    uint           // 下一次读取数据的下标\n   \n       recvq    waitq  \t\t// 接受队列\n       sendq    waitq  \t\t// 发送队列\n   \n       lock mutex \t\t\t\t// 互斥锁，支持多协程访问\n   }\n   \n\n * 缓冲区是一个环形缓冲区 ring buffer\n\n * 发送数据时，\n   \n   * 不发生阻塞的情况：缓冲区非空且有空闲区域、缓冲区为空且有协程等待接收数据\n   * 会发生阻塞的情况：channel 为 nil、缓冲区为空且没有协程等待接收数据、缓冲区满了且没有协程等待接收数据\n   * 可以使用 select + default 的非阻塞式写法\n   \n   select {\n   case ch<- 10:\n   // ...\n   default:\n   // ...\n   }\n   \n\n * 接收数据时，\n   \n   * 不发生阻塞的情况：缓冲区非空有数据、缓冲区为空且有协程等待发送数据\n   * 会发生阻塞的情况：channel 为 nil、缓冲区为空且没有协程等待发送数据、有缓冲区但没有数据且没有协程等待发送数据\n   * 也可以使用 select + default 的非阻塞写法\n\n * 多路 select 中，每个 case 可以是一个 channel 的发送 或 接受操作，其中 default 可选\n\nselect {\ncase a = <-ch1:\n// ...\ncase ch2 <- b\n}\n\n\n * 用 channel 共享内存可以解耦生产者和消费者，但容易引发阻塞甚至死锁",charsets:{cjk:!0}},{title:"一些最近",frontmatter:{title:"一些最近",date:"2022-11-03T19:46:50.000Z",permalink:"/pages/018443/",tags:["Casual Records"]},regularPath:"/x04.Casual%20Records/01.%E4%B8%80%E4%BA%9B%E6%9C%80%E8%BF%91.html",relativePath:"x04.Casual Records/01.一些最近.md",key:"v-62d053a2",path:"/pages/018443/",headers:[{level:4,title:"关于未来方向",slug:"关于未来方向",normalizedTitle:"关于未来方向",charIndex:89},{level:4,title:"关于对国内CS教育的反思",slug:"关于对国内cs教育的反思",normalizedTitle:"关于对国内cs教育的反思",charIndex:267},{level:4,title:"关于学校氛围",slug:"关于学校氛围",normalizedTitle:"关于学校氛围",charIndex:543},{level:4,title:"关于学习进度",slug:"关于学习进度",normalizedTitle:"关于学习进度",charIndex:809},{level:4,title:"关于情感",slug:"关于情感",normalizedTitle:"关于情感",charIndex:1909},{level:4,title:"关于一些新的想法",slug:"关于一些新的想法",normalizedTitle:"关于一些新的想法",charIndex:2109}],lastUpdated:"11/12/2024, 10:24:10 PM",lastUpdatedTimestamp:173142145e4,headersStr:"关于未来方向 关于对国内CS教育的反思 关于学校氛围 关于学习进度 关于情感 关于一些新的想法",content:"今天是 2022.11.3，在图书馆，头有点小晕。今天又是摆烂的一天，番茄中的学习时长有点低(不过没记上一些学校的浪费时间但又不得不听的课)，想着稍微理一些目前的思绪吧。\n\n# 关于未来方向\n\n就目前吧对未来的想法主要就是 好好学习几门基础课，然后到了大三下开始考研。在升上大二的那段时间，也算是确定了未来想考研的想法，实在太想去 top2 了55555。至于未来研究方向，目前是对 system 还是比较感兴趣的，不过未来空下来还想去尝试了解更多，比如图形学、编译器、数据库内核开发等吧，不过也得基于基础扎实的前提就是了。。\n\n# 关于对国内CS教育的反思\n\n真的不得不说，美丽国在 CS教育上领先我们实在是太多了，每门课都有着精美的课程设计和各种 labs project 的大作业，幸亏这是一个开源的 CS 世界，在一所小小双非学校也能汲取全世界前辈们的精华，真的非常感谢前辈们。另外国内如 南大jyy老师等一批老师也开发了非常优质的课程。我也热切地希望，在未来，国内的同学们能在一个课堂下，热烈地讨论着每一节课，一起探索计算机的世界，做着自己学校自己老师所设计的实验与项目，真的好希望有那一天！同时我自己个人也非常希望能在未来某一天能做些什么，能发一点光，出一份力...\n\n# 关于学校氛围\n\n学校氛围其实非常非常卷，但其实我一直不是很理解同学们的卷是为了什么emm。不过毕竟人各有志，我也尊重每个人的想法，只是有时候也感觉自己挺孤独的，有时候真的很难找到一个同样热爱计算机科学的人一起去交流探讨各种学术，或是一起共同进步 QAQ，总觉得自己与大环境格格不入，偶尔也会自闭，然后怀疑自己。其实刚上来的时候自己也想卷的，也想保研，不过一个是精力实在不够，一个是保不上梦校，所以后来就放弃卷绩点了（摆！）反正走一步看一步吧，也算有自己的一些规划，也明确未来的方向，或许很难融入大家，但自己确实学的挺开心的！\n\n# 关于学习进度\n\n最近在进行三件套的学习中，不是前端，是 《C++ Primer》、CMU15-445 以及 南大PA实验。\n\n不得不说 《C++ Primer》这本书是真的... 不适合学习 C++，至少我个人感觉是这样的，太全面的，感觉更适合当一本字典工具书，不过既然看都看了，那还是坚持看完吧，看了大概600来页吧，其实在看的这一章模板看完基本上就把主体内容看完了，后面就是一些高级主题和各种库了。\n\n然后是CMU15-445，其实本来是想大二下，或者大三再看的，不过因为学校数据库讲的实在是太慢而且太浅了（不过老师很用心），所以不得不提上进程，不过因为 Project1 需要扎实的 CPP 基础，所以还没继续看，不过到今天为止的话基础已经差不多打完了。Andy 老师的课也还是非常 interestring 的，每节课还有专门的 BGM、DJ 什么的，不过 Homework1 让写的一些 SQL 查询还挺难的...尤其是最后的递归CTE。\n\n最后是南大的PA，其实在暑假的时候我就又尝试在做了，不过当时犯了一个非常非常蠢的错误。。。导致环境很久很久都没搭建起来，就放弃了。不过最近再次尝试的时候发现了这个问题并解决了，于是乎又开始了这个实验，不得不说 PA 的实验手册真的写的非常非常好 55555，真的非常感谢jyy老师，余博士等前辈对课程建设的用心啊。不过就是说，PA 好难 QAQ\n\n现在吧，自己大概学的东西也挺杂的，从最开始的高中算法竞赛，现在每天也保持着至少一道的力扣每日一题保持手感，算是算法能力应该是过关了的；然后程序语言的话 CPP、JavaSE、Python、还有前端三件套balabala的也都会一点，不过都不是非常非常精，接下来打算就主力 CPP 了吧。关于这一点，其实真的挺喜欢 CPP 的，虽然确实难，但是对它总有一种莫名的情感，毕竟是自己接触编程第一门语言，语言里的初恋了属于是）；AI方面的话也算是学了不少，吴恩达老师机器学习、深度学习也都看完了，也自己实现了点小东西，不过后面对数学的要求有点高，加上自己在 AI 里感受不太到编程的乐趣，所以以后也不打算走了；前端的话么，不谈了，学过前端三件套加一些框架后感觉倒不是很好玩；至于计算机基础学科的话，CSAPP是看完了，不过 labs 还没全做完，打算 PA 后补上，基本上除去没啥问题的数据结构，剩下三大件的话其实都入了个门把。计网的话粗略过了一遍湖科大高老师的课（虽然全忘了），计组的话 CSAPP里学了些，然后 OS 的话 CSAPP 还有 jyy 老师的课也看了一半，总体上算是过了入门阶段了。\n\n# 关于情感\n\n这两天在看复旦的虎子哥的博客的时候，看到他给npy定了学习计划，还陪对方一起学习了jyy老师的操作系统，看完后自己真的只有羡慕QAQ，真的好期待这种一起学习一起进步的生活。其实我觉得自己一直是一个精神独立、生活充沛的人。每天还算自律，坚持锻炼、学习，偶尔打打游戏也不上头，一直保持着提升自己，性格也算主动，不过感觉理想中的这东西还是急不了，慢慢来吧~（先让我把 PA 做了555）\n\n# 关于一些新的想法\n\n最近有时候觉得自己见得世面还是太少了，这段时间又在多看看一些实习的东西，想提早去看看工业界的一些真实场景吧emmm 不知道寒假有没有机会能拿到个后端的开发岗，不过感觉得先把计网的深入学习提上日程了。。。（好忙啊 = ^ =)\n\n----------------------------------------\n\n都瞎写的，最近有点小e，脑子里心里各种都挺乱的，可能是接连两本800来页的书看的人有点心态崩吧，快自我怀疑了 QAQ\n\n另外，真的好想去 pku 555555 至少当下就是这样（不知道未来会不会变心）\n\n嗯。。理了一下最近的思路，小小暂停歇了一下。 之后要继续努力了！",normalizedContent:"今天是 2022.11.3，在图书馆，头有点小晕。今天又是摆烂的一天，番茄中的学习时长有点低(不过没记上一些学校的浪费时间但又不得不听的课)，想着稍微理一些目前的思绪吧。\n\n# 关于未来方向\n\n就目前吧对未来的想法主要就是 好好学习几门基础课，然后到了大三下开始考研。在升上大二的那段时间，也算是确定了未来想考研的想法，实在太想去 top2 了55555。至于未来研究方向，目前是对 system 还是比较感兴趣的，不过未来空下来还想去尝试了解更多，比如图形学、编译器、数据库内核开发等吧，不过也得基于基础扎实的前提就是了。。\n\n# 关于对国内cs教育的反思\n\n真的不得不说，美丽国在 cs教育上领先我们实在是太多了，每门课都有着精美的课程设计和各种 labs project 的大作业，幸亏这是一个开源的 cs 世界，在一所小小双非学校也能汲取全世界前辈们的精华，真的非常感谢前辈们。另外国内如 南大jyy老师等一批老师也开发了非常优质的课程。我也热切地希望，在未来，国内的同学们能在一个课堂下，热烈地讨论着每一节课，一起探索计算机的世界，做着自己学校自己老师所设计的实验与项目，真的好希望有那一天！同时我自己个人也非常希望能在未来某一天能做些什么，能发一点光，出一份力...\n\n# 关于学校氛围\n\n学校氛围其实非常非常卷，但其实我一直不是很理解同学们的卷是为了什么emm。不过毕竟人各有志，我也尊重每个人的想法，只是有时候也感觉自己挺孤独的，有时候真的很难找到一个同样热爱计算机科学的人一起去交流探讨各种学术，或是一起共同进步 qaq，总觉得自己与大环境格格不入，偶尔也会自闭，然后怀疑自己。其实刚上来的时候自己也想卷的，也想保研，不过一个是精力实在不够，一个是保不上梦校，所以后来就放弃卷绩点了（摆！）反正走一步看一步吧，也算有自己的一些规划，也明确未来的方向，或许很难融入大家，但自己确实学的挺开心的！\n\n# 关于学习进度\n\n最近在进行三件套的学习中，不是前端，是 《c++ primer》、cmu15-445 以及 南大pa实验。\n\n不得不说 《c++ primer》这本书是真的... 不适合学习 c++，至少我个人感觉是这样的，太全面的，感觉更适合当一本字典工具书，不过既然看都看了，那还是坚持看完吧，看了大概600来页吧，其实在看的这一章模板看完基本上就把主体内容看完了，后面就是一些高级主题和各种库了。\n\n然后是cmu15-445，其实本来是想大二下，或者大三再看的，不过因为学校数据库讲的实在是太慢而且太浅了（不过老师很用心），所以不得不提上进程，不过因为 project1 需要扎实的 cpp 基础，所以还没继续看，不过到今天为止的话基础已经差不多打完了。andy 老师的课也还是非常 interestring 的，每节课还有专门的 bgm、dj 什么的，不过 homework1 让写的一些 sql 查询还挺难的...尤其是最后的递归cte。\n\n最后是南大的pa，其实在暑假的时候我就又尝试在做了，不过当时犯了一个非常非常蠢的错误。。。导致环境很久很久都没搭建起来，就放弃了。不过最近再次尝试的时候发现了这个问题并解决了，于是乎又开始了这个实验，不得不说 pa 的实验手册真的写的非常非常好 55555，真的非常感谢jyy老师，余博士等前辈对课程建设的用心啊。不过就是说，pa 好难 qaq\n\n现在吧，自己大概学的东西也挺杂的，从最开始的高中算法竞赛，现在每天也保持着至少一道的力扣每日一题保持手感，算是算法能力应该是过关了的；然后程序语言的话 cpp、javase、python、还有前端三件套balabala的也都会一点，不过都不是非常非常精，接下来打算就主力 cpp 了吧。关于这一点，其实真的挺喜欢 cpp 的，虽然确实难，但是对它总有一种莫名的情感，毕竟是自己接触编程第一门语言，语言里的初恋了属于是）；ai方面的话也算是学了不少，吴恩达老师机器学习、深度学习也都看完了，也自己实现了点小东西，不过后面对数学的要求有点高，加上自己在 ai 里感受不太到编程的乐趣，所以以后也不打算走了；前端的话么，不谈了，学过前端三件套加一些框架后感觉倒不是很好玩；至于计算机基础学科的话，csapp是看完了，不过 labs 还没全做完，打算 pa 后补上，基本上除去没啥问题的数据结构，剩下三大件的话其实都入了个门把。计网的话粗略过了一遍湖科大高老师的课（虽然全忘了），计组的话 csapp里学了些，然后 os 的话 csapp 还有 jyy 老师的课也看了一半，总体上算是过了入门阶段了。\n\n# 关于情感\n\n这两天在看复旦的虎子哥的博客的时候，看到他给npy定了学习计划，还陪对方一起学习了jyy老师的操作系统，看完后自己真的只有羡慕qaq，真的好期待这种一起学习一起进步的生活。其实我觉得自己一直是一个精神独立、生活充沛的人。每天还算自律，坚持锻炼、学习，偶尔打打游戏也不上头，一直保持着提升自己，性格也算主动，不过感觉理想中的这东西还是急不了，慢慢来吧~（先让我把 pa 做了555）\n\n# 关于一些新的想法\n\n最近有时候觉得自己见得世面还是太少了，这段时间又在多看看一些实习的东西，想提早去看看工业界的一些真实场景吧emmm 不知道寒假有没有机会能拿到个后端的开发岗，不过感觉得先把计网的深入学习提上日程了。。。（好忙啊 = ^ =)\n\n----------------------------------------\n\n都瞎写的，最近有点小e，脑子里心里各种都挺乱的，可能是接连两本800来页的书看的人有点心态崩吧，快自我怀疑了 qaq\n\n另外，真的好想去 pku 555555 至少当下就是这样（不知道未来会不会变心）\n\n嗯。。理了一下最近的思路，小小暂停歇了一下。 之后要继续努力了！",charsets:{cjk:!0}},{title:"25 考研随记",frontmatter:{title:"25 考研随记",date:"2023-11-27T22:15:22.000Z",permalink:"/pages/ef3649/",tags:["Casual Records"]},regularPath:"/x04.Casual%20Records/02.25%20%E8%80%83%E7%A0%94%E9%9A%8F%E8%AE%B0.html",relativePath:"x04.Casual Records/02.25 考研随记.md",key:"v-36182552",path:"/pages/ef3649/",headers:[{level:2,title:"2023.11.27",slug:"_2023-11-27",normalizedTitle:"2023.11.27",charIndex:45},{level:2,title:"2023.12.2",slug:"_2023-12-2",normalizedTitle:"2023.12.2",charIndex:160},{level:2,title:"2023.12.9",slug:"_2023-12-9",normalizedTitle:"2023.12.9",charIndex:1502},{level:2,title:"2023.12.17",slug:"_2023-12-17",normalizedTitle:"2023.12.17",charIndex:2245},{level:2,title:"2023.12.24",slug:"_2023-12-24",normalizedTitle:"2023.12.24",charIndex:2840},{level:2,title:"2023.12.31",slug:"_2023-12-31",normalizedTitle:"2023.12.31",charIndex:3277},{level:2,title:"2024.1.7",slug:"_2024-1-7",normalizedTitle:"2024.1.7",charIndex:3943},{level:2,title:"2024.1.14",slug:"_2024-1-14",normalizedTitle:"2024.1.14",charIndex:4374},{level:2,title:"2024.1.21",slug:"_2024-1-21",normalizedTitle:"2024.1.21",charIndex:5055},{level:2,title:"2024.1.29",slug:"_2024-1-29",normalizedTitle:"2024.1.29",charIndex:5638},{level:2,title:"2024.2.4",slug:"_2024-2-4",normalizedTitle:"2024.2.4",charIndex:6059},{level:2,title:"2024.2.11",slug:"_2024-2-11",normalizedTitle:"2024.2.11",charIndex:6322},{level:2,title:"2024.2.18",slug:"_2024-2-18",normalizedTitle:"2024.2.18",charIndex:6637},{level:2,title:"2024.2.25",slug:"_2024-2-25",normalizedTitle:"2024.2.25",charIndex:7179},{level:2,title:"2024.3.3",slug:"_2024-3-3",normalizedTitle:"2024.3.3",charIndex:7481},{level:2,title:"2024.3.10",slug:"_2024-3-10",normalizedTitle:"2024.3.10",charIndex:7851},{level:2,title:"2024.3.17",slug:"_2024-3-17",normalizedTitle:"2024.3.17",charIndex:8311},{level:2,title:"2024.3.24",slug:"_2024-3-24",normalizedTitle:"2024.3.24",charIndex:8681},{level:2,title:"2024.3.31",slug:"_2024-3-31",normalizedTitle:"2024.3.31",charIndex:8870},{level:2,title:"2024.4.3（加更）",slug:"_2024-4-3-加更",normalizedTitle:"2024.4.3（加更）",charIndex:9211},{level:2,title:"2024.4.8（补上周）",slug:"_2024-4-8-补上周",normalizedTitle:"2024.4.8（补上周）",charIndex:9691},{level:2,title:"2024.4.16",slug:"_2024-4-16",normalizedTitle:"2024.4.16",charIndex:10631},{level:2,title:"2024.4.22",slug:"_2024-4-22",normalizedTitle:"2024.4.22",charIndex:10906},{level:2,title:"2024.4.29",slug:"_2024-4-29",normalizedTitle:"2024.4.29",charIndex:11504},{level:2,title:"2024.5.5",slug:"_2024-5-5",normalizedTitle:"2024.5.5",charIndex:12323},{level:2,title:"2024.5.12",slug:"_2024-5-12",normalizedTitle:"2024.5.12",charIndex:12835},{level:2,title:"2024.5.19",slug:"_2024-5-19",normalizedTitle:"2024.5.19",charIndex:13284},{level:2,title:"2024.5.26",slug:"_2024-5-26",normalizedTitle:"2024.5.26",charIndex:14046},{level:2,title:"2024.6.2",slug:"_2024-6-2",normalizedTitle:"2024.6.2",charIndex:14588},{level:2,title:"2024.6.9",slug:"_2024-6-9",normalizedTitle:"2024.6.9",charIndex:15593},{level:2,title:"2024.6.17（补上周）",slug:"_2024-6-17-补上周",normalizedTitle:"2024.6.17（补上周）",charIndex:15984},{level:2,title:"2024.6.25（补上周）",slug:"_2024-6-25-补上周",normalizedTitle:"2024.6.25（补上周）",charIndex:16611},{level:2,title:"2024.6.30",slug:"_2024-6-30",normalizedTitle:"2024.6.30",charIndex:16895},{level:2,title:"2024.7.8（补昨天）",slug:"_2024-7-8-补昨天",normalizedTitle:"2024.7.8（补昨天）",charIndex:17668},{level:2,title:"2024.7.14",slug:"_2024-7-14",normalizedTitle:"2024.7.14",charIndex:17847},{level:2,title:"2024.7.29",slug:"_2024-7-29",normalizedTitle:"2024.7.29",charIndex:18320},{level:2,title:"2024.8.5",slug:"_2024-8-5",normalizedTitle:"2024.8.5",charIndex:18680},{level:2,title:"2024.8.11",slug:"_2024-8-11",normalizedTitle:"2024.8.11",charIndex:19320},{level:2,title:"2024.8.18",slug:"_2024-8-18",normalizedTitle:"2024.8.18",charIndex:19746}],lastUpdated:"11/12/2024, 10:24:10 PM",lastUpdatedTimestamp:173142145e4,headersStr:"2023.11.27 2023.12.2 2023.12.9 2023.12.17 2023.12.24 2023.12.31 2024.1.7 2024.1.14 2024.1.21 2024.1.29 2024.2.4 2024.2.11 2024.2.18 2024.2.25 2024.3.3 2024.3.10 2024.3.17 2024.3.24 2024.3.31 2024.4.3（加更） 2024.4.8（补上周） 2024.4.16 2024.4.22 2024.4.29 2024.5.5 2024.5.12 2024.5.19 2024.5.26 2024.6.2 2024.6.9 2024.6.17（补上周） 2024.6.25（补上周） 2024.6.30 2024.7.8（补昨天） 2024.7.14 2024.7.29 2024.8.5 2024.8.11 2024.8.18",content:"> 漫长的一路，总得留下些什么\n> \n> 谨以此文记录自己的 25 届考研历程。\n\n\n# 2023.11.27\n\n昨天收到了考研准备的数学书，准备翻一翻看看。今天算是把 Fusion 项目基本全做完了，过两天就要进入备考状态了，所以今天开始尝试着去调整了下状态，跑了个快 2 公里，晚上也准备早点睡，调下作息。\n\n\n# 2023.12.2\n\n大概学了几天高数了，整体状态是慢慢有在提升，希望能尽快找回之前的自律感。\n\n昨晚反思了一下，我选择的复旦22408，初试难度确实降了一些，但复试真的难了很多，我突然对这种未知性产生了一些焦虑。。。\n\n翻看了很多资料，我觉得自己得做好这些事情：\n\n初试备考（22408之外）：\n\n或许复试的准备未必要到初试后才进行，12 月初如此早的开始备考，考的又是 22408，那不如趁此机会调整好学习状态进一步的按大一大二那样学。\n\n这个阶段的额外课程主要集中于除了 408 以外的基础课，所以不包括静态分析、难度较高的课程 Lab等\n\n * 扎实一下数据库的理论基础\n * 学习编译原理，但做一个编译器的小项目可以留到初试后\n * 分布式系统理论基础，或许可以先做一下之前看好的分布式数据库的 Lab\n * 网络安全\n * 扎实打磨一下自己 Fusion 的这个前后端项目，搞个软著、大创什么的（或许还有机会落地）\n * ...（暂时就想到这些）\n\n初试备考（22408，希望别改 11408...）：\n\n * 数学自己主跟的是张宇，毕竟自己大一高数基础还不错，听下来也很舒服，不过后续可能还会博览众长一下看看武忠祥老师等\n   \n   * 数学目前打算主要把《张宇基础30讲》好好搞，刷一下 1000 题，同时做做看其他老师的基础讲义例题和课后练习题\n   * 《张宇基础30讲》打算先听课，然后没听完一讲或者大半讲，在对着书捋一遍，把过程中的一些内容记录在 ipad 上\n   * 争取 3 月份前过完基础课接着好好刷题，强化课前可能再把 660 一刷，另外想再练练三大计算\n   * 后续强化冲刺再看了~\n\n * 英语现在就背背单词，可能寒假后半段开始看看课？但毕竟没有听力，轻松很多了，除了听力自己基础应该也还算行，打算寒假到暑假前会每天做点阅读，暑假再开始搞搞翻译作文那些吧\n\n * 政治估计八月份后再开始准备吧\n\n * 408 的话打算寒假开始先把 Nand2Tetris 看看，然后先主攻 OS，辅以计组吧，数据结构和计网感觉本身基础还不错打算寒假结束后再看吧，其实 OS 感觉也还可以但为了开学后能直接考试免听课还是先多做做题。\n\n初试后：\n\n * 出分后，甚至初试完就要开始联系导师，了解导师对学生的要求，研究导师的论文、研究方向，有机会的话还可以去问问能否参加组会\n * 考完初试后，要开始大量练习英语的听读\n * 考完初试后，要大量的准备除了 408 以外的基础课，复习也好，做项目也好，新学也好，例如分布式系统 MIT6.824、编译原理、静态分析（研究生课）、数据库CMU15445...\n * 考完初试后要培养阅读的习惯，顶会论文、计算机科研杂志、各种文章...参考蒋炎岩老师\n * 针对选择的小方向，要进行大量的研究和学习\n * 针对本科的课程成绩单准备一下老师可能会提问的内容（数据库绩点不高但又相当重要，离散概率论这些数学课都忘了估计）\n\n感觉大一大二花了那么多时间，自己无论从目前基础，备考的宏观思路，都不会比大部分科班生差，其实也不用那么焦虑，如果还是怕不稳那就在多努力一些吧emmm，目前就想到这些了，后面有想法再记录吧。\n\n\n# 2023.12.9\n\n下面是我在公交车晕着车瞎写写的（\n\n昨天又开始很焦虑复试，搜集了很多资料，不过并没有什么结果。但在睡前找到了一个复试思路讲解的视频，就是说很多学校的复试打分并不是面试完直接出分然后分数加起来排个序，而是对于满意的学生根据初试成绩打个大约能让其过的分数。 这个真的一语点中人，尤其是对于🥚🥚这种初复试 55 开的。 今天早上我又尝试搜了搜实验室导师们的信息，尝试看看能不能找到些类似招生要求的（当然还是无果）。 不过经过一些思考我还是有些自己新的 idea 的，首先对于本科成绩这一点，似乎我的数据库在其余计算机基础课之间格外突出...另外我粗略翻阅了一下彭老师在知乎发的关于其出版的现代软工那本书的一些思考（恰好是我们软工的课本），或许好好研读一下也很重要。还有就是或许如果复试能展现出一些关于软件科研方面的一些涉猎应该也会大有裨益，例如继续学习一下软件分析的学习，看看导师们的论文，微服务、云原生的科研学习等等。当然有时间还得研究一下 编译原理，java 这些。\n\n当然还得反思一下数学的学习，最近一周的话数学每天都花了 6h+，主要在于听课和复习上，个人复习的方法是听视频课时做好各种标注，然后看一遍书的同时用 ipad 把重要内容都记录下来，另外做一遍例题；完成后还会再单独复习一下 ipad 上的笔记，并制作一份个人的背诵清单，以及背诵答案，之后再进行默写。不知道会不会有点繁琐和效率低，不过自己觉得基础阶段花多少时间去研究课本和知识点都不为过~就是宇哥给了好多技巧还有结论，希望理解后再背下来能提升一下数学思维和解题速度（好像确实挺有帮助）另外题目刷的不多，就做了课后习题以及一点点 《1800》，宇爹你的 25 题源 1000 赶紧出版！\n\n\n# 2023.12.17\n\n昨天 16 号过生日，玩得很开心，今天起床小晚，迷迷糊糊开始写这周的考研随记。\n\n上周末后来联系到了一位想去的实验室的想去的组的去年的学长，聊了些许，似乎开始没那么焦虑了（学长你的经验贴写的真好）。于是乎，我开始了编译原理的学习，以及后续打算继续的静态分析。一开始看的是南大 whf 老师的，不过毕竟不是专门给“网友”的课程录播，听起来有些不适，但资料很全很棒！后来转了中科大老师的 b 站视频，搞了本龙书（刚拿的快递），下载了本虎书，不过似乎都有些难，但还挺有趣，准备学习段时间了。\n\n关于英语的话，每天还在坚持背着单词，慢慢来，毕竟只有读写，压力不大。\n\n关于 408，不急，先等王道今年的书发货，封面是梵高的星空，整挺好看\n\n关于数学，把宇爹目前的更新到的课都看完了，每一讲也做了笔记的复习，背诵清单的制作、默写等，感觉复习的还算充分，不过有些点似乎还是容易忘。《1800》作为现在没题目刷的替代，也刷了一些，感觉还不错。武忠祥老师的课感觉也蛮不错的，有时候可以和宇哥的结合一下下，另外武老师的每一题也开始刷了，今天一会儿准备补上 Day 21 到 Day 25 的。另外准备这两天再看看三大计算练一下计算能力吧。\n\n感觉就这些了（也许会有漏记录的），这周还是很开心的，已经到了 23 年的最后半个月了，另外也快期末了，希望明年一切顺利，平平安安的。\n\n\n# 2023.12.24\n\n又来写考研随记了，这一周似乎没什么变化，至少初试备考上是的。反而是编译原理的学习有了蛮多变化，感觉南大魏老师讲的蛮好的，资料 PPT 也都很全很棒，但 lab 没有开放挺可惜的。\n\n这两天是在开始看 《crafting interpreter》（具体来说是昨天开始的），感觉写得非常有趣，读起来体验很好，英语的也不会很吃力，希望自己能坚持看下去。\n\n静态分析的话，昨天开始看南大软甲分析第三讲前半部分了，今天把剩下的一半看完。\n\n数学的话，这周主要都是刷题整理，倒是昨天搞了本《命题真假 400 条》和《考研快捷解题》（强化阶段再用），《400 条》看着还不错，蛮多概念拷打的，基础阶段打算加入这本的学习计划。比较可惜的是 25 的《张宇 1000 题》似乎又要延迟了，得一月多初版，继续安心等待吧。今天打算继续刷下《三大计算》，再提前做点《660》\n\n英语还是继续背着单词，408 也是还没启动不是很急。\n\n下周开始要开始忙期末了 QAQ\n\n\n# 2023.12.31\n\n今天是 23 年的最后一天，正好也是今年的最后一篇随记，感觉备考了一个月了，收获还是蛮多的。\n\n首先是考研科目外的学习，编译原理算是理论了解了大概，但做的 lab 好硬核，感觉并不是我初试阶段能静下心来去好好攻克的，打算初试完再继续了，静态分析也是。\n\n24 考研结束后感觉得加强了 408 和数学的学习了，先稳初试再说吧。\n\n英语和政治还是老样子，每天背背单词。\n\n408 的话等寒假开始，有一些意向的课程，后面再研究再研究，感觉自己不能仅局限于考纲，以自己的基础得再多看看考纲外的内容。\n\n主要的还是数学的规划，今天似乎我的《张宇1000》到了，要准备开刷了；目前的话基础课算是第五讲结束，复习背诵和题目也都过了一次，准备开始第六讲了；刷题上三大计算也算做完了第一部分，1 / 3 over 了。\n\n目前的一个寒假初步规划：\n\n 1. 看完 25 的张宇基础课（第一轮），要求是每一章要完成：听课，课后知识整理，背诵清单与答案的制定，默一遍背诵清单，完成课后习题与《张宇 1000 题》A 组（第一轮慢一点）\n 2. 第一轮结束后，通过给自己定制整理的知识和背诵清单，开始第二轮的复习，期间开始刷 660，速度要比第一轮快\n 3. 每天 5 - 10 条《400命题》，偶尔可以休一两天\n 4. 武忠祥每日一题\n 5. 错题的记录，和不断重做\n 6. 三大计算刷完\n 7. 任务驱动式（而非时间驱动式）地执行上述任务\n\n差不多就是这些了，这两天也要开始准备期末了，还好课不难不多，明年继续加油！\n\n\n# 2024.1.7\n\n今天是 2024 年的第一个周末，这一周没什么好总结的，基本都在准备期末考试，没什么心情和状态复习考研QAQ 不过今天回家了，明天开始全力模式！\n\n另外最近得到的一些比较好的 idea：\n\n 1. 数学强化班可以听去年的，不用等更新另外买了。\n    * 自己打算可能 30 讲听完或者快听完，或者 wait 更新的时候就开始刷武忠祥老师去年的强化班与题。等宇爹今年的强化出来再听一遍 复习 + 扩展思路。\n 2. 买了本李艳芳 900。\n    * 等自己做了再来评价吧。\n 3. 408 的话感觉小黄鸭老师还不错，再观望一下。\n\n感觉自己数学搭配估计是，基础：1000 + 900 + 660 + 三大计算了（感觉这一套可以用到强化了，做完就能上真题，然后模拟了）\n\n三大计算做完 1/3 了，提早做感觉还蛮有帮助的。\n\n夜记：关于前段时间吴老师和我提到的思路，我在洗澡的时候突然想到了一个蛮不错的下游任务，后续准备跟进看看hh\n\n\n# 2024.1.14\n\n在家呆了一个礼拜了，这一周几乎没出过门基本都在家学习（开摆\n\n感觉这一周状态其实一般般，每天大概 7 个小时左右，每天的 To-Do-List 只能完成个 85 % 的样子，我分析下来很大概率是作息问题，睡得太晚了，今天开始得早点睡（昨天第一天早睡）另外可能是一直在刷题的缘故吧，比听课更加动脑。\n\n数学的话，最近一直在刷三大计算与 900 题，不得不说这两本感觉真的很不错。三大计算对锻炼计算能力帮助还是蛮大的，现在做了 1 / 2 了，感觉基础阶段昨晚确实大有裨益；900 题的题目也是非常新，就是有点小难，但做起来收获还真蛮多的，后面也会继续做下去的。不过宇哥的课更新的有点慢，大部分课好像都是这样，不过慢慢来，就当追番了，每周也可以有更多时间去自我反思、复习以及刷题。\n\n408 的话最近报了王道的领学班，本来就纠结，跟学长请教讨论了一下，果断报了。就是课也是周更，先等 15 号开课观望一下，可能也会自己提前开始吧，毕竟基础还可以。目前是打算后续一天 计组 + 数据结构，一天 OS + 计网的方式去复习，具体等开课在做规划吧，不过目前打算以复习 5 -6 轮的滚动方式来学。\n\n最近比较焦虑的依然是复试的事情，前段时间了解到了一些 LLM 方面的代码语义模型，本来想到了一个还蛮不错的 idea，不过现在看下来实现可能性和创新难度上还是有点大，感觉自己还缺了好多 ML、DL、NLP 方面的知识 T_T，接下来打算继续思考了解看看有什么能做的，只是学这些基础课恐怕是今年是没机会了。初试后的复习规划压力也好大啊 QAQ\n\n\n# 2024.1.21\n\n这周的话感觉收获还是蛮多的吧，大概总结一下。\n\n首先是这周的学习状态，基本上每天都能保证有 7 - 9h 左右，感觉进度还是推的可以的，睡觉时间和起床时间平均下来也比之前稍微早了一点。\n\n数学方面，这周开了积分了，也算是紧跟着 30 讲基础班的进度，不过为了提早开积分计算，所以看了一点武忠祥老师的课，三大计算的最后一板块也开始了。另外的话基本每天都有在刷 900 题，不知道是自己太菜还是题目难，刷的挺吃力的，不过感觉还能坚持，还 ok，收获蛮多的，每道错题自己也有在坚持做总结和收获。另外的话下周也就是明天，打算提早开线代了，打算等数二基础部分结束，也同步结束线代的一轮。\n\n英语的话已经是每天背 100 个单词，练练字什么的，不是很急。\n\n408 的话，算是开始了，目前是先跟着王道的每周进度，不过后面打算自己看书自己安排进度，但目前的还是优先数学\n\n整体上的进度，和学习效果还是在预期的，就是可能做 900 题的效率比较低，另外比较重要的收货是关于复试准备的项目（毕设）内容，感觉自己对 NLP + PL 的较差还是挺感兴趣的，在代码方面的大模型应用研究感觉也蛮有趣的，接下来打算空余时间把机器学习复习一下，再学习一下 NLP 的内容，资料收集了蛮多，不过可能得等我线代学一些之后（这也是提早开线代的原因，而且线代基本全忘了）\n\n\n# 2024.1.29\n\n今天是礼拜一写的上一周的记录，昨天没时间写就拖了一天。\n\n数学上刷题少了些，主要是 30 讲上第九章的积分计算还没更新，三大计算和 900 的积分部分也都不是很好开，不过第八讲算是结束了，概念什么的感觉也算理解的蛮深刻的，但感觉做题还差了点也有可能是放松休了两天状态不对了emm。另外线代的话算是第一讲全 over 了，明天周二打算开第二讲了~\n\n408 的话继续跟着王道，一天一点点地看着，这两周应该可以把数据结构第一遍过掉，还算比较轻松。不过 kmp 那一章看了一些竞赛上的内容，结果复习了好久看到王道书的最后写了统考不考算法大题 QAQ 蛮难蚌的\n\n科研上的话，最近打算开始学习李沐老师的动手学习深度学习（Dive into Deep Learning)了，先把基础打打好，不过因为还在备考就估计会慢一点。\n\n周三去打了次羽毛球，好久没运动了，身体蛮僵硬的，这两天也放松松懈了一下，明天开始得继续加油了。\n\n\n# 2024.2.4\n\n这一周的话感觉自己状态还挺差的，我感觉还是睡得太晚了（这周经常1点睡），昨天早上多睡了一会儿，明显感觉效率状态都嘎嘎好，不过好在这周除了研究项目没进展，考研安排还是在稳步推进着。\n\n数学的话线代结束了第二章，内容还蛮多的，高数的话今天感觉可以听完第九章的课了，明天复习总结一下就可以开始继续三大计算和 900 了。\n\n408 的话上周数据结构在树这里花了蛮多时间的，今天还有最后一个树的应用。\n\n另外的话这周极其后悔没有抢 JJ20 杭州站的票😭，希望能抢到苏州或者终点哈尔滨站的票......\n\n\n# 2024.2.11\n\n新年好啊新年好，这一周虽然是过年但其实效率还可以。\n\n数学的话这周把第十讲结束了，今天打算再重做一遍例题，然后把课后习题做了，明天做 1000 题。下周的话准备开始 6 - 10 讲的复习和错题重做工作了，还有视情况可能用 24 张宇 30 讲把最后一点积分等式与积分不等式过了，也就是结束一元函数积分学这块儿。另外三大计算感觉逐渐有点鸡肋了，积分刷了几道题就停了。\n\n408 的话数据结构这周正式结束了图这章，408 考生要专业课和数学课要记得真的好多。。。我有一定基础都感觉有点吃力了。下周开始查找和排序了，这两章有不少自己熟又不太熟，需要深挖的知识点，毕竟重心还是数学，就争取一周半内结束吧。\n\n\n# 2024.2.18\n\n这周其实状态还可以，不过经常出现做题效率低、复习错题效率低的问题（时间硬怼，另外这周也算是有好好规划了一下进度。\n\n数学的话目前是线代第三章结束了，知识点也总结完了，下周要刷课后习题 + 1000 题第三章基础题了，另外自己是打算一轮线代结束后开强化，以及二刷 900 的基础，进一步复习 1000 错题，开 1000 强化，660 补充吧。就是不知道自己题目能完成的怎么样，感觉做那么多题的基础上 660 应该能很快做掉，毕竟复习的早还是给自己多定点量。\n\n408 的话这周截止到今天已经算是把数据结构最后一章的 8.3 交换排序过掉了，感觉最后三四天应该就能结束数据结构了，之后打算在花一周的时间整体复盘做下思维导图，然后就能开计组了。\n\n另外的话，今天周日算是把 XMind 开了，做了一章蛮大的线代向量组这一章的思维导图，蛮好用的，后面数据结构也用这个。还有做了一个小的个人考研资料工作台，用飞书记录的，还挺好看 + 方便的，目前数据结构排序相关的代码已经自己整理放上去了，前面的还没来得及誊，等二轮或者强化再补上去。还有就是可能自己还得上每周计划了（\n\n另外最后的最后希望自己能抽中 JJ 的重拾快乐黑胶 QAQ （Update：没中。。。）\n\n\n# 2024.2.25\n\n今天回学校了，这两天有点小感冒状态不是很好，昨天鼻子疼得让回想起新冠了。。。不过好在是提前把每周任务完成了\n\n另外周五抽空去了 fd 江湾看了看，学校好好看啊QAQ，得继续加油了。\n\n这周的话数学算是把线代第四章和三四章需要做的题都做完了，有点难，等一轮结束再做一遍吧，高数准备开强化了，至于最后的多元函数+二重积分就等 25 张宇慢慢更新了，另外把 900 题前三章进度内的题 A 组做完了，感觉质量蛮高，难度也蛮大的，收获很多。\n\n408 的话数据结构是一轮结束了，接下来就是做做思维导图，下周开计组了。\n\n这周学习进展还可以，感冒了状态欠佳不继续写了，下周好好加油。\n\n\n# 2024.3.3\n\n这周的话在学校学的，感觉状态还可以，另外还看了蛮多新出的经验贴。\n\n数学的话，这周被第五章弄得蛮久，还差相似化的部分没有看，打算接下来看一下李艳芳老师的线代基础，感觉效率很高。另外，这周做了 660，由于多元微分开始就还没学，做了 1 - 75，感觉不是很难，接下来继续看武老师强化课，准备再刷一下严选题。\n\n408 的话发现自己数据结构学的有点忘了。。。但为了不拖进度，等后面二刷吧，基础还行应该很快就 ok 了。另外，计组第二章学的有点慢，这也是这周唯一的每周计划没完成的部分，但估计接下来还会看几天，因为吸取了数据结构的经验，决定看一个视频就自己总结一下写在纸上，后续隔两天花几分钟看两眼，来减轻后续的复习压力。\n\n英语的话继续再背，另外就是这周开始一天 150 个词儿了。\n\n好了准备去做下周的计划了（\n\n\n# 2024.3.10\n\n这周的话其实如果不看周末，效率还是蛮不错的，周末回家了效率爆炸，这周比较特殊所以得回去一次，下周好好加训了QAQ\n\n这周在学习计划的安排上其实改动了蛮多的，打算把 660 停掉，一方面是错误率并不高，一方面是看了不少经验贴 + 自己反思了一下全是会被 880 + 1000 题全方位覆盖，另外自己强化阶段的计划也算定好了，大致就是：预习 + 听武老师强化课，反思总结完后，做严选题，搞定后开 880 基础 + 综合 + 扩展，期间对于大的专题如数列极限等就放到强化过完集中突破。\n\n数学进度上，目前自己是第一章的总结完了，并且过完了严选题，正确率都还可以，准备过 880（如果周末状态好的话这会儿估计都开第二章强化了），另外周末在听多元微分的基础课，感觉有点晕，不知道是我睡得太少头疼的问题还是确实难，可能下周得再补一下。\n\n408 的话还差个浮点数那一章的习题就把数据表示过完了，虽然相当慢，但感觉过得还是挺扎实的，也做了些总结，后续得记得常看\n\n英语继续背着，老样子\n\n下周加训QAQ\n\n\n# 2024.3.17\n\n这周不算最后三四天本来状态还蛮好的，但先是急性肠胃炎，又是颈椎导致的头剧痛（越睡越痛的那种），直到今天在基本都康复了，有点难蚌。\n\n数学的话，这周基本都在过武忠祥的基础课 + 过一遍 25 张宇 30 讲书上的部分，结束了多元微分 + 微分方程 + 二重积分，但本来计划昨天周六就结束数学基础的，结果最后还剩下了张宇 30 讲 二重积分最后几页的题过一遍才全结束，得明天了，明天顺便做一下课后习题。这周计划突然改变的，因为听了武忠祥的多元微分感觉讲的蛮不错的，而且 25 张宇的课更新太慢了。。。另外就是几天没做题，感觉手好生QAQ，听不了一点\n\n408 的话这周过了大部分的第三章，不过后来因为生病，几天都没碰计组。\n\n下周开始增加了和同学的运动环节，预计 周二、四跑步，周日打球，身体健康真的很重要QAQ\n\n\n# 2024.3.24\n\n这周运动了蛮多的，感觉身体状况确实好很多的（加上拿了两本大黑书做垫子）\n\n数学的话把强化第二章过完了，也复习了一遍感觉还行，明天做做题了，另外就是 880 第一章综合和拓展做的也感觉还行，除了几道证明题有点难蚌\n\n408 继续再过计组，第三章好多过得麻了，这周的计划没有完成QAQ\n\n明天加训！最近能起的很早了，都是 7 点前下的床，每天也不困~\n\n\n# 2024.3.31\n\n这周感觉基本都在做题做题，做的头疼，另外有两天效率有点低。\n\n数学的话算是强化第二章彻底结束，严选题 + 880 的基础 + 综合 + 拓展 全做完了，证明题做的我头疼。下周打算先开第五章，因为基础过得很快，另外得抽一天进行第一章笔记的复习，严选题的错题复习。\n\n408 的话计组第四章还差一点，下周能结束。\n\n另外的话今天打算开始每天早起后，到科技楼直接开始学数学，刷题或者听课，然后中午开始做当天的规划，来尽量保证上午的尽早进入状态，另外下午开 408，来增加 408 的学习时间。\n\n还有就是最近 🥚 的复试又弄得我很焦虑，询问了老师，老师打算帮我后续介绍一个博士认识认识，不管怎么样得提前开始准备一下算法科研类项目了😭\n\n下周继续加油吧。\n\n\n# 2024.4.3（加更）\n\n昨天 4.2 马也哥上岸了，去了我想去的学校，想去的实验室。老实说，从大一开始就一直很想考 🥚，看着马也哥从初试前到出成绩，到复试，到复试结束，一路下来自己也跟着各种焦虑希望他能上岸，但当上岸的那一刻，看到群友们都上岸的那一刻，自己又感觉很怅然，好像已经努力了很久，考研开的很早，又是从大一就一直在努力，但大家上岸的那一刻并不属于自己，好像经历了那么久但其实实际什么都没发生，加上今年加入了机试，分数线爆冷，似乎还有不少跨考的在 xhs 晒（不知道是不是引流），真的愈发焦虑，真当轮到自己上场的那一刻，又是对未来充满了不安。最近从事彻夜难安，反复地刷着群友的消息，以获取信息为借口，其实只是在安慰自己，麻木自己。昨天做出了决定，加下来一段时间回家备考了，似乎有点惧怕那种孤独感。但这应该是必然会面对的，在学校的过多交流会麻木自己，会让自己感到轻松、愉快，仿佛大家在一起战斗，但只有我自己知道，考研这条路，只有自己。\n\n总之希望自己能好好加油，我想如果能考到 400+，无论多炸应该也不会怕吧，拜托一定不要辜负自己的雄志。\n\n\n# 2024.4.8（补上周）\n\n【下面部分内容是在大半夜用语音识别记录的】\n\n首先是这周的状态吧，其实还行，只不过这个礼拜一开始的几天在学校可能状态差一点。周四早上回的家，在家头两天学的状态其实还可以，不过这两天有点心态炸TuT，已经把群扔到群助手里了，真不能水群啊。\n\n先是数学，这个礼拜并没有完成预定的每周计划T_T，主要是因为在多元微分这一章确实听课加讲义的复习花了蛮久的，然后再严选题做了有足足三天，大题错的有点多，小题还好，不过确实收获很多，然后考虑到是速通完基础后的第一次高强度做题也能理解，而且真心感觉这一章的内容概念可以相当深刻QAQ，计算量也相当大。既定的目标是七号前完成多元微分的强化所有题目，今天 8 号还没做完...（昨晚水群太焦虑睡得晚今天起得还早上午状态有点差）不过周二 9 号应该做完没问题，打算10 号整体复盘一下，11 号开微分方程啦。有时感觉自己可能确实进度有点太快了，又或者是第一次上强化感觉也挺正常的，出现了很多焦虑和崩溃的情况，不过还算能扛得住。\n\n408的话，报了个 01 的班，感觉相当不错，周六也听了第一节课，打算后续就跟下去了，不过得先用王道的进行一遍预习就是。另外礼拜天复习的时候还想到了一个记忆策略就是用知识卡片类似背单词一样去记录下来各种琐碎知识点，包括一些个人觉得比较重要的，又以防忘记的知识点，用的是飞书，后面可以感觉还可以开源hhh。不过408的进度确实没有推多少，但也不是很急吧，跟着 01 慢慢来，新的一周得继续开第五章的内容了。\n\n英语的话，这周开始每天 150 个单词变到了 200 个复习 + 新词。\n\n最后就是这周加了很多学长，尤其是从 🍠 认识了邓哥（派神）。真的非常巧 TvT，他去的方向是我非常想去的实验室，和他聊完后还发现初高中都是在一个区的，甚至还有共同认识的人，家也离得很近TwT。总之一聊就非常的有亲切感，真的好想上岸。自开始备考后感觉很难有非常开心的时候了，像这两天完全都是焦虑的心情，感觉今年会炸，虽然自己目标是保 400 冲 420，但自己真的有那实力么，从高中那时起就很怀疑自己的天赋了，也不知道今年冲计还是软，还要博弈，哎，加油吧。今晚早点睡，明天调调作息 好好努力TAT\n\n\n# 2024.4.16\n\n前两天忘记写了，简单回忆一下（有不少已经忘了）\n\n回家后状态还可以，虽然有两天比较焦虑（\n\n数学的话，微分方程还差最后一点点题目就结束了，4 / 16 号周二应该能全部完成，然后开一元积分学的强化，感觉自己做题有点慢。。不过每道题都做了总结不知道效果如何（应该还可以）\n\n408 的话，计组第二章想后面专门自己对着 PPT 和回放复习，所以 01 计组第二节课没跟，另外王道的进度是第五章结束了，这周一开了第六章总线\n\n另外自己定了个时间表，希望后面能照着坚持一下，最近做题做得还蛮焦虑的。。。\n\n英语的话继续在背单词\n\n\n# 2024.4.22\n\n昨天忘记写了，今天补上。这段时间状态一般般，首先是因为这周（实际上周，后用这周代替）回了一次学校，效率不是很高，回来后也调整了一下，就睡得晚上午很困，还有上午的数学也难就效率很低很低 TuT，不过周日还有下周一好一点点。\n\n数学，这周主要是在一元积分强化，课都听完了，例题也都重做了一遍，也总结了一遍，这一套花了好久，但目测没法在目标时间前完成积分强化了。。。因为这周得给 OS 让时间，下周期中考 QAQ，考好了就可以天天待在家里复习了！另外被群u搞的也有点焦虑，怎么 25 的都开始出题了。。。\n\n408，这周计组收了个尾，但是计组第七章课听得有点乱，就过了一半，没做题没看书，打算后面再好好搞一下中断、IO 这块儿，急着开 OS 了，周四大胆问了一下老师，老师说如果下周期中情况好的话就让我免听！OS 再过第二张了，直至周一把调度课看完，题目做了 45 道还没订正，书过了一遍，也做了知识卡片，第二章调度前的内容书 和 题都还没过，第一章全过完了（课 + 书 + 题 + 知识卡片总结），明天打算全开 OS 了，加油！\n\n英语、政治老样子\n\n另外，等期中结束后要给自己好好安排一下时间规划什么的了 TvT，感觉每天都在学但每天都也就七八小时，不过我晚上效率真的高，为什么考研数学不能放在晚上呢T3T，最近还刷到了咸鱼当时的作息，感觉可以偶尔给自己搞个放松日~\n\n\n# 2024.4.29\n\n上周日又忘记写了，周一来补\n\n这周的话起得比之前会晚一点，感觉专注度好了不少，另外还给自己安排上了 tomato 的锁机。\n\n数学，这周在写严选题和 880，截止周一是做到了一元积分学综合篇的解答题，做完基础篇感觉自己无敌了，结果综合篇难度陡增（，这周做完就能开最后一章二重积分了！\n\n408，自从考完试就搁置了几天 OS，死锁的四节课花了三天吃饭的时候听的，然后周一的今天把题目做完了，算是完全结束了巨多的第二章，准备第三章了！另外不知道周四的 OS 怎么样，考了两道 408 真题，等五一后看看老师允不允许免听了😭\n\n英语、政治计划不变\n\n另外就是，周四去认识了一位吴老师介绍的博士刚毕业的师哥，和老师与师哥聊了不少，决定尝试发一篇论文试试，读了一篇吴老师发我的论文，结合了自己以前看的一篇想到了一个 idea，查了一下也没人做过，师哥听了觉得有可行性，自己还找了不少资料，总之接下来一个月可能还要为了发沦为而忙于做实验了QAQ，希望能有个好结果，没好结果就当毕设了也行（，真的好想去 codewisdom 做科研，想发的论文 idea 也是智能软件开发的，感觉能发出来，初试过线，加上自己的代码底子和基础复试真无敌了😭 希望挪用的初试时间都有回报。\n\n下面附上周四回家后（好像是周五）写的近期计划：(似乎不少都得拖一两天 QAQ)\n\n【4.26】严选题积分全做完 / PV 选择题剩余完成 + 订正\n【4.27 + 4.28 + 4.29】 880积分基础 + 综合全做完 / 死锁课、题（？）\n【4.30】 880 积分拓展篇 + 二重积分强化课全部 / 内存 1.1 + 1.2 课、题；内存 1.3 课？\n【5.1 + 5.2 + (5.3)】 二重积分辅导讲义例题全部做一遍 + 严选题全做完\n【5.3】研究制定线代基础复习 + 强化计划\n每天晚上看论文，先综述，CCF-B刊、软件学报\n\n\n\n# 2024.5.5\n\n这周被论文弄得实在是，心力交瘁，非常崩溃，在昨晚的反思下，在今天周日的凌晨决定先不做科研了，还是专心初试吧，哎。。。\n\n数学，周日今天才做完二重积分的严选题，上周做的计划算是被科研完全打乱了，太难过了TuT。明天开始做高数最后一章二重积分的 880 了，另外严选题感觉不难（虽然有不少计算错），但是武强化辅导讲义上的例题重做的时候错了好多，感觉例题难度远大于严选题。。。明天试试 880\n\n408 这周进度就几乎没怎么对，周六才听完 3.1 的课（虽然 3.1 不少，而且第三章内存管理就两部分），周日今天开始过书和做题，感觉这部分王道书，尤其是链接装入的部分讲的相当简略（几乎没讲），这部分自己找了点视频看了，后面二轮打算跟着 01 或者再找点书加补一下。接下来的进度规划：5.15 前结束 OS，开始跟 OS 的直播课，同时周中过计网，OS 直播课结束前，结束计网的看书 + 做题。接下来周末跟 01 计网，周中开计组的二轮 01 基础课 和部分章节的二轮 DS 01 基础课。一轮平均每门花一个月，二轮争取每门 15 天之内。\n\n政治英语老样子，不过英语单词在背超纲词了，整体背的还可以。\n\n\n# 2024.5.12\n\n这周回学校，状态在逐步回升，今天周日学了快 8 h（大概，不过下午看了会儿 BLG 打 T1 的比赛emm。好消息是，OS 的免听申请成功了，接下来可以专心在家备考了！坏消息是，最近水群有点多，不过今天周日还好\n\n数学，这周开始在过线代的强化了，虽说是强化，但一轮学的实在是太乱，导致最后两章完全没学，而姜晓千的线代强化又是直接做题，为了扎实基础，我决定花 6 天把线代基础过了，截止周日过完了第三章向量。等强化的时候考虑同步复习错题（希望自己能做到，也有时间QAQ）\n\n408，老实说自己规划做的非常好，但是实际做下来量实在是太大了，今天按 wd 打卡表 4.1 + 4.2 的部分快过完了，希望明天能收尾并把 4.3 over，结束文件系统，能 14 15 两天过完 OS 最后一章 😭，但我相信我计网应该能按时完成，嗯。。。\n\n最近水群实在是有点多，但进度至少还在保持，昨天听了 25 的宣讲，感觉 25 的卷王还是蛮多的，但自己毕竟奔着组去的，狠狠加油冲了\n\n\n# 2024.5.19\n\n这周的话感觉熬夜熬的有点多，现在是 23:11，打算写完就睡了。另外看 MSI 比赛的几天学习时间确实不高，差不多 6h 左右。\n\n数学，这周开始是正式（前天）进入了线代强化，经过最后的抉择，以及和零壹老师的讨论规划（对，老师太热心了，我后面报了零壹答疑班，和老师进一步细细讨论了，柠檬神😭）后，决定线代流程为：每一章先 24 张宇强化课 + 例题巩固，之后看杨威老师 24 的强化讲义例题与作业和讲解，最后再刷 880。当然期间我还要继续 880 和严选题，还有辅导讲义 高数部分的错题复习，预计放在每天 408 后的下午晚上，上午仍然是推进线代进度。\n\n408，这周把王道 OS 结束了，又和零壹的老师讨论了一下，加上自己的思考，认为现在单独开计网的性价比不搞，于是接下来的安排就是，周日加周一周二，来过零壹的 OS 当周课程以及消化总结，平时跟计组和 DS 的 01 课，进行二轮复习，不做大题，优先加深知识点的理解和复习，等到暑假王道的强化课再同步刷大题，另外跟 01 强化课，感觉在总结（输出）保证的基础上，408 增加轮数，多多益善。但不得不说，我今天过了遇见哥第一章串讲，以及一些知识点，例如系统调用，中断，宏微内核，外核等知识点，讲的真的清楚和深入，我做过 xv6 的实验，对系统调用的影响很深刻，感觉遇见哥通过他的讲解甚至帮我把整个实验都回忆了一遍，真跪了。不过一些琐碎的小知识点，会帮你理解的记忆讲解，更细的得看书补充了（虽然做考研题应该够了，wd 课后题可能不够），但对重要知识点，大题知识点，一些难以理解记忆的知识点，真的强😭\n\n英语政治老样子。\n\n下周得好好加油了，优先是要保证早起早睡，最近皮肤也不好，体重更别说了，下周末还要去听次演唱会，周中一定要好好努力！\n\n\n# 2024.5.26\n\n这周其实学习状态感觉还不错，学的都很清楚，不过周六去 JJ20苏州站Day1 了，第二天下午回家，太困太累状态也不好。\n\n数学，这周学完了线代九讲的第五章，和例题全部的重做，另外下周也就是明天周一打算再把第五章的知识点摘录理一下，感觉做题还是不行。感觉线代比高数难😭，另外 01 的每日一题有点牛逼，每道都直击经典的错误（，下周好好加油数学！\n\n408，这周 408 学的我真感觉无敌了，遇见哥的两节课够我吃 4 天，收获拉的满中之满，各大考研群的问题都能秒啥，且很清楚的讲明白，感觉越来越扎实了了，另外还听了两节 M 佬的存储器，其中一节做了复习，另一节明天复习，M佬的讲课功底和实力也是牛逼，太清楚了，感觉 408 越来越透了！另外周末两天在地铁上一直在考研群里给别人解答 408 的问题，01 老师们教的太好了！\n\n英语政治还是老样子，但是今天在等高铁的时候一口气多背了 100 多个新词，把红宝书拓展词也背完了，相当于我的考研单词后续只需要复习就好了！\n\n这周我觉得状态好了很大一个原因是，加了固定的锁机时间，以及比之前早睡了一丢丢（虽然还是12点），周末真的玩的太开心了，具体感受自己也都发微博就不记录在这里了，明天又要回归日常好好加油了！\n\n\n# 2024.6.2\n\n这周状态中规中矩，比上周好，一共学了 50 个小时，希望下周加油！昨天和马也哥去吃了个饭，越来越有动力了😭\n\n数学，数学的话今天 6.2 算是把 24 张宇 9 讲的课看完了，明天也就是下周一做二次型的例题，接着打算就开杨威老师的线代题目 + 880，做完就准备开套卷了 + 复习 880 和 严选题，还有高数辅导讲义的的高数错题了（忘完了QAQ)。另外这一周一直在做柠檬哥和文文姐的每日一（n）题，每天晚上八九点钟跟着群友一起做，有几题真的给我做的道心破碎了，不过确实属于难题。。。道阻且长啊，让我感觉我的数学已经寄一半了，准备靠408了TVT\n\n408，408 一直状态还可以最近，截止到今天，是把 OS 的内存管理（4h）的课听了一半多一点（预计明天就能把内存管理 + 周日今天的文件系统听完），然后计组部分把存储器是结束了，讲义也看完了，不过留了一道讲义上的综合题打算明天过（今天懒了），然后计组课复习到了指令系统课听完了（讲义没看，感觉重点还是数据运算那部分忘得多，这一节课也涉及到了一部分关于状态码修改的内容，有些就不太熟悉了。。）最后就是未来规划，预计大约 6 月中旬前二轮复习完计组，然后开始数据结构的复习，等到月底前，半个月内把数据结构二轮复习完（应该很快，主要就是复习树、查找、排序三章内容）然后期间的一轮计网我觉得压力应该不会很大，自己计网基础很挺好的，再加上学科性质比 OS 简单，应该会很轻松，只是每周就得额外拿两天用来提前做一遍王道，这次打算先 01，再王道~哦还有就是自己的轮次规划，第一轮过得王道（计网除外）我觉得主要就是了解各知识点（虽然都学过）熟悉一下，然后第一轮能深能串就多扎实一下；第二轮跟 01，过 PPT + 讲义，很多知识点自己输出式地整理，但不过王道书；等到第三轮我再回归 01 PPT 讲义 + 王道书和选择错题以及部分大题；期间可能会同步开四轮的王道强化课以及五轮零壹强化课（因为王道的强化好像比较早）（轮次有点多，但其实类似于流水线一样，三轮自己复习一个知识点没过多久，就会再四轮重复，然后又没过多久可能又进入了五轮（当然主要是难点部分），这是我自己的复习思路，二轮现在就有点这样的形式了）\n\n英语政治老样子，不过果断感觉开始逐步做一下英语真题了，另外这周单词好像有一两天有点摸鱼（\n\n希望下周再接再厉吧，快期末了不过QAQ\n\n\n# 2024.6.9\n\n这周有两天学习情况还可以，但总体的上午效率还是一般般，还是容易熬夜。。。\n\n数学，这周算是做完了杨威老师强化课第一二三章的例题和练习题，感觉线代越学越简单了，下周应该就能结束杨威老师的题了，后续再问问柠檬哥下一步做什么，自己是打算开套卷 + 同步刷错题和 880 线代。\n\n408，今天 6.9 结束了 01 OS 的基础课，这周跟的直播，感觉效果还行，不过 IO 这块儿跟直播有部分内容听得糊涂还得再听一遍梳理一下（主要当时有点犯困了），下周就是 m 佬的计网了，听说是王牌课有波大的。不知道自己能不能在一模前复习完计组 + 数据结构。。。OS 也还有文件和 IO 的讲义 + PPT 得复习 TuT，这周一还有下周三还得搞期末的论文和项目，鸭梨山大。\n\n英语政治不变，这周单词都背了。\n\n累TvT。。。这周还买了黑神话豪华版，今年估计是没机会玩了。\n\n\n# 2024.6.17（补上周）\n\n这周回学校交了个作业，导致一两天几乎没学，状态也一般。。。不过回家后还行（大概\n\n数学，最近的数学进度是真慢啊。。。目前是才将杨威老师第五章的例题做了一半。。。希望下周能结束吧，毕竟数学进度还是快的，想提提 408 二轮的进度，可以一模考考得好点（不过柠檬哥也开始催我们赶紧结束强化，早点模拟套卷了）\n\n408，这周算是正式结束了 OS，把 OS 剩下的几张都复习完了，并且模拟卷也做掉了，自我感觉 OS 复习的算是相当好，不过肯定还不够上考场，但至少目前还是很满意的，解决大部分考研群一半多的问题还是 ok 的。然后周末开了两节计网，能感觉到 m 老师在一些没那么好理解的知识点的讲解上讲的相当不错和细致，不过对于计网这门科目感觉还是得多补充一些细碎的小的点，虽然可能不考就是了，但是得好好过一下王道。\n\n英语政治不变。\n\n这周把蛋大群退了，还清理了一下群列表，打算好好沉淀了，u1s1 虽然有时候还是回去水零壹群和旦工以及王道群，但明显的是水群花的时间下降了，确实有效学习时间还是上来了的，不过睡眠时间还是得提早（虽然感觉经常是因为 22 点后还在学习，又刷了会儿手机，结果就很晚 12 点才睡（当然还包括了周末上课上的晚+洗漱等耗时。下周（本周）基本都在学校里待，希望能尽量学一点吧。。。然后还有个没啥压力的 os 期末。哦对，礼拜一状态很差，很困，因为昨晚我家猫三四点扒窗户把我吵醒了，一宿没睡着 TuT\n\n\n# 2024.6.25（补上周）\n\n上周的忘写了，周一也忘写了，拖到了周二补上。不过上周也没什么好记录的，周一交论文，周三上午考试，所以回了趟学校和室友玩了四天，出去吃了饭，唱了K（还唱了一路生花bushi\n\n数学进度几乎没动，截止到今天周二结束了线代杨威老师的例题和练习题，算是结束了全部的一轮强化\n\n408 倒是在学校把绪论和物理层复习 + 王道书做完了，周五回家后周末两天学的还行，同时晚上上课把链路层直播课听了，不过复习量还有不少\n\n剩下就没什么了。。。摆烂的一周，不过期末 os 考得还行，估的大概有 90+ 吧（，希望能让最后一门 408 也有满绩。\n\n\n# 2024.6.30\n\n这周在家状态一般般，今天是 6 月最后一天，明天开始就要好好加训了（尤其是作息的调整）。写完这次的随记，要做一下下一个月的规划了。\n\n数学，这周开了一套 23李四 1，emmm，怎么说呢，手真的很生，感觉自己强化了个寂寞TuT。经过复盘以及思考，接下来的策略就是查缺补漏了。今天晚上我又在思考，觉得自己光看书看之前的笔记也只能留个印象，熟悉一下，感觉还是有学不进的感觉，所以决定还是以做题驱动了，目前是打算明天先粗略过一下积分一章的知识点，然后用错题本把错题截出来做，有时间再把 1000 题做一下 或者 做严选错题还没想好（另外打算严选错题 880 错题 不再一天做，分开来可以减缓一些遗忘速度）线代强化过程中不学高数正是错误的选择 😭 总之还得做题驱动，套卷用来找漏洞，题集用来打补丁。（不得不说 25 的 18 讲题目是真的多）\n\n408，这周 408 也像往常一样，收获也不少，目前进度是今天周日把 01 计组数据运算上看完了，还差个下以及遗漏的 IO 例题补没看，计组就算二轮（大概）复习完了，接下来的任务主要就是网络层的复习 + 王道书，以及数据结构的复习了，备战一模，虽然目前做的题目不多，基本都在复习知识点，大题也没做过，不过还是要争取 100+，如果能到 100+，我觉得我最后的成绩应该很有机会冲 130（虽然这周和群 u 讨论知识点的过程中，感觉全是漏洞。。。不过小漏洞问题不大 QAQ\n\n英语，这周做了 02 年第一篇完型，有点受打击，感觉英语也得开训了，不过可能阅读理解会简单一点，09 之后也会好些，另外明天准备开始背核心词以及做长难句了\n\n政治，今天刚到的肖 1000 题 以及 苏一导图，准备接下来规划每天看一点，不然政治可能得 50 分了QAQ\n\n明天好好加油！第一步就是早起！\n\n\n# 2024.7.8（补昨天）\n\n这周去拔牙了，疼的相似，总之是感觉一般般的一周，但收获还是不少的，简单写写吧。\n\n数学，开了一套超越，感觉难得一比，但是收获很多，也暂时有方向去打补丁了。\n\n408，周末结束了 01 直播课，日常进度还在补网络层的复习工作 + 王道书（太多了TuT)\n\n英语政治，老样子，但是这周没开英语阅读，两门课等一模结束再考虑了\n\n\n# 2024.7.14\n\n这周状态一般，天天熬夜TuT，今天周日刚结束一模，把大群退了，好好加训了QAQ\n\n数学，这周除了一模没有开额外的套卷，做了一章1000强化的积分学概念，感觉还行，也有不少收获。另外为了避免自己不复习错题，开始有整理每周的错题和记忆点，打算接下来每周至少花一天去复习 T_T 一模真的考的稀巴烂中烂中烂，做起来感觉比超越略简单一点点，但最后估分感觉还没超越高，真的一坨大的，果然训练量还是不够。二模一定要上125+ T^T\n\n408，这周周中结束了计网的一轮（实际看下来一轮并不扎实。。。），完成了wd书的习题，直到周末一模前都在狂学罗素哥的数据结构，复习了很多知识点（虽然不少没考），一模真的是依托大的，遇见哥计组部分学的相当不扎实（没有二刷及时复习的后果），另外大题做的也是。。。哎，目前估分下来是 95 - 100出头，明天开始好好强化复习了TuT\n\n英语政治，老样子，但是明天真要开了，尤其是小英\n\n加油加油加油加油加油加油加油加油加油加油加油加油加油加油，二模一定要冲 数学 + 408 = 260+ 😡\n\n\n# 2024.7.29\n\n上周没写，生病了，这周一起。\n\n最近水群虽然也不少，但是和群u们一起组了个自习室，还有pjh，今天涣散哥也来了。很明显每天的学习时长上去了，基本 8-9+ h了。\n\n数学：上周有点忘了，但这周开了一套真题，2.5 h 做完的，二重积分还原漏了个 r 扣了十分，最后 133，感觉真题确实学不到什么，明天做套超越。不过最近的每周 Review 效果感觉还不错，就是平时的每日一题有点多。。。另外多元微分这里专项训练了一下感觉还可以。下周继续加油\n\n408：最近开了 ds 强化，另外把计组 中断、IO 这块儿做了详细的笔记感觉很不错，不过 wd 的题一直拖着没做，另外 ds 也进入了强化阶段，截止今天算是把树图之前的全结束了（就是01讲义的几道选择题忘做了）\n\n简单写写了有点晚了，加油！\n\n\n# 2024.8.5\n\n昨天有忘写了。。。上周日均时长确实上来了，学习量也上去了，不过后面几天尤其是周末在看奥运乒乓球赛。。时长一般般。\n\n数学，这周做了这超越，做得相当差，但扣分点都在证明题和线代小题上，光证明题就有三道。。难蚌，于是乎最近开始打算再刷一遍线代题集，截止到今天，明后天应该就能把 900 的重点线代题做完了，感觉错的不算太多其实。之后就继续专心夜雨的强化 + 开套卷，不过可能后续 微分方程、二重积分、积分综合题（微分方程、物理应用、几何应用）还会再补一下（比如看看文文姐讲义）总体来说进度不错\n\n408，这周完成了 ds 强化的核心内容，就留了个排序没开，截止到周一今天算是把查找的真题也做完了。自己每一章做的事有：01 课、讲义、ppt、总结笔记、刷真题。反正就是很磨时间，不知道计组将会如何，这周四之前应该是能结束了 ds 强化了的（maybe），但我感觉查找还得再做大题，另外自己跳过了红黑树（\n\n英语，很难讲，感觉阅读还是很多读不懂有些单词认识但文章有点晕，不过 11 年最后两篇都是文章没咋读懂但题目没咋错，就错了 Text4 一道题。。。下周继续吧，不过再下周预计可能要开始作文了\n\n政治，算是想好了一个还不错的复习计划，每天一讲课，然后复习大前天的导图内容 + 做对应的题，但是确实是有点难移出时间来每天保证学习。。。希望调调作息能坚持每天做吧。\n\n加油，最近熬夜还是有，每天累累的 + 还看奥运，确实学习状态时好时坏。。。总体还行吧QAQ\n\n\n# 2024.8.11\n\n毫无疑问，这周是我状态可以说最差的一周，也许是奥运乒乓赛，也许是反正的 408 强化任务、线代进阶任务，也许是厌学的开始，总之这一周状态挺差的，时长的水分也不少。\n\n数学，这周把 900 线代做完了，前面都还行最后一章二次型着实有点难，错了不少。。另外周日看了一点微分不等式证明题，一张套卷没做状态很差\n\n408，这周状态更差了，但把排序结束了，也算正式结束了 ds 强化，满打满算除去生病的两天，一共 17 天左右，从今天吧算是开始了机组的强化。ds 强化自认为还是蛮扎实的不错的，至少考研层面的要求基本达到了，后期就是要复习 + 在做点综合大题，尤其是查找这块儿感觉容易错（哦对还有个红黑树没看）计组的话先要把自己的难点大骨头，数据表示运算给拿下。。。\n\n政治，一点没看\n\n英语，做了两三篇阅读吧，一般般，找了个感觉蛮不错的老师的视频接下来可能会看一些。\n\n明天开始去图书馆了，得好好调整加训了，已经 8 月中旬了！\n\n\n# 2024.8.18\n\n这周状态还可以，去了几天图书馆，后面没去，抽空稍微写一点\n\n数学，这周做了三套模拟卷，周末考了欧几里得 8 月模考，一般般，虽然上了 100 但显然是运气好，另外就是其实大部分题目考完再做都对了，包括证明题和图画错的二重积分，感觉自己现在能力还不够以至于容易各种犯小错误，看来还是得狠狠加训\n\n408，这周进度有点慢，好不容易过完了数据运算强化（花了4天左右？），很难蚌，但指令系统明显快多了，继续加油吧。\n\n英语政治就老样子没怎么学，但周末反思了一下，下周应该会加大力度\n\n加油，最近挺玉玉的。",normalizedContent:"> 漫长的一路，总得留下些什么\n> \n> 谨以此文记录自己的 25 届考研历程。\n\n\n# 2023.11.27\n\n昨天收到了考研准备的数学书，准备翻一翻看看。今天算是把 fusion 项目基本全做完了，过两天就要进入备考状态了，所以今天开始尝试着去调整了下状态，跑了个快 2 公里，晚上也准备早点睡，调下作息。\n\n\n# 2023.12.2\n\n大概学了几天高数了，整体状态是慢慢有在提升，希望能尽快找回之前的自律感。\n\n昨晚反思了一下，我选择的复旦22408，初试难度确实降了一些，但复试真的难了很多，我突然对这种未知性产生了一些焦虑。。。\n\n翻看了很多资料，我觉得自己得做好这些事情：\n\n初试备考（22408之外）：\n\n或许复试的准备未必要到初试后才进行，12 月初如此早的开始备考，考的又是 22408，那不如趁此机会调整好学习状态进一步的按大一大二那样学。\n\n这个阶段的额外课程主要集中于除了 408 以外的基础课，所以不包括静态分析、难度较高的课程 lab等\n\n * 扎实一下数据库的理论基础\n * 学习编译原理，但做一个编译器的小项目可以留到初试后\n * 分布式系统理论基础，或许可以先做一下之前看好的分布式数据库的 lab\n * 网络安全\n * 扎实打磨一下自己 fusion 的这个前后端项目，搞个软著、大创什么的（或许还有机会落地）\n * ...（暂时就想到这些）\n\n初试备考（22408，希望别改 11408...）：\n\n * 数学自己主跟的是张宇，毕竟自己大一高数基础还不错，听下来也很舒服，不过后续可能还会博览众长一下看看武忠祥老师等\n   \n   * 数学目前打算主要把《张宇基础30讲》好好搞，刷一下 1000 题，同时做做看其他老师的基础讲义例题和课后练习题\n   * 《张宇基础30讲》打算先听课，然后没听完一讲或者大半讲，在对着书捋一遍，把过程中的一些内容记录在 ipad 上\n   * 争取 3 月份前过完基础课接着好好刷题，强化课前可能再把 660 一刷，另外想再练练三大计算\n   * 后续强化冲刺再看了~\n\n * 英语现在就背背单词，可能寒假后半段开始看看课？但毕竟没有听力，轻松很多了，除了听力自己基础应该也还算行，打算寒假到暑假前会每天做点阅读，暑假再开始搞搞翻译作文那些吧\n\n * 政治估计八月份后再开始准备吧\n\n * 408 的话打算寒假开始先把 nand2tetris 看看，然后先主攻 os，辅以计组吧，数据结构和计网感觉本身基础还不错打算寒假结束后再看吧，其实 os 感觉也还可以但为了开学后能直接考试免听课还是先多做做题。\n\n初试后：\n\n * 出分后，甚至初试完就要开始联系导师，了解导师对学生的要求，研究导师的论文、研究方向，有机会的话还可以去问问能否参加组会\n * 考完初试后，要开始大量练习英语的听读\n * 考完初试后，要大量的准备除了 408 以外的基础课，复习也好，做项目也好，新学也好，例如分布式系统 mit6.824、编译原理、静态分析（研究生课）、数据库cmu15445...\n * 考完初试后要培养阅读的习惯，顶会论文、计算机科研杂志、各种文章...参考蒋炎岩老师\n * 针对选择的小方向，要进行大量的研究和学习\n * 针对本科的课程成绩单准备一下老师可能会提问的内容（数据库绩点不高但又相当重要，离散概率论这些数学课都忘了估计）\n\n感觉大一大二花了那么多时间，自己无论从目前基础，备考的宏观思路，都不会比大部分科班生差，其实也不用那么焦虑，如果还是怕不稳那就在多努力一些吧emmm，目前就想到这些了，后面有想法再记录吧。\n\n\n# 2023.12.9\n\n下面是我在公交车晕着车瞎写写的（\n\n昨天又开始很焦虑复试，搜集了很多资料，不过并没有什么结果。但在睡前找到了一个复试思路讲解的视频，就是说很多学校的复试打分并不是面试完直接出分然后分数加起来排个序，而是对于满意的学生根据初试成绩打个大约能让其过的分数。 这个真的一语点中人，尤其是对于🥚🥚这种初复试 55 开的。 今天早上我又尝试搜了搜实验室导师们的信息，尝试看看能不能找到些类似招生要求的（当然还是无果）。 不过经过一些思考我还是有些自己新的 idea 的，首先对于本科成绩这一点，似乎我的数据库在其余计算机基础课之间格外突出...另外我粗略翻阅了一下彭老师在知乎发的关于其出版的现代软工那本书的一些思考（恰好是我们软工的课本），或许好好研读一下也很重要。还有就是或许如果复试能展现出一些关于软件科研方面的一些涉猎应该也会大有裨益，例如继续学习一下软件分析的学习，看看导师们的论文，微服务、云原生的科研学习等等。当然有时间还得研究一下 编译原理，java 这些。\n\n当然还得反思一下数学的学习，最近一周的话数学每天都花了 6h+，主要在于听课和复习上，个人复习的方法是听视频课时做好各种标注，然后看一遍书的同时用 ipad 把重要内容都记录下来，另外做一遍例题；完成后还会再单独复习一下 ipad 上的笔记，并制作一份个人的背诵清单，以及背诵答案，之后再进行默写。不知道会不会有点繁琐和效率低，不过自己觉得基础阶段花多少时间去研究课本和知识点都不为过~就是宇哥给了好多技巧还有结论，希望理解后再背下来能提升一下数学思维和解题速度（好像确实挺有帮助）另外题目刷的不多，就做了课后习题以及一点点 《1800》，宇爹你的 25 题源 1000 赶紧出版！\n\n\n# 2023.12.17\n\n昨天 16 号过生日，玩得很开心，今天起床小晚，迷迷糊糊开始写这周的考研随记。\n\n上周末后来联系到了一位想去的实验室的想去的组的去年的学长，聊了些许，似乎开始没那么焦虑了（学长你的经验贴写的真好）。于是乎，我开始了编译原理的学习，以及后续打算继续的静态分析。一开始看的是南大 whf 老师的，不过毕竟不是专门给“网友”的课程录播，听起来有些不适，但资料很全很棒！后来转了中科大老师的 b 站视频，搞了本龙书（刚拿的快递），下载了本虎书，不过似乎都有些难，但还挺有趣，准备学习段时间了。\n\n关于英语的话，每天还在坚持背着单词，慢慢来，毕竟只有读写，压力不大。\n\n关于 408，不急，先等王道今年的书发货，封面是梵高的星空，整挺好看\n\n关于数学，把宇爹目前的更新到的课都看完了，每一讲也做了笔记的复习，背诵清单的制作、默写等，感觉复习的还算充分，不过有些点似乎还是容易忘。《1800》作为现在没题目刷的替代，也刷了一些，感觉还不错。武忠祥老师的课感觉也蛮不错的，有时候可以和宇哥的结合一下下，另外武老师的每一题也开始刷了，今天一会儿准备补上 day 21 到 day 25 的。另外准备这两天再看看三大计算练一下计算能力吧。\n\n感觉就这些了（也许会有漏记录的），这周还是很开心的，已经到了 23 年的最后半个月了，另外也快期末了，希望明年一切顺利，平平安安的。\n\n\n# 2023.12.24\n\n又来写考研随记了，这一周似乎没什么变化，至少初试备考上是的。反而是编译原理的学习有了蛮多变化，感觉南大魏老师讲的蛮好的，资料 ppt 也都很全很棒，但 lab 没有开放挺可惜的。\n\n这两天是在开始看 《crafting interpreter》（具体来说是昨天开始的），感觉写得非常有趣，读起来体验很好，英语的也不会很吃力，希望自己能坚持看下去。\n\n静态分析的话，昨天开始看南大软甲分析第三讲前半部分了，今天把剩下的一半看完。\n\n数学的话，这周主要都是刷题整理，倒是昨天搞了本《命题真假 400 条》和《考研快捷解题》（强化阶段再用），《400 条》看着还不错，蛮多概念拷打的，基础阶段打算加入这本的学习计划。比较可惜的是 25 的《张宇 1000 题》似乎又要延迟了，得一月多初版，继续安心等待吧。今天打算继续刷下《三大计算》，再提前做点《660》\n\n英语还是继续背着单词，408 也是还没启动不是很急。\n\n下周开始要开始忙期末了 qaq\n\n\n# 2023.12.31\n\n今天是 23 年的最后一天，正好也是今年的最后一篇随记，感觉备考了一个月了，收获还是蛮多的。\n\n首先是考研科目外的学习，编译原理算是理论了解了大概，但做的 lab 好硬核，感觉并不是我初试阶段能静下心来去好好攻克的，打算初试完再继续了，静态分析也是。\n\n24 考研结束后感觉得加强了 408 和数学的学习了，先稳初试再说吧。\n\n英语和政治还是老样子，每天背背单词。\n\n408 的话等寒假开始，有一些意向的课程，后面再研究再研究，感觉自己不能仅局限于考纲，以自己的基础得再多看看考纲外的内容。\n\n主要的还是数学的规划，今天似乎我的《张宇1000》到了，要准备开刷了；目前的话基础课算是第五讲结束，复习背诵和题目也都过了一次，准备开始第六讲了；刷题上三大计算也算做完了第一部分，1 / 3 over 了。\n\n目前的一个寒假初步规划：\n\n 1. 看完 25 的张宇基础课（第一轮），要求是每一章要完成：听课，课后知识整理，背诵清单与答案的制定，默一遍背诵清单，完成课后习题与《张宇 1000 题》a 组（第一轮慢一点）\n 2. 第一轮结束后，通过给自己定制整理的知识和背诵清单，开始第二轮的复习，期间开始刷 660，速度要比第一轮快\n 3. 每天 5 - 10 条《400命题》，偶尔可以休一两天\n 4. 武忠祥每日一题\n 5. 错题的记录，和不断重做\n 6. 三大计算刷完\n 7. 任务驱动式（而非时间驱动式）地执行上述任务\n\n差不多就是这些了，这两天也要开始准备期末了，还好课不难不多，明年继续加油！\n\n\n# 2024.1.7\n\n今天是 2024 年的第一个周末，这一周没什么好总结的，基本都在准备期末考试，没什么心情和状态复习考研qaq 不过今天回家了，明天开始全力模式！\n\n另外最近得到的一些比较好的 idea：\n\n 1. 数学强化班可以听去年的，不用等更新另外买了。\n    * 自己打算可能 30 讲听完或者快听完，或者 wait 更新的时候就开始刷武忠祥老师去年的强化班与题。等宇爹今年的强化出来再听一遍 复习 + 扩展思路。\n 2. 买了本李艳芳 900。\n    * 等自己做了再来评价吧。\n 3. 408 的话感觉小黄鸭老师还不错，再观望一下。\n\n感觉自己数学搭配估计是，基础：1000 + 900 + 660 + 三大计算了（感觉这一套可以用到强化了，做完就能上真题，然后模拟了）\n\n三大计算做完 1/3 了，提早做感觉还蛮有帮助的。\n\n夜记：关于前段时间吴老师和我提到的思路，我在洗澡的时候突然想到了一个蛮不错的下游任务，后续准备跟进看看hh\n\n\n# 2024.1.14\n\n在家呆了一个礼拜了，这一周几乎没出过门基本都在家学习（开摆\n\n感觉这一周状态其实一般般，每天大概 7 个小时左右，每天的 to-do-list 只能完成个 85 % 的样子，我分析下来很大概率是作息问题，睡得太晚了，今天开始得早点睡（昨天第一天早睡）另外可能是一直在刷题的缘故吧，比听课更加动脑。\n\n数学的话，最近一直在刷三大计算与 900 题，不得不说这两本感觉真的很不错。三大计算对锻炼计算能力帮助还是蛮大的，现在做了 1 / 2 了，感觉基础阶段昨晚确实大有裨益；900 题的题目也是非常新，就是有点小难，但做起来收获还真蛮多的，后面也会继续做下去的。不过宇哥的课更新的有点慢，大部分课好像都是这样，不过慢慢来，就当追番了，每周也可以有更多时间去自我反思、复习以及刷题。\n\n408 的话最近报了王道的领学班，本来就纠结，跟学长请教讨论了一下，果断报了。就是课也是周更，先等 15 号开课观望一下，可能也会自己提前开始吧，毕竟基础还可以。目前是打算后续一天 计组 + 数据结构，一天 os + 计网的方式去复习，具体等开课在做规划吧，不过目前打算以复习 5 -6 轮的滚动方式来学。\n\n最近比较焦虑的依然是复试的事情，前段时间了解到了一些 llm 方面的代码语义模型，本来想到了一个还蛮不错的 idea，不过现在看下来实现可能性和创新难度上还是有点大，感觉自己还缺了好多 ml、dl、nlp 方面的知识 t_t，接下来打算继续思考了解看看有什么能做的，只是学这些基础课恐怕是今年是没机会了。初试后的复习规划压力也好大啊 qaq\n\n\n# 2024.1.21\n\n这周的话感觉收获还是蛮多的吧，大概总结一下。\n\n首先是这周的学习状态，基本上每天都能保证有 7 - 9h 左右，感觉进度还是推的可以的，睡觉时间和起床时间平均下来也比之前稍微早了一点。\n\n数学方面，这周开了积分了，也算是紧跟着 30 讲基础班的进度，不过为了提早开积分计算，所以看了一点武忠祥老师的课，三大计算的最后一板块也开始了。另外的话基本每天都有在刷 900 题，不知道是自己太菜还是题目难，刷的挺吃力的，不过感觉还能坚持，还 ok，收获蛮多的，每道错题自己也有在坚持做总结和收获。另外的话下周也就是明天，打算提早开线代了，打算等数二基础部分结束，也同步结束线代的一轮。\n\n英语的话已经是每天背 100 个单词，练练字什么的，不是很急。\n\n408 的话，算是开始了，目前是先跟着王道的每周进度，不过后面打算自己看书自己安排进度，但目前的还是优先数学\n\n整体上的进度，和学习效果还是在预期的，就是可能做 900 题的效率比较低，另外比较重要的收货是关于复试准备的项目（毕设）内容，感觉自己对 nlp + pl 的较差还是挺感兴趣的，在代码方面的大模型应用研究感觉也蛮有趣的，接下来打算空余时间把机器学习复习一下，再学习一下 nlp 的内容，资料收集了蛮多，不过可能得等我线代学一些之后（这也是提早开线代的原因，而且线代基本全忘了）\n\n\n# 2024.1.29\n\n今天是礼拜一写的上一周的记录，昨天没时间写就拖了一天。\n\n数学上刷题少了些，主要是 30 讲上第九章的积分计算还没更新，三大计算和 900 的积分部分也都不是很好开，不过第八讲算是结束了，概念什么的感觉也算理解的蛮深刻的，但感觉做题还差了点也有可能是放松休了两天状态不对了emm。另外线代的话算是第一讲全 over 了，明天周二打算开第二讲了~\n\n408 的话继续跟着王道，一天一点点地看着，这两周应该可以把数据结构第一遍过掉，还算比较轻松。不过 kmp 那一章看了一些竞赛上的内容，结果复习了好久看到王道书的最后写了统考不考算法大题 qaq 蛮难蚌的\n\n科研上的话，最近打算开始学习李沐老师的动手学习深度学习（dive into deep learning)了，先把基础打打好，不过因为还在备考就估计会慢一点。\n\n周三去打了次羽毛球，好久没运动了，身体蛮僵硬的，这两天也放松松懈了一下，明天开始得继续加油了。\n\n\n# 2024.2.4\n\n这一周的话感觉自己状态还挺差的，我感觉还是睡得太晚了（这周经常1点睡），昨天早上多睡了一会儿，明显感觉效率状态都嘎嘎好，不过好在这周除了研究项目没进展，考研安排还是在稳步推进着。\n\n数学的话线代结束了第二章，内容还蛮多的，高数的话今天感觉可以听完第九章的课了，明天复习总结一下就可以开始继续三大计算和 900 了。\n\n408 的话上周数据结构在树这里花了蛮多时间的，今天还有最后一个树的应用。\n\n另外的话这周极其后悔没有抢 jj20 杭州站的票😭，希望能抢到苏州或者终点哈尔滨站的票......\n\n\n# 2024.2.11\n\n新年好啊新年好，这一周虽然是过年但其实效率还可以。\n\n数学的话这周把第十讲结束了，今天打算再重做一遍例题，然后把课后习题做了，明天做 1000 题。下周的话准备开始 6 - 10 讲的复习和错题重做工作了，还有视情况可能用 24 张宇 30 讲把最后一点积分等式与积分不等式过了，也就是结束一元函数积分学这块儿。另外三大计算感觉逐渐有点鸡肋了，积分刷了几道题就停了。\n\n408 的话数据结构这周正式结束了图这章，408 考生要专业课和数学课要记得真的好多。。。我有一定基础都感觉有点吃力了。下周开始查找和排序了，这两章有不少自己熟又不太熟，需要深挖的知识点，毕竟重心还是数学，就争取一周半内结束吧。\n\n\n# 2024.2.18\n\n这周其实状态还可以，不过经常出现做题效率低、复习错题效率低的问题（时间硬怼，另外这周也算是有好好规划了一下进度。\n\n数学的话目前是线代第三章结束了，知识点也总结完了，下周要刷课后习题 + 1000 题第三章基础题了，另外自己是打算一轮线代结束后开强化，以及二刷 900 的基础，进一步复习 1000 错题，开 1000 强化，660 补充吧。就是不知道自己题目能完成的怎么样，感觉做那么多题的基础上 660 应该能很快做掉，毕竟复习的早还是给自己多定点量。\n\n408 的话这周截止到今天已经算是把数据结构最后一章的 8.3 交换排序过掉了，感觉最后三四天应该就能结束数据结构了，之后打算在花一周的时间整体复盘做下思维导图，然后就能开计组了。\n\n另外的话，今天周日算是把 xmind 开了，做了一章蛮大的线代向量组这一章的思维导图，蛮好用的，后面数据结构也用这个。还有做了一个小的个人考研资料工作台，用飞书记录的，还挺好看 + 方便的，目前数据结构排序相关的代码已经自己整理放上去了，前面的还没来得及誊，等二轮或者强化再补上去。还有就是可能自己还得上每周计划了（\n\n另外最后的最后希望自己能抽中 jj 的重拾快乐黑胶 qaq （update：没中。。。）\n\n\n# 2024.2.25\n\n今天回学校了，这两天有点小感冒状态不是很好，昨天鼻子疼得让回想起新冠了。。。不过好在是提前把每周任务完成了\n\n另外周五抽空去了 fd 江湾看了看，学校好好看啊qaq，得继续加油了。\n\n这周的话数学算是把线代第四章和三四章需要做的题都做完了，有点难，等一轮结束再做一遍吧，高数准备开强化了，至于最后的多元函数+二重积分就等 25 张宇慢慢更新了，另外把 900 题前三章进度内的题 a 组做完了，感觉质量蛮高，难度也蛮大的，收获很多。\n\n408 的话数据结构是一轮结束了，接下来就是做做思维导图，下周开计组了。\n\n这周学习进展还可以，感冒了状态欠佳不继续写了，下周好好加油。\n\n\n# 2024.3.3\n\n这周的话在学校学的，感觉状态还可以，另外还看了蛮多新出的经验贴。\n\n数学的话，这周被第五章弄得蛮久，还差相似化的部分没有看，打算接下来看一下李艳芳老师的线代基础，感觉效率很高。另外，这周做了 660，由于多元微分开始就还没学，做了 1 - 75，感觉不是很难，接下来继续看武老师强化课，准备再刷一下严选题。\n\n408 的话发现自己数据结构学的有点忘了。。。但为了不拖进度，等后面二刷吧，基础还行应该很快就 ok 了。另外，计组第二章学的有点慢，这也是这周唯一的每周计划没完成的部分，但估计接下来还会看几天，因为吸取了数据结构的经验，决定看一个视频就自己总结一下写在纸上，后续隔两天花几分钟看两眼，来减轻后续的复习压力。\n\n英语的话继续再背，另外就是这周开始一天 150 个词儿了。\n\n好了准备去做下周的计划了（\n\n\n# 2024.3.10\n\n这周的话其实如果不看周末，效率还是蛮不错的，周末回家了效率爆炸，这周比较特殊所以得回去一次，下周好好加训了qaq\n\n这周在学习计划的安排上其实改动了蛮多的，打算把 660 停掉，一方面是错误率并不高，一方面是看了不少经验贴 + 自己反思了一下全是会被 880 + 1000 题全方位覆盖，另外自己强化阶段的计划也算定好了，大致就是：预习 + 听武老师强化课，反思总结完后，做严选题，搞定后开 880 基础 + 综合 + 扩展，期间对于大的专题如数列极限等就放到强化过完集中突破。\n\n数学进度上，目前自己是第一章的总结完了，并且过完了严选题，正确率都还可以，准备过 880（如果周末状态好的话这会儿估计都开第二章强化了），另外周末在听多元微分的基础课，感觉有点晕，不知道是我睡得太少头疼的问题还是确实难，可能下周得再补一下。\n\n408 的话还差个浮点数那一章的习题就把数据表示过完了，虽然相当慢，但感觉过得还是挺扎实的，也做了些总结，后续得记得常看\n\n英语继续背着，老样子\n\n下周加训qaq\n\n\n# 2024.3.17\n\n这周不算最后三四天本来状态还蛮好的，但先是急性肠胃炎，又是颈椎导致的头剧痛（越睡越痛的那种），直到今天在基本都康复了，有点难蚌。\n\n数学的话，这周基本都在过武忠祥的基础课 + 过一遍 25 张宇 30 讲书上的部分，结束了多元微分 + 微分方程 + 二重积分，但本来计划昨天周六就结束数学基础的，结果最后还剩下了张宇 30 讲 二重积分最后几页的题过一遍才全结束，得明天了，明天顺便做一下课后习题。这周计划突然改变的，因为听了武忠祥的多元微分感觉讲的蛮不错的，而且 25 张宇的课更新太慢了。。。另外就是几天没做题，感觉手好生qaq，听不了一点\n\n408 的话这周过了大部分的第三章，不过后来因为生病，几天都没碰计组。\n\n下周开始增加了和同学的运动环节，预计 周二、四跑步，周日打球，身体健康真的很重要qaq\n\n\n# 2024.3.24\n\n这周运动了蛮多的，感觉身体状况确实好很多的（加上拿了两本大黑书做垫子）\n\n数学的话把强化第二章过完了，也复习了一遍感觉还行，明天做做题了，另外就是 880 第一章综合和拓展做的也感觉还行，除了几道证明题有点难蚌\n\n408 继续再过计组，第三章好多过得麻了，这周的计划没有完成qaq\n\n明天加训！最近能起的很早了，都是 7 点前下的床，每天也不困~\n\n\n# 2024.3.31\n\n这周感觉基本都在做题做题，做的头疼，另外有两天效率有点低。\n\n数学的话算是强化第二章彻底结束，严选题 + 880 的基础 + 综合 + 拓展 全做完了，证明题做的我头疼。下周打算先开第五章，因为基础过得很快，另外得抽一天进行第一章笔记的复习，严选题的错题复习。\n\n408 的话计组第四章还差一点，下周能结束。\n\n另外的话今天打算开始每天早起后，到科技楼直接开始学数学，刷题或者听课，然后中午开始做当天的规划，来尽量保证上午的尽早进入状态，另外下午开 408，来增加 408 的学习时间。\n\n还有就是最近 🥚 的复试又弄得我很焦虑，询问了老师，老师打算帮我后续介绍一个博士认识认识，不管怎么样得提前开始准备一下算法科研类项目了😭\n\n下周继续加油吧。\n\n\n# 2024.4.3（加更）\n\n昨天 4.2 马也哥上岸了，去了我想去的学校，想去的实验室。老实说，从大一开始就一直很想考 🥚，看着马也哥从初试前到出成绩，到复试，到复试结束，一路下来自己也跟着各种焦虑希望他能上岸，但当上岸的那一刻，看到群友们都上岸的那一刻，自己又感觉很怅然，好像已经努力了很久，考研开的很早，又是从大一就一直在努力，但大家上岸的那一刻并不属于自己，好像经历了那么久但其实实际什么都没发生，加上今年加入了机试，分数线爆冷，似乎还有不少跨考的在 xhs 晒（不知道是不是引流），真的愈发焦虑，真当轮到自己上场的那一刻，又是对未来充满了不安。最近从事彻夜难安，反复地刷着群友的消息，以获取信息为借口，其实只是在安慰自己，麻木自己。昨天做出了决定，加下来一段时间回家备考了，似乎有点惧怕那种孤独感。但这应该是必然会面对的，在学校的过多交流会麻木自己，会让自己感到轻松、愉快，仿佛大家在一起战斗，但只有我自己知道，考研这条路，只有自己。\n\n总之希望自己能好好加油，我想如果能考到 400+，无论多炸应该也不会怕吧，拜托一定不要辜负自己的雄志。\n\n\n# 2024.4.8（补上周）\n\n【下面部分内容是在大半夜用语音识别记录的】\n\n首先是这周的状态吧，其实还行，只不过这个礼拜一开始的几天在学校可能状态差一点。周四早上回的家，在家头两天学的状态其实还可以，不过这两天有点心态炸tut，已经把群扔到群助手里了，真不能水群啊。\n\n先是数学，这个礼拜并没有完成预定的每周计划t_t，主要是因为在多元微分这一章确实听课加讲义的复习花了蛮久的，然后再严选题做了有足足三天，大题错的有点多，小题还好，不过确实收获很多，然后考虑到是速通完基础后的第一次高强度做题也能理解，而且真心感觉这一章的内容概念可以相当深刻qaq，计算量也相当大。既定的目标是七号前完成多元微分的强化所有题目，今天 8 号还没做完...（昨晚水群太焦虑睡得晚今天起得还早上午状态有点差）不过周二 9 号应该做完没问题，打算10 号整体复盘一下，11 号开微分方程啦。有时感觉自己可能确实进度有点太快了，又或者是第一次上强化感觉也挺正常的，出现了很多焦虑和崩溃的情况，不过还算能扛得住。\n\n408的话，报了个 01 的班，感觉相当不错，周六也听了第一节课，打算后续就跟下去了，不过得先用王道的进行一遍预习就是。另外礼拜天复习的时候还想到了一个记忆策略就是用知识卡片类似背单词一样去记录下来各种琐碎知识点，包括一些个人觉得比较重要的，又以防忘记的知识点，用的是飞书，后面可以感觉还可以开源hhh。不过408的进度确实没有推多少，但也不是很急吧，跟着 01 慢慢来，新的一周得继续开第五章的内容了。\n\n英语的话，这周开始每天 150 个单词变到了 200 个复习 + 新词。\n\n最后就是这周加了很多学长，尤其是从 🍠 认识了邓哥（派神）。真的非常巧 tvt，他去的方向是我非常想去的实验室，和他聊完后还发现初高中都是在一个区的，甚至还有共同认识的人，家也离得很近twt。总之一聊就非常的有亲切感，真的好想上岸。自开始备考后感觉很难有非常开心的时候了，像这两天完全都是焦虑的心情，感觉今年会炸，虽然自己目标是保 400 冲 420，但自己真的有那实力么，从高中那时起就很怀疑自己的天赋了，也不知道今年冲计还是软，还要博弈，哎，加油吧。今晚早点睡，明天调调作息 好好努力tat\n\n\n# 2024.4.16\n\n前两天忘记写了，简单回忆一下（有不少已经忘了）\n\n回家后状态还可以，虽然有两天比较焦虑（\n\n数学的话，微分方程还差最后一点点题目就结束了，4 / 16 号周二应该能全部完成，然后开一元积分学的强化，感觉自己做题有点慢。。不过每道题都做了总结不知道效果如何（应该还可以）\n\n408 的话，计组第二章想后面专门自己对着 ppt 和回放复习，所以 01 计组第二节课没跟，另外王道的进度是第五章结束了，这周一开了第六章总线\n\n另外自己定了个时间表，希望后面能照着坚持一下，最近做题做得还蛮焦虑的。。。\n\n英语的话继续在背单词\n\n\n# 2024.4.22\n\n昨天忘记写了，今天补上。这段时间状态一般般，首先是因为这周（实际上周，后用这周代替）回了一次学校，效率不是很高，回来后也调整了一下，就睡得晚上午很困，还有上午的数学也难就效率很低很低 tut，不过周日还有下周一好一点点。\n\n数学，这周主要是在一元积分强化，课都听完了，例题也都重做了一遍，也总结了一遍，这一套花了好久，但目测没法在目标时间前完成积分强化了。。。因为这周得给 os 让时间，下周期中考 qaq，考好了就可以天天待在家里复习了！另外被群u搞的也有点焦虑，怎么 25 的都开始出题了。。。\n\n408，这周计组收了个尾，但是计组第七章课听得有点乱，就过了一半，没做题没看书，打算后面再好好搞一下中断、io 这块儿，急着开 os 了，周四大胆问了一下老师，老师说如果下周期中情况好的话就让我免听！os 再过第二张了，直至周一把调度课看完，题目做了 45 道还没订正，书过了一遍，也做了知识卡片，第二章调度前的内容书 和 题都还没过，第一章全过完了（课 + 书 + 题 + 知识卡片总结），明天打算全开 os 了，加油！\n\n英语、政治老样子\n\n另外，等期中结束后要给自己好好安排一下时间规划什么的了 tvt，感觉每天都在学但每天都也就七八小时，不过我晚上效率真的高，为什么考研数学不能放在晚上呢t3t，最近还刷到了咸鱼当时的作息，感觉可以偶尔给自己搞个放松日~\n\n\n# 2024.4.29\n\n上周日又忘记写了，周一来补\n\n这周的话起得比之前会晚一点，感觉专注度好了不少，另外还给自己安排上了 tomato 的锁机。\n\n数学，这周在写严选题和 880，截止周一是做到了一元积分学综合篇的解答题，做完基础篇感觉自己无敌了，结果综合篇难度陡增（，这周做完就能开最后一章二重积分了！\n\n408，自从考完试就搁置了几天 os，死锁的四节课花了三天吃饭的时候听的，然后周一的今天把题目做完了，算是完全结束了巨多的第二章，准备第三章了！另外不知道周四的 os 怎么样，考了两道 408 真题，等五一后看看老师允不允许免听了😭\n\n英语、政治计划不变\n\n另外就是，周四去认识了一位吴老师介绍的博士刚毕业的师哥，和老师与师哥聊了不少，决定尝试发一篇论文试试，读了一篇吴老师发我的论文，结合了自己以前看的一篇想到了一个 idea，查了一下也没人做过，师哥听了觉得有可行性，自己还找了不少资料，总之接下来一个月可能还要为了发沦为而忙于做实验了qaq，希望能有个好结果，没好结果就当毕设了也行（，真的好想去 codewisdom 做科研，想发的论文 idea 也是智能软件开发的，感觉能发出来，初试过线，加上自己的代码底子和基础复试真无敌了😭 希望挪用的初试时间都有回报。\n\n下面附上周四回家后（好像是周五）写的近期计划：(似乎不少都得拖一两天 qaq)\n\n【4.26】严选题积分全做完 / pv 选择题剩余完成 + 订正\n【4.27 + 4.28 + 4.29】 880积分基础 + 综合全做完 / 死锁课、题（？）\n【4.30】 880 积分拓展篇 + 二重积分强化课全部 / 内存 1.1 + 1.2 课、题；内存 1.3 课？\n【5.1 + 5.2 + (5.3)】 二重积分辅导讲义例题全部做一遍 + 严选题全做完\n【5.3】研究制定线代基础复习 + 强化计划\n每天晚上看论文，先综述，ccf-b刊、软件学报\n\n\n\n# 2024.5.5\n\n这周被论文弄得实在是，心力交瘁，非常崩溃，在昨晚的反思下，在今天周日的凌晨决定先不做科研了，还是专心初试吧，哎。。。\n\n数学，周日今天才做完二重积分的严选题，上周做的计划算是被科研完全打乱了，太难过了tut。明天开始做高数最后一章二重积分的 880 了，另外严选题感觉不难（虽然有不少计算错），但是武强化辅导讲义上的例题重做的时候错了好多，感觉例题难度远大于严选题。。。明天试试 880\n\n408 这周进度就几乎没怎么对，周六才听完 3.1 的课（虽然 3.1 不少，而且第三章内存管理就两部分），周日今天开始过书和做题，感觉这部分王道书，尤其是链接装入的部分讲的相当简略（几乎没讲），这部分自己找了点视频看了，后面二轮打算跟着 01 或者再找点书加补一下。接下来的进度规划：5.15 前结束 os，开始跟 os 的直播课，同时周中过计网，os 直播课结束前，结束计网的看书 + 做题。接下来周末跟 01 计网，周中开计组的二轮 01 基础课 和部分章节的二轮 ds 01 基础课。一轮平均每门花一个月，二轮争取每门 15 天之内。\n\n政治英语老样子，不过英语单词在背超纲词了，整体背的还可以。\n\n\n# 2024.5.12\n\n这周回学校，状态在逐步回升，今天周日学了快 8 h（大概，不过下午看了会儿 blg 打 t1 的比赛emm。好消息是，os 的免听申请成功了，接下来可以专心在家备考了！坏消息是，最近水群有点多，不过今天周日还好\n\n数学，这周开始在过线代的强化了，虽说是强化，但一轮学的实在是太乱，导致最后两章完全没学，而姜晓千的线代强化又是直接做题，为了扎实基础，我决定花 6 天把线代基础过了，截止周日过完了第三章向量。等强化的时候考虑同步复习错题（希望自己能做到，也有时间qaq）\n\n408，老实说自己规划做的非常好，但是实际做下来量实在是太大了，今天按 wd 打卡表 4.1 + 4.2 的部分快过完了，希望明天能收尾并把 4.3 over，结束文件系统，能 14 15 两天过完 os 最后一章 😭，但我相信我计网应该能按时完成，嗯。。。\n\n最近水群实在是有点多，但进度至少还在保持，昨天听了 25 的宣讲，感觉 25 的卷王还是蛮多的，但自己毕竟奔着组去的，狠狠加油冲了\n\n\n# 2024.5.19\n\n这周的话感觉熬夜熬的有点多，现在是 23:11，打算写完就睡了。另外看 msi 比赛的几天学习时间确实不高，差不多 6h 左右。\n\n数学，这周开始是正式（前天）进入了线代强化，经过最后的抉择，以及和零壹老师的讨论规划（对，老师太热心了，我后面报了零壹答疑班，和老师进一步细细讨论了，柠檬神😭）后，决定线代流程为：每一章先 24 张宇强化课 + 例题巩固，之后看杨威老师 24 的强化讲义例题与作业和讲解，最后再刷 880。当然期间我还要继续 880 和严选题，还有辅导讲义 高数部分的错题复习，预计放在每天 408 后的下午晚上，上午仍然是推进线代进度。\n\n408，这周把王道 os 结束了，又和零壹的老师讨论了一下，加上自己的思考，认为现在单独开计网的性价比不搞，于是接下来的安排就是，周日加周一周二，来过零壹的 os 当周课程以及消化总结，平时跟计组和 ds 的 01 课，进行二轮复习，不做大题，优先加深知识点的理解和复习，等到暑假王道的强化课再同步刷大题，另外跟 01 强化课，感觉在总结（输出）保证的基础上，408 增加轮数，多多益善。但不得不说，我今天过了遇见哥第一章串讲，以及一些知识点，例如系统调用，中断，宏微内核，外核等知识点，讲的真的清楚和深入，我做过 xv6 的实验，对系统调用的影响很深刻，感觉遇见哥通过他的讲解甚至帮我把整个实验都回忆了一遍，真跪了。不过一些琐碎的小知识点，会帮你理解的记忆讲解，更细的得看书补充了（虽然做考研题应该够了，wd 课后题可能不够），但对重要知识点，大题知识点，一些难以理解记忆的知识点，真的强😭\n\n英语政治老样子。\n\n下周得好好加油了，优先是要保证早起早睡，最近皮肤也不好，体重更别说了，下周末还要去听次演唱会，周中一定要好好努力！\n\n\n# 2024.5.26\n\n这周其实学习状态感觉还不错，学的都很清楚，不过周六去 jj20苏州站day1 了，第二天下午回家，太困太累状态也不好。\n\n数学，这周学完了线代九讲的第五章，和例题全部的重做，另外下周也就是明天周一打算再把第五章的知识点摘录理一下，感觉做题还是不行。感觉线代比高数难😭，另外 01 的每日一题有点牛逼，每道都直击经典的错误（，下周好好加油数学！\n\n408，这周 408 学的我真感觉无敌了，遇见哥的两节课够我吃 4 天，收获拉的满中之满，各大考研群的问题都能秒啥，且很清楚的讲明白，感觉越来越扎实了了，另外还听了两节 m 佬的存储器，其中一节做了复习，另一节明天复习，m佬的讲课功底和实力也是牛逼，太清楚了，感觉 408 越来越透了！另外周末两天在地铁上一直在考研群里给别人解答 408 的问题，01 老师们教的太好了！\n\n英语政治还是老样子，但是今天在等高铁的时候一口气多背了 100 多个新词，把红宝书拓展词也背完了，相当于我的考研单词后续只需要复习就好了！\n\n这周我觉得状态好了很大一个原因是，加了固定的锁机时间，以及比之前早睡了一丢丢（虽然还是12点），周末真的玩的太开心了，具体感受自己也都发微博就不记录在这里了，明天又要回归日常好好加油了！\n\n\n# 2024.6.2\n\n这周状态中规中矩，比上周好，一共学了 50 个小时，希望下周加油！昨天和马也哥去吃了个饭，越来越有动力了😭\n\n数学，数学的话今天 6.2 算是把 24 张宇 9 讲的课看完了，明天也就是下周一做二次型的例题，接着打算就开杨威老师的线代题目 + 880，做完就准备开套卷了 + 复习 880 和 严选题，还有高数辅导讲义的的高数错题了（忘完了qaq)。另外这一周一直在做柠檬哥和文文姐的每日一（n）题，每天晚上八九点钟跟着群友一起做，有几题真的给我做的道心破碎了，不过确实属于难题。。。道阻且长啊，让我感觉我的数学已经寄一半了，准备靠408了tvt\n\n408，408 一直状态还可以最近，截止到今天，是把 os 的内存管理（4h）的课听了一半多一点（预计明天就能把内存管理 + 周日今天的文件系统听完），然后计组部分把存储器是结束了，讲义也看完了，不过留了一道讲义上的综合题打算明天过（今天懒了），然后计组课复习到了指令系统课听完了（讲义没看，感觉重点还是数据运算那部分忘得多，这一节课也涉及到了一部分关于状态码修改的内容，有些就不太熟悉了。。）最后就是未来规划，预计大约 6 月中旬前二轮复习完计组，然后开始数据结构的复习，等到月底前，半个月内把数据结构二轮复习完（应该很快，主要就是复习树、查找、排序三章内容）然后期间的一轮计网我觉得压力应该不会很大，自己计网基础很挺好的，再加上学科性质比 os 简单，应该会很轻松，只是每周就得额外拿两天用来提前做一遍王道，这次打算先 01，再王道~哦还有就是自己的轮次规划，第一轮过得王道（计网除外）我觉得主要就是了解各知识点（虽然都学过）熟悉一下，然后第一轮能深能串就多扎实一下；第二轮跟 01，过 ppt + 讲义，很多知识点自己输出式地整理，但不过王道书；等到第三轮我再回归 01 ppt 讲义 + 王道书和选择错题以及部分大题；期间可能会同步开四轮的王道强化课以及五轮零壹强化课（因为王道的强化好像比较早）（轮次有点多，但其实类似于流水线一样，三轮自己复习一个知识点没过多久，就会再四轮重复，然后又没过多久可能又进入了五轮（当然主要是难点部分），这是我自己的复习思路，二轮现在就有点这样的形式了）\n\n英语政治老样子，不过果断感觉开始逐步做一下英语真题了，另外这周单词好像有一两天有点摸鱼（\n\n希望下周再接再厉吧，快期末了不过qaq\n\n\n# 2024.6.9\n\n这周有两天学习情况还可以，但总体的上午效率还是一般般，还是容易熬夜。。。\n\n数学，这周算是做完了杨威老师强化课第一二三章的例题和练习题，感觉线代越学越简单了，下周应该就能结束杨威老师的题了，后续再问问柠檬哥下一步做什么，自己是打算开套卷 + 同步刷错题和 880 线代。\n\n408，今天 6.9 结束了 01 os 的基础课，这周跟的直播，感觉效果还行，不过 io 这块儿跟直播有部分内容听得糊涂还得再听一遍梳理一下（主要当时有点犯困了），下周就是 m 佬的计网了，听说是王牌课有波大的。不知道自己能不能在一模前复习完计组 + 数据结构。。。os 也还有文件和 io 的讲义 + ppt 得复习 tut，这周一还有下周三还得搞期末的论文和项目，鸭梨山大。\n\n英语政治不变，这周单词都背了。\n\n累tvt。。。这周还买了黑神话豪华版，今年估计是没机会玩了。\n\n\n# 2024.6.17（补上周）\n\n这周回学校交了个作业，导致一两天几乎没学，状态也一般。。。不过回家后还行（大概\n\n数学，最近的数学进度是真慢啊。。。目前是才将杨威老师第五章的例题做了一半。。。希望下周能结束吧，毕竟数学进度还是快的，想提提 408 二轮的进度，可以一模考考得好点（不过柠檬哥也开始催我们赶紧结束强化，早点模拟套卷了）\n\n408，这周算是正式结束了 os，把 os 剩下的几张都复习完了，并且模拟卷也做掉了，自我感觉 os 复习的算是相当好，不过肯定还不够上考场，但至少目前还是很满意的，解决大部分考研群一半多的问题还是 ok 的。然后周末开了两节计网，能感觉到 m 老师在一些没那么好理解的知识点的讲解上讲的相当不错和细致，不过对于计网这门科目感觉还是得多补充一些细碎的小的点，虽然可能不考就是了，但是得好好过一下王道。\n\n英语政治不变。\n\n这周把蛋大群退了，还清理了一下群列表，打算好好沉淀了，u1s1 虽然有时候还是回去水零壹群和旦工以及王道群，但明显的是水群花的时间下降了，确实有效学习时间还是上来了的，不过睡眠时间还是得提早（虽然感觉经常是因为 22 点后还在学习，又刷了会儿手机，结果就很晚 12 点才睡（当然还包括了周末上课上的晚+洗漱等耗时。下周（本周）基本都在学校里待，希望能尽量学一点吧。。。然后还有个没啥压力的 os 期末。哦对，礼拜一状态很差，很困，因为昨晚我家猫三四点扒窗户把我吵醒了，一宿没睡着 tut\n\n\n# 2024.6.25（补上周）\n\n上周的忘写了，周一也忘写了，拖到了周二补上。不过上周也没什么好记录的，周一交论文，周三上午考试，所以回了趟学校和室友玩了四天，出去吃了饭，唱了k（还唱了一路生花bushi\n\n数学进度几乎没动，截止到今天周二结束了线代杨威老师的例题和练习题，算是结束了全部的一轮强化\n\n408 倒是在学校把绪论和物理层复习 + 王道书做完了，周五回家后周末两天学的还行，同时晚上上课把链路层直播课听了，不过复习量还有不少\n\n剩下就没什么了。。。摆烂的一周，不过期末 os 考得还行，估的大概有 90+ 吧（，希望能让最后一门 408 也有满绩。\n\n\n# 2024.6.30\n\n这周在家状态一般般，今天是 6 月最后一天，明天开始就要好好加训了（尤其是作息的调整）。写完这次的随记，要做一下下一个月的规划了。\n\n数学，这周开了一套 23李四 1，emmm，怎么说呢，手真的很生，感觉自己强化了个寂寞tut。经过复盘以及思考，接下来的策略就是查缺补漏了。今天晚上我又在思考，觉得自己光看书看之前的笔记也只能留个印象，熟悉一下，感觉还是有学不进的感觉，所以决定还是以做题驱动了，目前是打算明天先粗略过一下积分一章的知识点，然后用错题本把错题截出来做，有时间再把 1000 题做一下 或者 做严选错题还没想好（另外打算严选错题 880 错题 不再一天做，分开来可以减缓一些遗忘速度）线代强化过程中不学高数正是错误的选择 😭 总之还得做题驱动，套卷用来找漏洞，题集用来打补丁。（不得不说 25 的 18 讲题目是真的多）\n\n408，这周 408 也像往常一样，收获也不少，目前进度是今天周日把 01 计组数据运算上看完了，还差个下以及遗漏的 io 例题补没看，计组就算二轮（大概）复习完了，接下来的任务主要就是网络层的复习 + 王道书，以及数据结构的复习了，备战一模，虽然目前做的题目不多，基本都在复习知识点，大题也没做过，不过还是要争取 100+，如果能到 100+，我觉得我最后的成绩应该很有机会冲 130（虽然这周和群 u 讨论知识点的过程中，感觉全是漏洞。。。不过小漏洞问题不大 qaq\n\n英语，这周做了 02 年第一篇完型，有点受打击，感觉英语也得开训了，不过可能阅读理解会简单一点，09 之后也会好些，另外明天准备开始背核心词以及做长难句了\n\n政治，今天刚到的肖 1000 题 以及 苏一导图，准备接下来规划每天看一点，不然政治可能得 50 分了qaq\n\n明天好好加油！第一步就是早起！\n\n\n# 2024.7.8（补昨天）\n\n这周去拔牙了，疼的相似，总之是感觉一般般的一周，但收获还是不少的，简单写写吧。\n\n数学，开了一套超越，感觉难得一比，但是收获很多，也暂时有方向去打补丁了。\n\n408，周末结束了 01 直播课，日常进度还在补网络层的复习工作 + 王道书（太多了tut)\n\n英语政治，老样子，但是这周没开英语阅读，两门课等一模结束再考虑了\n\n\n# 2024.7.14\n\n这周状态一般，天天熬夜tut，今天周日刚结束一模，把大群退了，好好加训了qaq\n\n数学，这周除了一模没有开额外的套卷，做了一章1000强化的积分学概念，感觉还行，也有不少收获。另外为了避免自己不复习错题，开始有整理每周的错题和记忆点，打算接下来每周至少花一天去复习 t_t 一模真的考的稀巴烂中烂中烂，做起来感觉比超越略简单一点点，但最后估分感觉还没超越高，真的一坨大的，果然训练量还是不够。二模一定要上125+ t^t\n\n408，这周周中结束了计网的一轮（实际看下来一轮并不扎实。。。），完成了wd书的习题，直到周末一模前都在狂学罗素哥的数据结构，复习了很多知识点（虽然不少没考），一模真的是依托大的，遇见哥计组部分学的相当不扎实（没有二刷及时复习的后果），另外大题做的也是。。。哎，目前估分下来是 95 - 100出头，明天开始好好强化复习了tut\n\n英语政治，老样子，但是明天真要开了，尤其是小英\n\n加油加油加油加油加油加油加油加油加油加油加油加油加油加油，二模一定要冲 数学 + 408 = 260+ 😡\n\n\n# 2024.7.29\n\n上周没写，生病了，这周一起。\n\n最近水群虽然也不少，但是和群u们一起组了个自习室，还有pjh，今天涣散哥也来了。很明显每天的学习时长上去了，基本 8-9+ h了。\n\n数学：上周有点忘了，但这周开了一套真题，2.5 h 做完的，二重积分还原漏了个 r 扣了十分，最后 133，感觉真题确实学不到什么，明天做套超越。不过最近的每周 review 效果感觉还不错，就是平时的每日一题有点多。。。另外多元微分这里专项训练了一下感觉还可以。下周继续加油\n\n408：最近开了 ds 强化，另外把计组 中断、io 这块儿做了详细的笔记感觉很不错，不过 wd 的题一直拖着没做，另外 ds 也进入了强化阶段，截止今天算是把树图之前的全结束了（就是01讲义的几道选择题忘做了）\n\n简单写写了有点晚了，加油！\n\n\n# 2024.8.5\n\n昨天有忘写了。。。上周日均时长确实上来了，学习量也上去了，不过后面几天尤其是周末在看奥运乒乓球赛。。时长一般般。\n\n数学，这周做了这超越，做得相当差，但扣分点都在证明题和线代小题上，光证明题就有三道。。难蚌，于是乎最近开始打算再刷一遍线代题集，截止到今天，明后天应该就能把 900 的重点线代题做完了，感觉错的不算太多其实。之后就继续专心夜雨的强化 + 开套卷，不过可能后续 微分方程、二重积分、积分综合题（微分方程、物理应用、几何应用）还会再补一下（比如看看文文姐讲义）总体来说进度不错\n\n408，这周完成了 ds 强化的核心内容，就留了个排序没开，截止到周一今天算是把查找的真题也做完了。自己每一章做的事有：01 课、讲义、ppt、总结笔记、刷真题。反正就是很磨时间，不知道计组将会如何，这周四之前应该是能结束了 ds 强化了的（maybe），但我感觉查找还得再做大题，另外自己跳过了红黑树（\n\n英语，很难讲，感觉阅读还是很多读不懂有些单词认识但文章有点晕，不过 11 年最后两篇都是文章没咋读懂但题目没咋错，就错了 text4 一道题。。。下周继续吧，不过再下周预计可能要开始作文了\n\n政治，算是想好了一个还不错的复习计划，每天一讲课，然后复习大前天的导图内容 + 做对应的题，但是确实是有点难移出时间来每天保证学习。。。希望调调作息能坚持每天做吧。\n\n加油，最近熬夜还是有，每天累累的 + 还看奥运，确实学习状态时好时坏。。。总体还行吧qaq\n\n\n# 2024.8.11\n\n毫无疑问，这周是我状态可以说最差的一周，也许是奥运乒乓赛，也许是反正的 408 强化任务、线代进阶任务，也许是厌学的开始，总之这一周状态挺差的，时长的水分也不少。\n\n数学，这周把 900 线代做完了，前面都还行最后一章二次型着实有点难，错了不少。。另外周日看了一点微分不等式证明题，一张套卷没做状态很差\n\n408，这周状态更差了，但把排序结束了，也算正式结束了 ds 强化，满打满算除去生病的两天，一共 17 天左右，从今天吧算是开始了机组的强化。ds 强化自认为还是蛮扎实的不错的，至少考研层面的要求基本达到了，后期就是要复习 + 在做点综合大题，尤其是查找这块儿感觉容易错（哦对还有个红黑树没看）计组的话先要把自己的难点大骨头，数据表示运算给拿下。。。\n\n政治，一点没看\n\n英语，做了两三篇阅读吧，一般般，找了个感觉蛮不错的老师的视频接下来可能会看一些。\n\n明天开始去图书馆了，得好好调整加训了，已经 8 月中旬了！\n\n\n# 2024.8.18\n\n这周状态还可以，去了几天图书馆，后面没去，抽空稍微写一点\n\n数学，这周做了三套模拟卷，周末考了欧几里得 8 月模考，一般般，虽然上了 100 但显然是运气好，另外就是其实大部分题目考完再做都对了，包括证明题和图画错的二重积分，感觉自己现在能力还不够以至于容易各种犯小错误，看来还是得狠狠加训\n\n408，这周进度有点慢，好不容易过完了数据运算强化（花了4天左右？），很难蚌，但指令系统明显快多了，继续加油吧。\n\n英语政治就老样子没怎么学，但周末反思了一下，下周应该会加大力度\n\n加油，最近挺玉玉的。",charsets:{cjk:!0}},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,tags:"更多"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-702df9d4",path:"/tags/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,tags:null},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-464606d4",path:"/archives/",lastUpdated:"3/4/2023, 5:38:14 PM",lastUpdatedTimestamp:1677922694e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Home",frontmatter:{home:!0,heroText:"Yra's blog",tagline:"记录个人的CS学习，内容或许会很杂。",bannerBg:"/img/sky_homepage.png",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-89715122",path:"/",lastUpdated:"8/16/2023, 11:58:02 AM",lastUpdatedTimestamp:1692158282e3,headersStr:null,content:" * 欢迎来到 Yra 的个人博客，本博客建立于 2022.8.13。我会在这里记录一些自己在计算机专业学习过程中的一些心得与知识分享。\n\n * 博客主页上面的 sidebar 是博客文章的大致分类。\n\n * 如果您有什么问题可以联系我：wenjun-1216@qq.com\n\n * 旧博客地址：Yra - 博客园\n\n----------------------------------------\n\n【本页面最近更新于2023.7.24】",normalizedContent:" * 欢迎来到 yra 的个人博客，本博客建立于 2022.8.13。我会在这里记录一些自己在计算机专业学习过程中的一些心得与知识分享。\n\n * 博客主页上面的 sidebar 是博客文章的大致分类。\n\n * 如果您有什么问题可以联系我：wenjun-1216@qq.com\n\n * 旧博客地址：yra - 博客园\n\n----------------------------------------\n\n【本页面最近更新于2023.7.24】",charsets:{cjk:!0}}],themeConfig:{nav:[{text:"Homepage",link:"/"},{text:"Competitive Programming",link:"/CompetitiveProgramming/",items:[{text:"LeetCode周赛",link:"/pages/dc89c0/"},{text:"Acwing周赛",link:"/pages/29a8bf/"},{text:"刷题整理",link:"/pages/0b751d/"},{text:"题解",link:"/pages/bdac31/"}]},{text:"Programming Languages",link:"/ProgrammingLanguages/",items:[{text:"CPP",link:"/pages/96615a/"},{text:"Golang",link:"/pages/f2991f/"}]},{text:"Learning Notes",link:"/LearningNotes",items:[{text:"System",items:[{text:"MIT6.S081 Labs",link:"/pages/80231f/"}]},{text:"Computer Networking",items:[{text:"CS144: Computer Networking",link:"/pages/dda50b/"}]},{text:"DataBase",items:[{text:"MySQL",link:"/pages/498a73/"},{text:"Redis",link:"/pages/c32e71/"}]},{text:"Others",items:[{text:"......",link:"/pages/b04817/"}]}]},{text:"Research",link:"/Research/",items:[{text:"Paper Reading",items:[{text:"Petri Net",link:"/pages/547f66/"}]},{text:"Static Analysis",items:[{text:"NJU Course Notes",link:"/pages/2498ed/"}]},{text:"Deep Learning",items:[{text:"Dive into Deep Learning",link:"/pages/382964/"}]}]},{text:"Casual Records",link:"/CasualRecords/"},{text:"Archives",link:"/archives/"}],sidebarDepth:2,logo:"/img/favicon-32x32.png",searchMaxSuggestions:10,lastUpdated:!0,docsDir:"docs",pageStyle:"card",category:!1,tag:!0,archive:!0,categoryText:"随笔",contentBgStyle:1,rightMenuBar:!0,sidebarOpen:!0,pageButton:!0,sidebar:{"/00.目录页/":[["01.Competitive Programming.md","Competitive Programming","/CompetitiveProgramming"],["02.Research.md","Research","/Research"],["03.Learning Notes.md","Learning Notes","/LearningNotes"],["04.Casual Records.md","Casual Records","/CasualRecords"],["05.Programming Languages.md","Programming Languages","/ProgrammingLanguages"]],catalogue:{"Competitive Programming":"/CompetitiveProgramming",Research:"/Research","Learning Notes":"/LearningNotes","Casual Records":"/CasualRecords","Programming Languages":"/ProgrammingLanguages"},"/01.Competitive Programming/":[{title:"LeetCode周赛",collapsable:!0,children:[{title:"Contests",collapsable:!0,children:[["01.LeetCode周赛/01.Contests/01.LeetCode 307th Weekly Contest.md","LeetCode 307th Weekly Contest","/pages/dc89c0/"],["01.LeetCode周赛/01.Contests/02.LeetCode 308th Weekly Contest.md","LeetCode 308th Weekly Contest","/pages/82da93/"],["01.LeetCode周赛/01.Contests/03.LeetCode 86th Biweekly Contest.md","LeetCode 86th Biweekly Contest","/pages/93641c/"],["01.LeetCode周赛/01.Contests/04.LeetCode 310th Weekly Contest.md","LeetCode 310th Weekly Contest","/pages/4804d1/"],["01.LeetCode周赛/01.Contests/05.LeetCode 312th Weekly Contest.md","LeetCode 312th Weekly Contest","/pages/e43306/"],["01.LeetCode周赛/01.Contests/06.LeetCode 313th Weekly Contest.md","LeetCode 313th Weekly Contest","/pages/4c0651/"],["01.LeetCode周赛/01.Contests/07.LeetCode 88th Biweekly Contest.md","LeetCode 88th Biweekly Contest","/pages/3ceb05/"],["01.LeetCode周赛/01.Contests/08.LeetCode 321th Weekly Contest.md","LeetCode 321th Weekly Contest","/pages/445c9b/"]]}]},{title:"Acwing周赛",collapsable:!0,children:[{title:"Contests",collapsable:!0,children:[["02.Acwing周赛/01.Contests/01.Acwing 64th Weekly Contest.md","Acwing 64th Weekly Contest","/pages/29a8bf/"]]}]},{title:"刷题日寄",collapsable:!0,children:[["03.刷题日寄/01.简简单单刷个题⑧.md","简简单单刷个题⑧","/pages/0b751d/"]]},{title:"题解",collapsable:!0,children:[["04.题解/01.洛谷P6510.md","洛谷P6510","/pages/bdac31/"],["04.题解/02.ABC283_F.md","ABC283_F","/pages/285600/"]]}],"/02.Research/":[{title:"Paper Reading",collapsable:!0,children:[{title:"Petri Net",collapsable:!0,children:[["01.Paper Reading/01.Petri Net/01.整理：基于着色Petri网的无人机侦察战术规划.md","整理：基于着色Petri网的无人机侦察战术规划","/pages/547f66/"]]}]},{title:"Static Analysis",collapsable:!0,children:[{title:"NJU Course Notes",collapsable:!0,children:[["02.Static Analysis/01.NJU Course Notes/01.Introduction.md","01 - Introduction","/pages/2498ed/"],["02.Static Analysis/01.NJU Course Notes/02.Intermediate Representation(IR).md","02 - Intermediate Representation(IR)","/pages/6818d5/"]]}]},{title:"Deep Learning",collapsable:!0,children:[["03.Deep Learning/01.Dive into Deep Learning.md","Dive into Deep Learning","/pages/382964/"]]}],"/03.Learning Notes/":[{title:"System",collapsable:!0,children:[{title:"MIT6.S081 | 21Fall",collapsable:!0,children:[["01.System/01.MIT6.S081 | 21Fall/01.Lab1: Unix utilities.md","Lab1: Unix utilities","/pages/80231f/"],["01.System/01.MIT6.S081 | 21Fall/02.Lab2: System Calls.md","Lab2: System Calls","/pages/e84f04/"],["01.System/01.MIT6.S081 | 21Fall/03.Lab3: Page Tables.md","Lab3: Page Tables","/pages/aa266f/"],["01.System/01.MIT6.S081 | 21Fall/04.Lab4: Traps.md","Lab4: Traps","/pages/80245f/"],["01.System/01.MIT6.S081 | 21Fall/05.Lab5: Copy-on-Write Fork for xv6.md","Lab5: Copy-on-Write Fork for xv6","/pages/810ff6/"],["01.System/01.MIT6.S081 | 21Fall/06.Lab6: Multithreading.md","Lab6: Multithreading","/pages/2bb440/"],["01.System/01.MIT6.S081 | 21Fall/07.Lab7: Networking.md","Lab7: Networking","/pages/b8b8a2/"],["01.System/01.MIT6.S081 | 21Fall/08.Lab8: Locks.md","Lab8: Locks","/pages/19fce7/"],["01.System/01.MIT6.S081 | 21Fall/09.Lab9: File System.md","Lab9: File System","/pages/865884/"],["01.System/01.MIT6.S081 | 21Fall/010.Lab10: Mmap.md","Lab10: Mmap","/pages/4708e0/"]]}]},{title:"Computer Networking",collapsable:!0,children:[{title:"CS144：Computer Networking",collapsable:!0,children:[["02.Computer Networking/02.CS144：Computer Networking/01.Lab0：Networking warmup.md","Lab0：Networking warmup","/pages/dda50b/"],["02.Computer Networking/02.CS144：Computer Networking/02.Lab1：stitching substrings into a byte stream.md","Lab1：stitching substrings into a byte stream","/pages/dc39fe/"],["02.Computer Networking/02.CS144：Computer Networking/03.Lab2：The TCP Receiver.md","Lab2：The TCP Receiver","/pages/875773/"],["02.Computer Networking/02.CS144：Computer Networking/04.Lab3：The TCP Sender.md","Lab3：The TCP Sender","/pages/e12074/"],["02.Computer Networking/02.CS144：Computer Networking/05.Lab4：The TCP Connection.md","Lab4：The TCP Connection","/pages/e07ff0/"]]}]},{title:"DataBase",collapsable:!0,children:[{title:"MySQL",collapsable:!0,children:[["03.DataBase/01.MySQL/01.MySQL 问题整理.md","MySQL 问题整理","/pages/498a73/"]]},{title:"Redis",collapsable:!0,children:[["03.DataBase/02.Redis/01.Redis 缓冲区溢出问题总结 copy.md","Redis 缓冲区溢出问题总结","/pages/c32e71/"],["03.DataBase/02.Redis/02.「缓存和数据库一致性问题」阅读笔记.md","「缓存和数据库一致性问题」阅读笔记","/pages/aac048/"]]}]},{title:"Software Engineering",collapsable:!0,children:[{title:"THU Course Notes",collapsable:!0,children:[["04.Software Engineering/01.THU Course Notes/01.软工笔记01：概述.md","01 - 概述","/pages/15f315/"],["04.Software Engineering/01.THU Course Notes/02.软工笔记02：软件过程.md","02 - 软件过程","/pages/7b3c38/"],["04.Software Engineering/01.THU Course Notes/03.软工笔记03：用例建模.md","03 - 用例建模","/pages/d38254/"]]}]},{title:"Others",collapsable:!0,children:[["05.Others/01.通过 Bit-Manipulation 实现 abs 函数.md","通过 Bit-Manipulation 实现 abs 函数","/pages/b04817/"],["05.Others/02.408 计组笔记.md","408 计组笔记","/pages/0e1ab0/"]]}],"/05.Programming Languages/":[{title:"CPP",collapsable:!0,children:[["01.CPP/01.【OOP】访问控制与继承.md","【OOP】访问控制与继承","/pages/96615a/"],["01.CPP/02.右值引用与std::move().md","右值引用与std::move()","/pages/03d2a3/"]]},{title:"Golang",collapsable:!0,children:[["02.Golang/01. Go 语言中的 GC 问题整理.md","Go 语言中的 GC 问题整理","/pages/f2991f/"],["02.Golang/02. Go 语言中的 channel 相关问题整理.md","Go 语言中的 Channel 相关问题整理","/pages/843296/"]]}],"/x04.Casual Records/":[["01.一些最近.md","一些最近","/pages/018443/"],["02.25 考研随记.md","25 考研随记","/pages/ef3649/"]]},author:{name:"Yra"},blogger:{avatar:"/img/head.png",name:"Yra",slogan:"Only a vegetable dog."},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:wenjun-1216@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Yra-A"}]},footer:{createYear:2022},blogInfo:{blogCreate:"2022-8-13",indexView:!0,pageView:!1,readingTime:!1,eachFileWords:[{name:"Competitive Programming",filePath:"/Users/yra/Desktop/MyBlog/docs/00.目录页/01.Competitive Programming.md",wordsCount:54,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.Competitive Programming",description:"程序设计竞赛中的一些解题记录和算法学习笔记"}},title:"Competitive Programming",date:"2022-08-07T22:48:31.000Z",permalink:"/CompetitiveProgramming",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},{name:"Research",filePath:"/Users/yra/Desktop/MyBlog/docs/00.目录页/02.Research.md",wordsCount:43,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.Research",description:"磕盐方面的一点点学习记录"}},title:"Research",date:"2022-08-07T23:32:01.000Z",permalink:"/Research",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},{name:"Learning Notes",filePath:"/Users/yra/Desktop/MyBlog/docs/00.目录页/03.Learning Notes.md",wordsCount:39,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"03.Learning Notes",description:"一些学习笔记"}},title:"Learning Notes",date:"2022-09-10T21:43:01.000Z",permalink:"/LearningNotes",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},{name:"Casual Records",filePath:"/Users/yra/Desktop/MyBlog/docs/00.目录页/04.Casual Records.md",wordsCount:42,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"04.Casual Records",description:"瞎写写，随便记录记录"}},title:"Casual Records",date:"2022-10-08T13:00:00.000Z",permalink:"/CasualRecords",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},{name:"Programming Languages",filePath:"/Users/yra/Desktop/MyBlog/docs/00.目录页/05.Programming Languages.md",wordsCount:46,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"05.Programming Languages",description:"一些编程语言的学习记录分享"}},title:"Programming Languages",date:"2022-10-31T15:00:00.000Z",permalink:"/ProgrammingLanguages",sidebar:!1,article:!1,comment:!1,editLink:!1,tags:["目录页"]},{name:"LeetCode 307th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/01.LeetCode 307th Weekly Contest.md",wordsCount:"1.1k",readingTime:"5.1m",title:"LeetCode 307th Weekly Contest",date:"2022-08-23T10:20:21.000Z",permalink:"/pages/dc89c0/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 308th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/02.LeetCode 308th Weekly Contest.md",wordsCount:840,readingTime:"4.1m",title:"LeetCode 308th Weekly Contest",date:"2022-08-29T14:34:47.000Z",permalink:"/pages/82da93/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 86th Biweekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/03.LeetCode 86th Biweekly Contest.md",wordsCount:956,readingTime:"4.8m",title:"LeetCode 86th Biweekly Contest",date:"2022-09-04T21:49:04.000Z",permalink:"/pages/93641c/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 310th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/04.LeetCode 310th Weekly Contest.md",wordsCount:"1.1k",readingTime:"5.1m",title:"LeetCode 310th Weekly Contest",date:"2022-09-13T19:20:16.000Z",permalink:"/pages/4804d1/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 312th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/05.LeetCode 312th Weekly Contest.md",wordsCount:"1.2k",readingTime:"5.5m",title:"LeetCode 312th Weekly Contest",date:"2022-09-27T13:36:43.000Z",permalink:"/pages/e43306/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 313th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/06.LeetCode 313th Weekly Contest.md",wordsCount:"1.1k",readingTime:"5.6m",title:"LeetCode 313th Weekly Contest",date:"2022-10-07T17:52:09.000Z",permalink:"/pages/4c0651/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 88th Biweekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/07.LeetCode 88th Biweekly Contest.md",wordsCount:"1.2k",readingTime:"5.1m",title:"LeetCode 88th Biweekly Contest",date:"2022-10-07T18:21:10.000Z",permalink:"/pages/3ceb05/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"LeetCode 321th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/01.LeetCode周赛/01.Contests/08.LeetCode 321th Weekly Contest.md",wordsCount:"1.3k",readingTime:"6m",title:"LeetCode 321th Weekly Contest",date:"2022-11-28T16:56:39.000Z",permalink:"/pages/445c9b/",tags:["Competitive Programming","LeetCode周赛","Contests"]},{name:"Acwing 64th Weekly Contest",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/02.Acwing周赛/01.Contests/01.Acwing 64th Weekly Contest.md",wordsCount:857,readingTime:"4.1m",title:"Acwing 64th Weekly Contest",date:"2022-08-14T17:12:15.000Z",permalink:"/pages/29a8bf/",tags:["Competitive Programming","Acwing周赛","Contests"]},{name:"简简单单刷个题⑧",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/03.刷题日寄/01.简简单单刷个题⑧.md",wordsCount:791,readingTime:"4.5m",title:"简简单单刷个题⑧",date:"2023-01-12T15:45:56.000Z",permalink:"/pages/0b751d/",tags:["Competitive Programming","刷题日寄"]},{name:"洛谷P6510",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/04.题解/01.洛谷P6510.md",wordsCount:567,readingTime:"2.4m",title:"洛谷P6510",date:"2023-01-14T16:12:53.000Z",permalink:"/pages/bdac31/",tags:["Competitive Programming","题解"]},{name:"ABC283_F",filePath:"/Users/yra/Desktop/MyBlog/docs/01.Competitive Programming/04.题解/02.ABC283_F.md",wordsCount:854,readingTime:"4.2m",title:"ABC283_F",date:"2023-02-20T08:22:25.000Z",permalink:"/pages/285600/",tags:["Competitive Programming","题解"]},{name:"整理：基于着色Petri网的无人机侦察战术规划",filePath:"/Users/yra/Desktop/MyBlog/docs/02.Research/01.Paper Reading/01.Petri Net/01.整理：基于着色Petri网的无人机侦察战术规划.md",wordsCount:"2.4k",readingTime:"8.9m",title:"整理：基于着色Petri网的无人机侦察战术规划",date:"2022-08-13T23:35:57.000Z",permalink:"/pages/547f66/",tags:["Research","Paper Reading","Petri Net"]},{name:"Introduction",filePath:"/Users/yra/Desktop/MyBlog/docs/02.Research/02.Static Analysis/01.NJU Course Notes/01.Introduction.md",wordsCount:909,readingTime:"3.9m",title:"01 - Introduction",date:"2023-09-18T19:28:17.000Z",permalink:"/pages/2498ed/",tags:["Research","Static Analysis","NJU Course Notes"]},{name:"Intermediate Representation(IR)",filePath:"/Users/yra/Desktop/MyBlog/docs/02.Research/02.Static Analysis/01.NJU Course Notes/02.Intermediate Representation(IR).md",wordsCount:"1.6k",readingTime:"7.1m",title:"02 - Intermediate Representation(IR)",date:"2023-09-22T19:01:04.000Z",permalink:"/pages/6818d5/",tags:["Research","Static Analysis","NJU Course Notes"]},{name:"Dive into Deep Learning",filePath:"/Users/yra/Desktop/MyBlog/docs/02.Research/03.Deep Learning/01.Dive into Deep Learning.md",wordsCount:67,readingTime:"1",title:"Dive into Deep Learning",date:"2024-01-27T21:44:53.000Z",permalink:"/pages/382964/",tags:["AI","Deep Learning"]},{name:"Lab1: Unix utilities",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/01.Lab1: Unix utilities.md",wordsCount:"1.7k",readingTime:"7.6m",title:null,date:"2023-02-01T21:20:08.000Z",permalink:"/pages/80231f/",tags:["Learning Notes","System","6.S081"]},{name:"Lab10: Mmap",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/010.Lab10: Mmap.md",wordsCount:"2.7k",readingTime:"11.5m",title:null,date:"2023-02-24T20:38:13.000Z",permalink:"/pages/4708e0/",tags:["Learning Notes","System","6.S081"]},{name:"Lab2: System Calls",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/02.Lab2: System Calls.md",wordsCount:"1.7k",readingTime:"7.3m",title:null,date:"2023-02-06T12:26:04.000Z",permalink:"/pages/e84f04/",tags:["Learning Notes","System","6.S081"]},{name:"Lab3: Page Tables",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/03.Lab3: Page Tables.md",wordsCount:"1.1k",readingTime:"4.9m",title:null,date:"2023-02-08T21:23:53.000Z",permalink:"/pages/aa266f/",tags:["Learning Notes","System","6.S081"]},{name:"Lab4: Traps",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/04.Lab4: Traps.md",wordsCount:"1.3k",readingTime:"5.8m",title:null,date:"2023-02-11T17:09:39.000Z",permalink:"/pages/80245f/",tags:["Learning Notes","System","6.S081"]},{name:"Lab5: Copy-on-Write Fork for xv6",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/05.Lab5: Copy-on-Write Fork for xv6.md",wordsCount:"1.3k",readingTime:"6m",title:null,date:"2023-02-17T20:58:12.000Z",permalink:"/pages/810ff6/",tags:["Learning Notes","System","6.S081"]},{name:"Lab6: Multithreading",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/06.Lab6: Multithreading.md",wordsCount:978,readingTime:"4.7m",title:null,date:"2023-02-20T14:27:08.000Z",permalink:"/pages/2bb440/",tags:["Learning Notes","System","6.S081"]},{name:"Lab7: Networking",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/07.Lab7: Networking.md",wordsCount:376,readingTime:"1.9m",title:null,date:"2023-02-21T20:16:29.000Z",permalink:"/pages/b8b8a2/",tags:["Learning Notes","System","6.S081"]},{name:"Lab8: Locks",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/08.Lab8: Locks.md",wordsCount:"1.9k",readingTime:"8.8m",title:null,date:"2023-02-22T14:53:28.000Z",permalink:"/pages/19fce7/",tags:["Learning Notes","System","6.S081"]},{name:"Lab9: File System",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/01.System/01.MIT6.S081 | 21Fall/09.Lab9: File System.md",wordsCount:"1k",readingTime:"5.2m",title:null,date:"2023-02-23T22:56:16.000Z",permalink:"/pages/865884/",tags:["Learning Notes","System","6.S081"]},{name:"Lab0：Networking warmup",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/01.Lab0：Networking warmup.md",wordsCount:868,readingTime:"4.7m",title:null,date:"2023-03-10T22:47:05.000Z",permalink:"/pages/dda50b/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},{name:"Lab1：stitching substrings into a byte stream",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/02.Lab1：stitching substrings into a byte stream.md",wordsCount:"1.2k",readingTime:"5.2m",title:null,date:"2023-03-13T22:56:33.000Z",permalink:"/pages/dc39fe/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},{name:"Lab2：The TCP Receiver",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/03.Lab2：The TCP Receiver.md",wordsCount:"1.3k",readingTime:"5.4m",title:null,date:"2023-03-14T23:32:31.000Z",permalink:"/pages/875773/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},{name:"Lab3：The TCP Sender",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/04.Lab3：The TCP Sender.md",wordsCount:"1.4k",readingTime:"6.5m",title:null,date:"2023-03-18T17:30:17.000Z",permalink:"/pages/e12074/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},{name:"Lab4：The TCP Connection",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/02.Computer Networking/02.CS144：Computer Networking/05.Lab4：The TCP Connection.md",wordsCount:"3k",readingTime:"12.7m",title:null,date:"2023-03-18T21:55:35.000Z",permalink:"/pages/e07ff0/",tags:["Learning Notes","Computer Networking","CS144：Computer Networking"]},{name:"MySQL 问题整理",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/03.DataBase/01.MySQL/01.MySQL 问题整理.md",wordsCount:"3.4k",readingTime:"12.1m",title:"MySQL 问题整理",date:"2023-07-24T15:58:11.000Z",permalink:"/pages/498a73/",tags:["Learning Notes","DataBase","MySQL"]},{name:"Redis 缓冲区溢出问题总结 copy",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/03.DataBase/02.Redis/01.Redis 缓冲区溢出问题总结 copy.md",wordsCount:896,readingTime:"3.1m",title:"Redis 缓冲区溢出问题总结",date:"2023-08-16T11:38:13.000Z",permalink:"/pages/c32e71/",tags:["Learning Notes","DataBase","Redis"]},{name:"「缓存和数据库一致性问题」阅读笔记",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/03.DataBase/02.Redis/02.「缓存和数据库一致性问题」阅读笔记.md",wordsCount:"1.9k",readingTime:"6.7m",title:"「缓存和数据库一致性问题」阅读笔记",date:"2023-08-16T11:38:13.000Z",permalink:"/pages/aac048/",tags:["Learning Notes","DataBase","Redis"]},{name:"软工笔记01：概述",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/04.Software Engineering/01.THU Course Notes/01.软工笔记01：概述.md",wordsCount:404,readingTime:"1.4m",title:"01 - 概述",date:"2023-09-21T22:41:49.000Z",permalink:"/pages/15f315/",tags:["Learning Notes","Software Engineering"]},{name:"软工笔记02：软件过程",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/04.Software Engineering/01.THU Course Notes/02.软工笔记02：软件过程.md",wordsCount:829,readingTime:"3.6m",title:"02 - 软件过程",date:"2023-09-24T19:48:45.000Z",permalink:"/pages/7b3c38/",tags:["Learning Notes","Software Engineering"]},{name:"软工笔记03：用例建模",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/04.Software Engineering/01.THU Course Notes/03.软工笔记03：用例建模.md",wordsCount:906,readingTime:"4.5m",title:"03 - 用例建模",date:"2023-10-06T22:57:03.000Z",permalink:"/pages/d38254/",tags:["Learning Notes","Software Engineering"]},{name:"通过 Bit-Manipulation 实现 abs 函数",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/05.Others/01.通过 Bit-Manipulation 实现 abs 函数.md",wordsCount:321,readingTime:"1.3m",title:"通过 Bit-Manipulation 实现 abs 函数",date:"2022-09-10T21:46:17.000Z",permalink:"/pages/b04817/",tags:["Learning Notes","Others"]},{name:"408 计组笔记",filePath:"/Users/yra/Desktop/MyBlog/docs/03.Learning Notes/05.Others/02.408 计组笔记.md",wordsCount:"2.7k",readingTime:"10m",title:"408 计组笔记",date:"2024-07-19T16:27:05.000Z",permalink:"/pages/0e1ab0/",tags:[null]},{name:"【OOP】访问控制与继承",filePath:"/Users/yra/Desktop/MyBlog/docs/05.Programming Languages/01.CPP/01.【OOP】访问控制与继承.md",wordsCount:856,readingTime:"3.1m",title:"【OOP】访问控制与继承",date:"2022-10-31T18:43:58.000Z",permalink:"/pages/96615a/",tags:["Programming Languages","CPP"]},{name:"右值引用与std::move()",filePath:"/Users/yra/Desktop/MyBlog/docs/05.Programming Languages/01.CPP/02.右值引用与std::move().md",wordsCount:"1.8k",readingTime:"6.5m",title:"右值引用与std::move()",date:"2022-11-03T15:09:58.000Z",permalink:"/pages/03d2a3/",tags:["Programming Languages","CPP"]},{name:" Go 语言中的 GC 问题整理",filePath:"/Users/yra/Desktop/MyBlog/docs/05.Programming Languages/02.Golang/01. Go 语言中的 GC 问题整理.md",wordsCount:"1.5k",readingTime:"5.4m",title:"Go 语言中的 GC 问题整理",date:"2023-09-06T15:32:50.000Z",permalink:"/pages/f2991f/",tags:["Programming Languages","Golang"]},{name:" Go 语言中的 channel 相关问题整理",filePath:"/Users/yra/Desktop/MyBlog/docs/05.Programming Languages/02.Golang/02. Go 语言中的 channel 相关问题整理.md",wordsCount:634,readingTime:"2.3m",title:"Go 语言中的 Channel 相关问题整理",date:"2023-09-06T16:41:48.000Z",permalink:"/pages/843296/",tags:["Programming Languages","Golang"]},{name:"一些最近",filePath:"/Users/yra/Desktop/MyBlog/docs/x04.Casual Records/01.一些最近.md",wordsCount:"1.9k",readingTime:"6.5m",title:"一些最近",date:"2022-11-03T19:46:50.000Z",permalink:"/pages/018443/",tags:["Casual Records"]},{name:"25 考研随记",filePath:"/Users/yra/Desktop/MyBlog/docs/x04.Casual Records/02.25 考研随记.md",wordsCount:"15.8k",readingTime:"54.5m",title:"25 考研随记",date:"2023-11-27T22:15:22.000Z",permalink:"/pages/ef3649/",tags:["Casual Records"]}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500}}};var ul=t(123),dl=t(124),pl=t(20);var fl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(pl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(pl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(pl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(pl.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(pl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(ul.default),Vt.component(dl.default);function ml(n){return n.toString().padStart(2,"0")}t(278);Vt.component("BlockToggle",()=>Promise.all([t.e(0),t.e(23)]).then(t.bind(null,416))),Vt.component("PageInfo",()=>t.e(39).then(t.bind(null,417))),Vt.component("WebInfo",()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,412))),Vt.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,418))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,124))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,123)));t(279);var hl=t(121),gl=t.n(hl),vl=t(122),bl=t.n(vl),_l=t(45);let yl,xl;var kl;"valine"===(kl="gitalk")?t.e(96).then(t.t.bind(null,407,7)).then(n=>xl=n.default):"gitalk"===kl&&Promise.all([t.e(0),t.e(95)]).then(t.t.bind(null,408,7)).then(()=>t.e(94).then(t.t.bind(null,409,7))).then(n=>yl=n.default);function wl(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=bl.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${_l.name}@v${_l.version}:`,_l.homepage);const ql={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new yl(wl({clientID:"a0d9e14952e66cd548f6",clientSecret:"388e8efe891637dcf8dccdd7c5ad06c6f656afff",repo:"blog-gitalk-comment",owner:"Yra-A",admin:["Yra-A"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new xl({...wl({clientID:"a0d9e14952e66cd548f6",clientSecret:"388e8efe891637dcf8dccdd7c5ad06c6f656afff",repo:"blog-gitalk-comment",owner:"Yra-A",admin:["Yra-A"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Cl="vuepress-plugin-comment";let Tl=null;function Sl(n){return ql.gitalk.clear(Cl)}function Pl(n){return!1!==n.comment&&!1!==n.comments}function zl(n){clearTimeout(Tl);if(document.querySelector("main.page"))return ql.gitalk.render(n,Cl);Tl=setTimeout(()=>zl(n),200)}var Il={mounted(){Tl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Sl()&&Pl(n)&&zl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Sl()&&Pl(t)&&zl(t)})}},Ll=Object(sl.a)(Il,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,El=(t(130),t(284),t(285),[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${ml(n.getUTCMonth()+1)}-${ml(n.getUTCDate())} ${ml(n.getUTCHours())}:${ml(n.getUTCMinutes())}:${ml(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(fl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({Vue:n})=>n.use(gl.a),({Vue:n})=>{n.component("Comment",Ll)},({Vue:n})=>{const{ignoredElements:e}=n.config;e.every(n=>"/^mjx-/"!==n.toString())&&e.push(/^mjx-/)}]),Al=["BlockToggle","Comment"];class jl extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(jl.prototype,{getPageAsyncComponent:so,getLayoutAsyncComponent:oo,getAsyncComponent:lo,getVueComponent:co});var Nl={install(n){const e=new jl;n.$vuepress=e,n.prototype.$vuepress=e}};function Ol(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Rl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return po("pageKey",e),Vt.component(e)||Vt.component(e,so(e)),Vt.component(e)?n(e):n("")}},Bl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ml={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Dl=(t(286),t(287),Object(sl.a)(Ml,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),$l={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Ws),Vt.use(Nl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},cl)),Vt.component("Content",Rl),Vt.component("ContentSlotsDistributor",Bl),Vt.component("OutboundLink",Dl),Vt.component("ClientOnly",$l),Vt.component("Layout",oo("Layout")),Vt.component("NotFound",oo("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"87746e7"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:cl.routerBase||cl.base,t=new Ws({base:e,mode:"history",fallback:!1,routes:ll,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Ol(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Ol(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";Ol(n,i)?r(i):Ol(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(El.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:r,router:t,siteData:cl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Al.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);